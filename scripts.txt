class Game_Player < Game_Character  
  
  def jump(x_plus, y_plus)    
    
    super    
    
    @followers.each {|f| f.jump(@x - f.x, @y - f.y)}  
    
  end
  
  end





class Game_Actor < Game_Battler
  alias heal_on_level_up level_up
  #--------------------------------------------------------------------------
  # * Level Up
  #--------------------------------------------------------------------------
  def level_up
	heal_on_level_up
	@hp = mhp
	@mp = mmp
  end
end











#==============================================================================
# Michael Basic 8D
#==============================================================================
class Game_Map
  def x_with_direction(x, d)
   x + ((d == 9 || d == 6 || d == 3) ? 1 : ((d == 7 || d == 4 || d == 1) ? -1 : 0))
  end
  def y_with_direction(y, d)
   y + ((d == 1 || d == 2 || d == 3) ? 1 : ((d == 7 || d == 8 || d == 9) ? -1 : 0))
  end
  def round_x_with_direction(x, d)
   round_x(x + ((d == 9 || d == 6 || d == 3) ? 1 : ((d == 7 || d == 4 || d == 1) ? -1 : 0)))
  end
  def round_y_with_direction(y, d)
   round_y(y + ((d == 1 || d == 2 || d == 3) ? 1 : ((d == 7 || d == 8 || d == 9) ? -1 : 0)))
  end
end
class Game_Character < Game_CharacterBase
  def turn_right_90
   case @direction
     when 1; set_direction(7); when 2; set_direction(4)
     when 3; set_direction(1); when 4; set_direction(8)
     when 6; set_direction(2); when 7; set_direction(9)
     when 8; set_direction(6); when 9; set_direction(3)
   end
  end
  def turn_left_90
   case @direction
     when 1; set_direction(3); when 2; set_direction(6)
     when 3; set_direction(9); when 4; set_direction(2)
     when 6; set_direction(8); when 7; set_direction(1)
     when 8; set_direction(4); when 9; set_direction(7)
   end
  end
end
class Game_Player < Game_Character
  def move_by_input
   return if !movable? || $game_map.interpreter.running?
   case Input.dir8
     when 2,4,6,8; move_straight(Input.dir8)
     when 1; move_diagonal(4, 2); when 3; move_diagonal(6, 2)
     when 7; move_diagonal(4, 8); when 9; move_diagonal(6, 8)
   else; end
  end
end





#==============================================================================
# 
# �� Yanfly Engine Ace - Ace Battle Engine v1.22
# -- Last Updated: 2012.03.04
# -- Level: Normal, Hard
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-BattleEngine"] = true

#==============================================================================
# �� Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.03.04 - Bug fixed: Input crash bug.
# 2012.02.13 - Bug fixed: Odd Victory game crash fixed.
# 2012.02.12 - Bug fixed: Displayed damage in combat log is correct now.
# 2012.01.29 - Visual Changes: Buff stacks now show one popup upon one skill.
# 2012.01.24 - Compatibility Update: Enemy Levels
# 2012.01.18 - Bug Fixed: Help Window clears text upon selecting nil items.
# 2012.01.11 - Added <one animation> tag for multi-hit skills to play an
#              animation only once.
#            - Reduced lag from battle system constantly recreating bitmaps.
# 2012.01.10 - Compatibility Update: Battle System FTB
# 2012.01.09 - Anticrash methods implemented.
#            - Damage Popups are now separate for damage formulas and recovery.
# 2012.01.05 - Bug fixed: Game no longer crashes with escape skills/items.
# 2012.01.02 - Compatibility Update: Target Manager
#            - Added Option: AUTO_FAST
#            - Random hits now show animations individually.
# 2011.12.30 - Compatibility Update: Enemy Levels
#            - Added Option to center the actors in the HUD.
# 2011.12.27 - Bug fixed: TP Damage skills and items no longer crash game.
#            - Default battle system bug fixes are now included from YEA's Ace
#              Core Engine.
#            - Groundwork is also made to support future battle system types.
#            - Multi-hit actions no longer linger when a target dies during the
#              middle of one of the hits.
#            - Compatibility Update: Lunatic Objects v1.02
# 2011.12.26 - Bug fixed: Multi-hit popups occured even after an enemy's dead.
# 2011.12.22 - Bug fixed: Elemental Resistance popup didn't show.
# 2011.12.20 - Bug fixed: Death state popups against immortal states.
#            - Bug fixed: During State popup fix.
#            - Added HIDE_POPUP_SWITCH.
# 2011.12.17 - Compatibiilty Update: Cast Animations
# 2011.12.15 - Compatibility Update: Battle Command List
# 2011.12.14 - Compatibility Update: Lunatic Objects
# 2011.12.13 - Compatibility Update: Command Party
# 2011.12.12 - Bug fixed: Turn stalling if no inputable members.
# 2011.12.10 - Compatibility update for Automatic Party HUD.
#            - Popup graphical bug fixed.
#            - Bug fixed: Didn't wait for boss dead animations.
#            - Bug fixed: Surprise attacks that froze the game.
#            - Bug fixed: Popups didn't show for straight recovery effects.
# 2011.12.08 - Finished Script.
# 2011.12.04 - Started Script.
# 
#==============================================================================
# �� Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# Ace Battle Engine works as a foundation for future battle engine add-ons. It
# allows for easier management of the battle engine without adding too many
# features, allowing users to customize what they want as they see fit. While
# the Ace Battle Engine isn't an entirely new engine, it gives users control
# that RPG Maker VX Ace didn't originally give them.
# 
# Furthermore, this script provides some new features. They are as follows:
# 
# -----------------------------------------------------------------------------
# Animation Fixes
# -----------------------------------------------------------------------------
# Though the Yanfly Engine Ace - Ace Core Engine script contains these fixes,
# these fixes are included in this script as well to ensure it's working for
# the battle script in the event someone chooses not to work with the Ace Core
# Engine script. The animation fixes prevent excessive animation overlaying
# (and making the screen look really ugly) and prevents animation clashing
# between two dual wielding normal attack animations.
# 
# -----------------------------------------------------------------------------
# Enemy Animations
# -----------------------------------------------------------------------------
# Enemies now show battle animations when they deliver attacks and skills
# against the player's party. Before in RPG Maker VX Ace, it was nothing more
# than just sound effects and the screen shaking. Now, animations play where
# the status window is and relative to the position of each party member.
# 
# -----------------------------------------------------------------------------
# Left/Right Command Selection
# -----------------------------------------------------------------------------
# While choosing actions, the player can press Left or Right to move freely
# between (alive) actors to change their skills. Players no longer have to
# cancel all the way back to change one person's skill and reselect everything.
# On that note, there is now the option that when a battle starts or at the
# end of a turn, players will start immediately at command selection rather
# than needing to select "Fight" in the Party Command Window.
# 
# -----------------------------------------------------------------------------
# Popups
# -----------------------------------------------------------------------------
# Dealing damage, inflicting states, adding buffs, landing critical hits,
# striking weaknesses, missing attacks, you name it, there's probably a popup
# for it. Popups deliver information to the player in a quick or orderly
# fashion without requiring the player to read lines of text.
# 
# -----------------------------------------------------------------------------
# Targeting Window
# -----------------------------------------------------------------------------
# When targeting enemies, the window is no longer displayed. Instead, the
# targeted enemies are highlighted and their names are shown at the top of the
# screen in a help window. Another thing that's changed is when skills that
# target multiple targets are selected, there is a confirmation step that the
# player must take before continuing. In this confirmation step, all of the
# multiple targets are selected and in the help window would display the scope
# of the skill (such as "All Foes" or "Random Foes"). RPG Maker VX Ace skipped
# this step by default.
# 
# -----------------------------------------------------------------------------
# Toggling On and Off Special Effects and Text
# -----------------------------------------------------------------------------
# Not everybody likes having the screen shake or the enemies blink when they
# take damage. These effects can now be toggled on and off. Certain text can
# also be toggled on and off from appearing. A lot of the displayed text has
# been rendered redundant through the use of popups.
# 
# -----------------------------------------------------------------------------
# Visual Battle Status Window
# -----------------------------------------------------------------------------
# Rather than just having rows of names with HP and MP bars next to them, the
# Battle Status Window now displays actors' faces and their gauges aligned at
# the bottom. More status effects can be shown in addition to showing more
# members on screen at once. The Battle Status Window is also optimized to
# refresh less (thus, removing potential lag from the system).
# 
# -----------------------------------------------------------------------------
# Window Position Changes
# -----------------------------------------------------------------------------
# Windows such as the Skill Window and Item Window have been rearranged to
# always provide the player a clear view of the battlefield rather than opening
# up and covering everything. As such, the window positions are placed at the
# bottom of the screen and are repositioned.
# 
#==============================================================================
# �� Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below �� Materials/�f�� but above �� Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Skill Notetags - These notetags go in the skills notebox in the database.
# -----------------------------------------------------------------------------
# <one animation>
# Causes the action to display the action animation only once, even if it's a
# multi-hit action. This is used primarily for non-all scope targeting.
# 
# -----------------------------------------------------------------------------
# Item Notetags - These notetags go in the items notebox in the database.
# -----------------------------------------------------------------------------
# <one animation>
# Causes the action to display the action animation only once, even if it's a
# multi-hit action. This is used primarily for non-all scope targeting.
# 
# -----------------------------------------------------------------------------
# Enemy Notetags - These notetags go in the enemy notebox in the database.
# -----------------------------------------------------------------------------
# <atk ani 1: x>
# <atk ani 2: x>
# Changes the normal attack animation of the particular enemy to animation x.
# Attack animation 1 is the first one that plays. If there's a second animation
# then the second one will play after in mirrored form.
# 
# -----------------------------------------------------------------------------
# State Notetags - These notetags go in the state notebox in the database.
# -----------------------------------------------------------------------------
# <popup add: string>
# <popup rem: string>
# <popup dur: string>
# Status effects now create popups whenever they're inflicted. However, if you
# don't like that a certain status effect uses a particular colour setting,
# change "string" to one of the rulesets below to cause that popup to use a
# different ruleset.
# 
# <popup hide add>
# <popup hide rem>
# <popup hide dur>
# Not everybody wants status effects to show popups when inflicted. When this
# is the case, insert the respective tag to hide popups from appearing when the
# state is added, removed, or during the stand-by phases.
# 
# -----------------------------------------------------------------------------
# Debug Tools - These tools only work during Test Play.
# -----------------------------------------------------------------------------
# - F5 Key -
# Recovers all actors. Restores their HP and MP to max. Does not affect TP.
# All states and buffs are removed whether they are positive or negative.
# 
# - F6 Key -
# Sets all actors to have 1 HP, 0 MP, and 0 TP. States are unaffected.
# 
# - F7 Key -
# Sets all actors to have max TP. Everything else is unaffected.
# 
# - F8 Key -
# Kills all enemies in battle. Ends the battle quickly.
# 
#==============================================================================
# �� Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module BATTLE
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Battle Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings are adjusted for the overall battle system. These are
    # various miscellaneous options to adjust. Each of the settings below will
    # explain what they do. Change default enemy battle animations here, too.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    BLINK_EFFECTS      = false  # Blink sprite when damaged?
    FLASH_WHITE_EFFECT = true   # Flash enemy white when it starts an attack.
    SCREEN_SHAKE       = false  # Shake screen in battle?
    SKIP_PARTY_COMMAND = true   # Skips the Fight/Escape menu.
    AUTO_FAST          = true   # Causes message windows to not wait.
    ENEMY_ATK_ANI      = 36     # Sets default attack animation for enemies.
    
    # If this switch is ON, popups will be hidden. If OFF, the popups will be
    # shown. If you do not wish to use this switch, set it to 0.
    HIDE_POPUP_SWITCH  = 0
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Battle Status Window -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This sets the default battle system your game will use. If your game
    # doesn't have any other battle systems installed, it will use :dtb.
    # 
    # Battle System        Requirement
    #   :dtb               - Default Turn Battle. Default system.
    #   :ftb               - YEA Battle System Add-On: Free Turn Battle
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    DEFAULT_BATTLE_SYSTEM = :dtb     # Default battle system set.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Battle Status Window -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Here, you can adjust the settings for the battle status window. The
    # battle status window, by default, will show the actor's face, HP, MP, TP
    # (if viable), and any inflicted status effects.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    BATTLESTATUS_NAME_FONT_SIZE = 20    # Font size used for name.
    BATTLESTATUS_TEXT_FONT_SIZE = 16    # Font size used for HP, MP, TP.
    BATTLESTATUS_NO_ACTION_ICON = 185   # No action icon.
    BATTLESTATUS_HPGAUGE_Y_PLUS = 11    # Y Location buffer used for HP gauge.
    BATTLESTATUS_CENTER_FACES   = false # Center faces for the Battle Status.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Help Window Text -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # When selecting a target to attack, this is the text that will be shown
    # in place of a target's name for special cases. These special cases are
    # for selections that were originally non-targetable battle scopes.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    HELP_TEXT_ALL_FOES        = "All Foes"
    HELP_TEXT_ONE_RANDOM_FOE  = "One Random Foe"
    HELP_TEXT_MANY_RANDOM_FOE = "%d Random Foes"
    HELP_TEXT_ALL_ALLIES      = "All Allies"
    HELP_TEXT_ALL_DEAD_ALLIES = "All Dead Allies"
    HELP_TEXT_ONE_RANDOM_ALLY = "One Random Ally"
    HELP_TEXT_RANDOM_ALLIES   = "%d Random Allies"
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Popup Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings will adjust the popups that appear in battle. Popups
    # deliver information to your player as battlers deal damage, inflict
    # status effects, and more.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ENABLE_POPUPS  = true     # Set this to false if you wish to disable them.
    FLASH_CRITICAL = true     # Sets critical hits to flash.
    
    # This hash adjusts the popup settings that will govern how popups appear.
    # Adjust them accordingly.
    POPUP_SETTINGS ={
      :offset     => -24,         # Height offset of a popup.
      :fade       => 12,          # Fade rate for each popup.
      :full       => 60,          # Frames before a popup fades.
      :hp_dmg     => "-%s ",      # SprintF for HP damage.
      :hp_heal    => "+%s ",      # SprintF for HP healing.
      :mp_dmg     => "-%s MP",    # SprintF for MP damage.
      :mp_heal    => "+%s MP",    # SprintF for MP healing.
      :tp_dmg     => "-%s TP",    # SprintF for MP damage.
      :tp_heal    => "+%s TP",    # SprintF for MP healing.
      :drained    => "DRAIN",     # Text display for draining HP/MP.
      :critical   => "CRITICAL!", # Text display for critical hit.
      :missed     => "MISS",      # Text display for missed attack.
      :evaded     => "EVADE!",    # Text display for evaded attack.
      :nulled     => "NULL",      # Text display for nulled attack.
      :failed     => "FAILED",    # Text display for a failed attack.
      :add_state  => "+%s",      # SprintF for added states.
      :rem_state  => "-%s",      # SprintF for removed states.
      :dur_state  => "%s",        # SprintF for during states.
      :ele_rates  => true,        # This will display elemental affinities.
      :ele_wait   => 20,          # This is how many frames will wait.
      :weakpoint  => "WEAKPOINT", # Appears if foe is weak to element.
      :resistant  => "RESIST",    # Appears if foe is resistant to element.
      :immune     => "IMMUNE",    # Appears if foe is immune to element.
      :absorbed   => "ABSORB",    # Appears if foe can absorb the element.
      :add_buff   => "%s�{",      # Appears when a positive buff is applied.
      :add_debuff => "%s�|",      # Appears when a negative buff is applied.
    } # Do not remove this.
    
    # This is the default font used for the popups. Adjust them accordingly
    # or even add new ones.
    DEFAULT = ["VL Gothic", "Verdana", "Arial", "Courier"]
    
    # The following are the various rules that govern the individual popup
    # types that will appear. Adjust them accordingly. Here is a list of what
    # each category does.
    #   Zoom1    The zoom the popup starts at. Values over 2.0 may cause lag.
    #   Zoom2    The zoom the popup goes to. Values over 2.0 may cause lag.
    #   Sz       The font size used for the popup text.
    #   Bold     Applying bold for the popup text.
    #   Italic   Applying italic for the popup text.
    #   Red      The red value of the popup text.
    #   Grn      The green value of the popup text.
    #   Blu      The blue value of the popup text.
    #   Font     The font used for the popup text.
    POPUP_RULES ={
      # Type     => [ Zoom1, Zoom2, Sz, Bold, Italic, Red, Grn, Blu, Font]
      "DEFAULT"  => [   2.0,   1.0, 24, true,  false, 255, 255, 255, DEFAULT],
      "CRITICAL" => [   2.0,   1.0, 24, true,  false, 255,  80,  80, DEFAULT], 
      "HP_DMG"   => [   2.0,   1.0, 36, true,  false, 255, 255, 255, DEFAULT], 
      "HP_HEAL"  => [   2.0,   1.0, 36, true,  false, 130, 250, 130, DEFAULT], 
      "MP_DMG"   => [   2.0,   1.0, 36, true,  false, 220, 180, 255, DEFAULT], 
      "MP_HEAL"  => [   2.0,   1.0, 36, true,  false, 160, 230, 255, DEFAULT], 
      "TP_DMG"   => [   2.0,   1.0, 36, true,  false, 242, 108,  78, DEFAULT], 
      "TP_HEAL"  => [   2.0,   1.0, 36, true,  false, 251, 175,  92, DEFAULT], 
      "ADDSTATE" => [   2.0,   1.0, 24, true,  false, 240, 100, 100, DEFAULT], 
      "REMSTATE" => [   2.0,   1.0, 24, true,  false, 125, 170, 225, DEFAULT], 
      "DURSTATE" => [   2.0,   1.0, 24, true,  false, 255, 240, 150, DEFAULT], 
      "DRAIN"    => [   2.0,   1.0, 36, true,  false, 250, 190, 255, DEFAULT], 
      "POSITIVE" => [   2.0,   1.0, 24, true,  false, 110, 210, 245, DEFAULT], 
      "NEGATIVE" => [   2.0,   1.0, 24, true,  false, 245, 155, 195, DEFAULT], 
      "WEAK_ELE" => [   0.5,   1.0, 24, true,  false, 240, 110,  80, DEFAULT], 
      "IMMU_ELE" => [   0.5,   1.0, 24, true,  false, 185, 235, 255, DEFAULT], 
      "REST_ELE" => [   0.5,   1.0, 24, true,  false, 145, 230, 180, DEFAULT], 
      "ABSB_ELE" => [   0.5,   1.0, 24, true,  false, 250, 190, 255, DEFAULT], 
      "BUFF"     => [   2.0,   1.0, 24, true,  false, 255, 240, 100, DEFAULT], 
      "DEBUFF"   => [   2.0,   1.0, 24, true,  false, 160, 130, 200, DEFAULT], 
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Streamlined Messages -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Want to remove some of those annoying messages that appear all the time?
    # Now you can! Select which messages you want to enable or disable. Some of
    # these messages will be rendered useless due to popups.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    MSG_ENEMY_APPEARS  = false  # Message when enemy appears start of battle.
    MSG_CURRENT_STATE  = false  # Show which states has affected battler.
    MSG_CURRENT_ACTION = true   # Show the current action of the battler.
    MSG_COUNTERATTACK  = true   # Show the message for a counterattack.
    MSG_REFLECT_MAGIC  = true   # Show message for reflecting magic attacks.
    MSG_SUBSTITUTE_HIT = true   # Show message for ally taking another's hit.
    MSG_FAILURE_HIT    = false  # Show effect failed against target.
    MSG_CRITICAL_HIT   = false  # Show attack was a critical hit.
    MSG_HIT_MISSED     = false  # Show attack missed the target.
    MSG_EVASION        = false  # Show attack was evaded by the target.
    MSG_HP_DAMAGE      = true  # Show HP damage to target.
    MSG_MP_DAMAGE      = true  # Show MP damage to target.
    MSG_TP_DAMAGE      = false  # Show TP damage to target.
    MSG_ADDED_STATES   = false  # Show target's added states.
    MSG_REMOVED_STATES = false  # Show target's removed states.
    MSG_CHANGED_BUFFS  = false  # Show target's changed buffs.
    
  end # BATTLE
end # YEA

#==============================================================================
# �� Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

module YEA
  module REGEXP
  module ENEMY
    
    ATK_ANI1 = /<(?:ATK_ANI_1|atk ani 1):[ ]*(\d+)>/i
    ATK_ANI2 = /<(?:ATK_ANI_2|atk ani 2):[ ]*(\d+)>/i
    
  end # ENEMY
  module USABLEITEM
    
    ONE_ANIMATION = /<(?:ONE_ANIMATION|one animation)>/i
    
  end # USABLEITEM
  module STATE
    
    POPUP_ADD = /<(?:POPUP_ADD_RULE|popup add rule|popup add):[ ](.*)>/i
    POPUP_REM = /<(?:POPUP_REM_RULE|popup rem rule|popup rem):[ ](.*)>/i
    POPUP_DUR = /<(?:POPUP_DUR_RULE|popup dur rule|popup dur):[ ](.*)>/i
    
    HIDE_ADD  = /<(?:POPUP_HIDE_ADD|popup hide add|hide add)>/i
    HIDE_REM  = /<(?:POPUP_HIDE_REM|popup hide rem|hide rem)>/i
    HIDE_DUR  = /<(?:POPUP_HIDE_DUR|popup hide dur|hide dur)>/i
    
  end # STATE
  end # REGEXP
end # YEA

#==============================================================================
# �� Switch
#==============================================================================

module Switch
  
  #--------------------------------------------------------------------------
  # self.hide_popups
  #--------------------------------------------------------------------------
  def self.hide_popups
    return false if YEA::BATTLE::HIDE_POPUP_SWITCH <= 0
    return $game_switches[YEA::BATTLE::HIDE_POPUP_SWITCH]
  end
  
end # Switch

#==============================================================================
# �� Colour
#==============================================================================

module Colour
  
  #--------------------------------------------------------------------------
  # self.text_colour
  #--------------------------------------------------------------------------
  def self.text_colour(index)
    windowskin = Cache.system("Window")
    x = 64 + (index % 8) * 8
    y = 96 + (index / 8) * 8
    return windowskin.get_pixel(x, y)
  end
  
end # Colour

#==============================================================================
# �� Icon
#==============================================================================

module Icon
  
  #--------------------------------------------------------------------------
  # self.no_action
  #--------------------------------------------------------------------------
  def self.no_action; return YEA::BATTLE::BATTLESTATUS_NO_ACTION_ICON; end
    
end # Icon

#==============================================================================
# �� Numeric
#==============================================================================

class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric

#==============================================================================
# �� DataManager
#==============================================================================

module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_abe load_database; end
  def self.load_database
    load_database_abe
    load_notetags_abe
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_abe
  #--------------------------------------------------------------------------
  def self.load_notetags_abe
    groups = [$data_enemies, $data_states, $data_skills, $data_items]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_abe
      end
    end
  end
  
end # DataManager

#==============================================================================
# �� RPG::UsableItem
#==============================================================================

class RPG::UsableItem < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :one_animation
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_abe
  #--------------------------------------------------------------------------
  def load_notetags_abe
    @one_animation = false
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::USABLEITEM::ONE_ANIMATION
        @one_animation = true
      end
    } # self.note.split
    #---
  end
  
end # RPG::UsableItem

#==============================================================================
# �� RPG::Enemy
#==============================================================================

class RPG::Enemy < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :atk_animation_id1
  attr_accessor :atk_animation_id2
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_abe
  #--------------------------------------------------------------------------
  def load_notetags_abe
    @atk_animation_id1 = YEA::BATTLE::ENEMY_ATK_ANI
    @atk_animation_id2 = 0
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::ENEMY::ATK_ANI1
        @atk_animation_id1 = $1.to_i
      when YEA::REGEXP::ENEMY::ATK_ANI2
        @atk_animation_id2 = $1.to_i
      end
    } # self.note.split
    #---
  end
  
end # RPG::Enemy

#==============================================================================
# �� RPG::Enemy
#==============================================================================

class RPG::State < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :popup_rules
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_abe
  #--------------------------------------------------------------------------
  def load_notetags_abe
    @popup_rules = { 
      :add_state => "ADDSTATE", 
      :rem_state => "REMSTATE", 
      :dur_state => nil
    } # Do not remove this.
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::STATE::POPUP_ADD
        @popup_rules[:add_state] = $1.upcase.to_s
      when YEA::REGEXP::STATE::POPUP_REM
        @popup_rules[:rem_state] = $1.upcase.to_s
      when YEA::REGEXP::STATE::POPUP_DUR
        @popup_rules[:dur_state] = $1.upcase.to_s
      when YEA::REGEXP::STATE::HIDE_ADD
        @popup_rules[:add_state] = nil
      when YEA::REGEXP::STATE::HIDE_REM
        @popup_rules[:rem_state] = nil
      when YEA::REGEXP::STATE::HIDE_DUR
        @popup_rules[:dur_state] = nil
      end
    } # self.note.split
    #---
  end
  
end # RPG::State

#==============================================================================
# �� BattleManager
#==============================================================================

module BattleManager
  
  #--------------------------------------------------------------------------
  # overwrite method: self.battle_start
  #--------------------------------------------------------------------------
  def self.battle_start
    $game_system.battle_count += 1
    $game_party.on_battle_start
    $game_troop.on_battle_start
    return unless YEA::BATTLE::MSG_ENEMY_APPEARS
    $game_troop.enemy_names.each do |name|
      $game_message.add(sprintf(Vocab::Emerge, name))
    end
    if @preemptive
      $game_message.add(sprintf(Vocab::Preemptive, $game_party.name))
    elsif @surprise
      $game_message.add(sprintf(Vocab::Surprise, $game_party.name))
    end
    wait_for_message
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: make_action_orders
  #--------------------------------------------------------------------------
  def self.make_action_orders
    make_dtb_action_orders if btype?(:dtb)
  end
  
  #--------------------------------------------------------------------------
  # new method: make_dtb_action_orders
  #--------------------------------------------------------------------------
  def self.make_dtb_action_orders
    @action_battlers = []
    @action_battlers += $game_party.members unless @surprise
    @action_battlers += $game_troop.members unless @preemptive
    @action_battlers.each {|battler| battler.make_speed }
    @action_battlers.sort! {|a,b| b.speed - a.speed }
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: turn_start
  #--------------------------------------------------------------------------
  def self.turn_start
    @phase = :turn
    clear_actor
    $game_troop.increase_turn
    @performed_battlers = []
    make_action_orders
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: next_subject
  #--------------------------------------------------------------------------
  def self.next_subject
    @performed_battlers = [] if @performed_battlers.nil?
    loop do
      @action_battlers -= @performed_battlers
      battler = @action_battlers.shift
      return nil unless battler
      next unless battler.index && battler.alive?
      @performed_battlers.push(battler)
      return battler
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: force_action
  #--------------------------------------------------------------------------
  def self.force_action(battler)
    @action_forced = [] if @action_forced == nil
    @action_forced.push(battler)
    return unless Switch.forced_action_remove
    @action_battlers.delete(battler)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: action_forced?
  #--------------------------------------------------------------------------
  def self.action_forced?
    @action_forced != nil
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: action_forced_battler
  #--------------------------------------------------------------------------
  def self.action_forced_battler
    @action_forced.shift
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: clear_action_force
  #--------------------------------------------------------------------------
  def self.clear_action_force
    return if @action_forced.nil?
    @action_forced = nil if @action_forced.empty?
  end
  
  #--------------------------------------------------------------------------
  # new method: self.init_battle_type
  #--------------------------------------------------------------------------
  def self.init_battle_type
    set_btype($game_system.battle_system)
  end
  
  #--------------------------------------------------------------------------
  # new method: self.set_btype
  #--------------------------------------------------------------------------
  def self.set_btype(btype = :dtb)
    @battle_type = btype
  end
  
  #--------------------------------------------------------------------------
  # new method: self.btype?
  #--------------------------------------------------------------------------
  def self.btype?(btype)
    return @battle_type == btype
  end
  
end # BattleManager

#==============================================================================
# �� Game_System
#==============================================================================

class Game_System
  
  #--------------------------------------------------------------------------
  # new method: battle_system
  #--------------------------------------------------------------------------
  def battle_system
    if @battle_system.nil?
      return battle_system_corrected(YEA::BATTLE::DEFAULT_BATTLE_SYSTEM)
    else
      return battle_system_corrected(@battle_system)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: set_battle_system
  #--------------------------------------------------------------------------
  def set_battle_system(type)
    case type
    when :dtb; @battle_system = :dtb
    when :ftb; @battle_system = $imported["YEA-BattleSystem-FTB"] ? :ftb : :dtb
    else;      @battle_system = :dtb
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: battle_system_corrected
  #--------------------------------------------------------------------------
  def battle_system_corrected(type)
    case type
    when :dtb; return :dtb
    when :ftb; return $imported["YEA-BattleSystem-FTB"] ? :ftb : :dtb
    else;      return :dtb
    end
  end
  
end # Game_System

#==============================================================================
# �� Sprite_Base
#==============================================================================

class Sprite_Base < Sprite
  
  #--------------------------------------------------------------------------
  # new method: start_pseudo_animation
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def start_pseudo_animation(animation, mirror = false)
    dispose_animation
    @animation = animation
    return if @animation.nil?
    @ani_mirror = mirror
    set_animation_rate
    @ani_duration = @animation.frame_max * @ani_rate + 1
    @ani_sprites = []
  end
  end # $imported["YEA-CoreEngine"]
  
end # Sprite_Base

#==============================================================================
# �� Sprite_Battler
#==============================================================================

class Sprite_Battler < Sprite_Base
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :effect_type
  attr_accessor :battler_visible
  attr_accessor :popups
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias sprite_battler_initialize_abe initialize
  def initialize(viewport, battler = nil)
    sprite_battler_initialize_abe(viewport, battler)
    @popups = []
    @popup_flags = []
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_bitmap
  #--------------------------------------------------------------------------
  alias sprite_battler_update_bitmap_abe update_bitmap
  def update_bitmap
    return if @battler.actor? && @battler.battler_name == ""
    sprite_battler_update_bitmap_abe
  end
  
  #--------------------------------------------------------------------------
  # alias method: setup_new_animation
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  alias sprite_battler_setup_new_animation_abe setup_new_animation
  def setup_new_animation
    sprite_battler_setup_new_animation_abe
    return if @battler.pseudo_ani_id <= 0
    animation = $data_animations[@battler.pseudo_ani_id]
    mirror = @battler.animation_mirror
    start_pseudo_animation(animation, mirror)
    @battler.pseudo_ani_id = 0
  end
  end # $imported["YEA-CoreEngine"]
  
  #--------------------------------------------------------------------------
  # alias method: setup_new_effect
  #--------------------------------------------------------------------------
  alias sprite_battler_setup_new_effect_abe setup_new_effect
  def setup_new_effect
    sprite_battler_setup_new_effect_abe
    setup_popups
  end
  
  #--------------------------------------------------------------------------
  # new method: setup_popups
  #--------------------------------------------------------------------------
  def setup_popups
    return unless @battler.use_sprite?
    @battler.popups = [] if @battler.popups.nil?
    return if @battler.popups == []
    array = @battler.popups.shift
    create_new_popup(array[0], array[1], array[2])
  end
  
  #--------------------------------------------------------------------------
  # new method: create_new_popup
  #--------------------------------------------------------------------------
  def create_new_popup(value, rules, flags)
    return if @battler == nil
    return if flags & @popup_flags != []
    array = YEA::BATTLE::POPUP_RULES[rules]
    for popup in @popups
      popup.y -= 24
    end
    return unless SceneManager.scene.is_a?(Scene_Battle)
    return if SceneManager.scene.spriteset.nil?
    view = SceneManager.scene.spriteset.viewportPopups
    new_popup = Sprite_Popup.new(view, @battler, value, rules, flags)
    @popups.push(new_popup)
    @popup_flags.push("weakness") if flags.include?("weakness")
    @popup_flags.push("resistant") if flags.include?("resistant")
    @popup_flags.push("immune") if flags.include?("immune")
    @popup_flags.push("absorbed") if flags.include?("absorbed")
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_effect
  #--------------------------------------------------------------------------
  alias sprite_battler_update_effect_abe update_effect
  def update_effect
    sprite_battler_update_effect_abe
    update_popups
  end
  
  #--------------------------------------------------------------------------
  # new method: update_popups
  #--------------------------------------------------------------------------
  def update_popups
    for popup in @popups
      popup.update
      next unless popup.opacity <= 0
      popup.bitmap.dispose
      popup.dispose
      @popups.delete(popup)
      popup = nil
    end
    @popup_flags = [] if @popups == [] && @popup_flags != []
    return unless SceneManager.scene_is?(Scene_Battle)
    if @current_active_battler != SceneManager.scene.subject
      @current_active_battler = SceneManager.scene.subject
      @popup_flags = []
    end
  end
  
end # Sprite_Battler

#==============================================================================
# �� Sprite_Popup
#==============================================================================

class Sprite_Popup < Sprite_Base
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :flags
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(viewport, battler, value, rules, flags)
    super(viewport)
    @value = value
    @rules = rules
    @rules = "DEFAULT" unless YEA::BATTLE::POPUP_RULES.include?(@rules)
    @fade = YEA::BATTLE::POPUP_SETTINGS[:fade]
    @full = YEA::BATTLE::POPUP_SETTINGS[:full]
    @flags = flags
    @battler = battler
    create_popup_bitmap
  end
  
  #--------------------------------------------------------------------------
  # create_popup_bitmap
  #--------------------------------------------------------------------------
  def create_popup_bitmap
    rules_array = YEA::BATTLE::POPUP_RULES[@rules]
    bw = Graphics.width
    bw += 48 if @flags.include?("state")
    bh = Font.default_size * 3
    bitmap = Bitmap.new(bw, bh)
    bitmap.font.name = rules_array[8]
    size = @flags.include?("critical") ? rules_array[2] * 1.2 : rules_array[2]
    bitmap.font.size = size
    bitmap.font.bold = rules_array[3]
    bitmap.font.italic = rules_array[4]
    if flags.include?("critical")
      crit = YEA::BATTLE::POPUP_RULES["CRITICAL"]
      bitmap.font.out_color.set(crit[5], crit[6], crit[7], 255)
    else
      bitmap.font.out_color.set(0, 0, 0, 255)
    end
    dx = 0; dy = 0; dw = 0
    dx += 24 if @flags.include?("state")
    dw += 24 if @flags.include?("state")
    if @flags.include?("state") || @flags.include?("buff")
      c_width = bitmap.text_size(@value).width
      icon_bitmap = $game_temp.iconset
      icon_index = flag_state_icon
      rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
      bitmap.blt(dx+(bw-c_width)/2-36, (bh - 24)/2, icon_bitmap, rect, 255)
    end
    bitmap.font.color.set(rules_array[5], rules_array[6], rules_array[7])
    bitmap.draw_text(dx, dy, bw-dw, bh, @value, 1)
    self.bitmap = bitmap
    self.x = @battler.screen_x
    self.x += rand(4) - rand(4) if @battler.sprite.popups.size >= 1
    self.x -= SceneManager.scene.spriteset.viewport1.ox
    self.y = @battler.screen_y - @battler.sprite.oy/2
    self.y -= @battler.sprite.oy/2 if @battler.actor?
    self.y -= SceneManager.scene.spriteset.viewport1.oy
    self.ox = bw/2; self.oy = bh/2
    self.zoom_x = self.zoom_y = rules_array[0]
    if @flags.include?("no zoom")
      self.zoom_x = self.zoom_y = rules_array[1]
    end
    @target_zoom = rules_array[1]
    @zoom_direction = (self.zoom_x > @target_zoom) ? "down" : "up"
    self.z = 500
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    #---
    if @flags.include?("critical") && YEA::BATTLE::FLASH_CRITICAL
      @hue_duration = 2 if @hue_duration == nil || @hue_duration == 0
      @hue_duration -= 1
      self.bitmap.hue_change(15) if @hue_duration <= 0
    end
    #---
    if @zoom_direction == "up"
      self.zoom_x = [self.zoom_x + 0.075, @target_zoom].min
      self.zoom_y = [self.zoom_y + 0.075, @target_zoom].min
    else
      self.zoom_x = [self.zoom_x - 0.075, @target_zoom].max
      self.zoom_y = [self.zoom_y - 0.075, @target_zoom].max
    end
    #---
    @full -= 1
    return if @full > 0
    self.y -= 1
    self.opacity -= @fade
  end
  
  #--------------------------------------------------------------------------
  # flag_state_icon
  #--------------------------------------------------------------------------
  def flag_state_icon
    for item in @flags; return item if item.is_a?(Integer); end
    return 0
  end
  
end # Sprite_Popup

#==============================================================================
# �� Spriteset_Battle
#==============================================================================

class Spriteset_Battle
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :actor_sprites
  attr_accessor :enemy_sprites
  attr_accessor :viewport1
  attr_accessor :viewportPopups
  
  #--------------------------------------------------------------------------
  # alias method: create_viewports
  #--------------------------------------------------------------------------
  alias spriteset_battle_create_viewports_abe create_viewports
  def create_viewports
    spriteset_battle_create_viewports_abe
    @viewportPopups = Viewport.new
    @viewportPopups.z = 200
  end
  
  #--------------------------------------------------------------------------
  # alias method: dispose_viewports
  #--------------------------------------------------------------------------
  alias spriteset_battle_dispose_viewports_abe dispose_viewports
  def dispose_viewports
    spriteset_battle_dispose_viewports_abe
    @viewportPopups.dispose
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_viewports
  #--------------------------------------------------------------------------
  alias spriteset_battle_update_viewports_abe update_viewports
  def update_viewports
    spriteset_battle_update_viewports_abe
    @viewportPopups.update
  end
  
end # Spriteset_Battle

#==============================================================================
# �� Game_Temp
#==============================================================================

class Game_Temp
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :battle_aid
  attr_accessor :evaluating
  attr_accessor :iconset
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias game_temp_initialize_abe initialize
  def initialize
    game_temp_initialize_abe
    @iconset = Cache.system("Iconset")
  end
  
end # Game_Temp

#==============================================================================
# �� Game_Action
#==============================================================================

class Game_Action
  
  #--------------------------------------------------------------------------
  # overwrite method: speed
  #--------------------------------------------------------------------------
  def speed
    speed = subject.agi
    speed += item.speed if item
    speed += subject.atk_speed if attack?
    return speed
  end
  
  #--------------------------------------------------------------------------
  # alias method: evaluate_item_with_target
  #--------------------------------------------------------------------------
  alias evaluate_item_with_target_abe evaluate_item_with_target
  def evaluate_item_with_target(target)
    $game_temp.evaluating = true
    result = evaluate_item_with_target_abe(target)
    $game_temp.evaluating = false
    return result
  end
  
end # Game_Action

#==============================================================================
# �� Game_ActionResult
#==============================================================================

class Game_ActionResult
  
  #--------------------------------------------------------------------------
  # alias method: clear
  #--------------------------------------------------------------------------
  alias game_actionresult_clear_abe clear
  def clear
    game_actionresult_clear_abe
    clear_stored_damage
  end
  
  #--------------------------------------------------------------------------
  # new method: clear_stored_damage
  #--------------------------------------------------------------------------
  def clear_stored_damage
    @stored_hp_damage = 0
    @stored_mp_damage = 0
    @stored_tp_damage = 0
    @stored_hp_drain = 0
    @stored_mp_drain = 0
  end
  
  #--------------------------------------------------------------------------
  # new method: store_damage
  #--------------------------------------------------------------------------
  def store_damage
    @stored_hp_damage += @hp_damage
    @stored_mp_damage += @mp_damage
    @stored_tp_damage += @tp_damage
    @stored_hp_drain += @hp_drain
    @stored_mp_drain += @mp_drain
  end
  
  #--------------------------------------------------------------------------
  # new method: restore_damage
  #--------------------------------------------------------------------------
  def restore_damage
    @hp_damage = @stored_hp_damage
    @mp_damage = @stored_mp_damage
    @tp_damage = @stored_tp_damage
    @hp_drain = @stored_hp_drain
    @mp_drain = @stored_mp_drain
    clear_stored_damage
  end
  
end # Game_ActionResult

#==============================================================================
# �� Game_BattlerBase
#==============================================================================

class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :popups
  
  #--------------------------------------------------------------------------
  # new method: create_popup
  #--------------------------------------------------------------------------
  def create_popup(value, rules = "DEFAULT", flags = [])
    return unless SceneManager.scene_is?(Scene_Battle)
    return unless YEA::BATTLE::ENABLE_POPUPS
    return if Switch.hide_popups
    @popups = [] if @popups.nil?
    @popups.push([value, rules, flags])
  end
  
  #--------------------------------------------------------------------------
  # new method: make_damage_popups
  #--------------------------------------------------------------------------
  def make_damage_popups(user)
    if @result.hp_drain != 0
      text = YEA::BATTLE::POPUP_SETTINGS[:drained]
      rules = "DRAIN"
      user.create_popup(text, rules)
      setting = :hp_dmg  if @result.hp_drain < 0
      setting = :hp_heal if @result.hp_drain > 0
      rules = "HP_DMG"   if @result.hp_drain < 0
      rules = "HP_HEAL"  if @result.hp_drain > 0
      value = @result.hp_drain.abs
      text = sprintf(YEA::BATTLE::POPUP_SETTINGS[setting], value.group)
      user.create_popup(text, rules)
    end
    if @result.mp_drain != 0
      text = YEA::BATTLE::POPUP_SETTINGS[:drained]
      rules = "DRAIN"
      user.create_popup(text, rules)
      setting = :mp_dmg  if @result.mp_drain < 0
      setting = :mp_heal if @result.mp_drain > 0
      rules = "HP_DMG"   if @result.mp_drain < 0
      rules = "HP_HEAL"  if @result.mp_drain > 0
      value = @result.mp_drain.abs
      text = sprintf(YEA::BATTLE::POPUP_SETTINGS[setting], value.group)
      user.create_popup(text, rules)
    end
    #---
    flags = []
    flags.push("critical") if @result.critical
    if @result.hp_damage != 0
      setting = :hp_dmg  if @result.hp_damage > 0
      setting = :hp_heal if @result.hp_damage < 0
      rules = "HP_DMG"   if @result.hp_damage > 0
      rules = "HP_HEAL"  if @result.hp_damage < 0
      value = @result.hp_damage.abs
      text = sprintf(YEA::BATTLE::POPUP_SETTINGS[setting], value.group)
      create_popup(text, rules, flags)
    end
    if @result.mp_damage != 0
      setting = :mp_dmg  if @result.mp_damage > 0
      setting = :mp_heal if @result.mp_damage < 0
      rules = "MP_DMG"   if @result.mp_damage > 0
      rules = "MP_HEAL"  if @result.mp_damage < 0
      value = @result.mp_damage.abs
      text = sprintf(YEA::BATTLE::POPUP_SETTINGS[setting], value.group)
      create_popup(text, rules, flags)
    end
    if @result.tp_damage != 0
      setting = :tp_dmg  if @result.tp_damage > 0
      setting = :tp_heal if @result.tp_damage < 0
      rules = "TP_DMG"   if @result.tp_damage > 0
      rules = "TP_HEAL"  if @result.tp_damage < 0
      value = @result.tp_damage.abs
      text = sprintf(YEA::BATTLE::POPUP_SETTINGS[setting], value.group)
      create_popup(text, rules)
    end
    @result.store_damage
    @result.clear_damage_values
  end
  
  #--------------------------------------------------------------------------
  # alias method: erase_state
  #--------------------------------------------------------------------------
  alias game_battlerbase_erase_state_abe erase_state
  def erase_state(state_id)
    make_state_popup(state_id, :rem_state) if @states.include?(state_id)
    game_battlerbase_erase_state_abe(state_id)
  end
  
  #--------------------------------------------------------------------------
  # new method: make_during_state_popup
  #--------------------------------------------------------------------------
  def make_during_state_popup
    state_id = most_important_state_id
    return if state_id == 0
    make_state_popup(state_id, :dur_state)
  end
  
  #--------------------------------------------------------------------------
  # new method: most_important_state_id
  #--------------------------------------------------------------------------
  def most_important_state_id
    states.each {|state| return state.id unless state.message3.empty? }
    return 0
  end
  
  #--------------------------------------------------------------------------
  # new method: make_state_popup
  #--------------------------------------------------------------------------
  def make_state_popup(state_id, type)
    state = $data_states[state_id]
    return if state.icon_index == 0
    rules = state.popup_rules[type]
    return if rules.nil?
    text = sprintf(YEA::BATTLE::POPUP_SETTINGS[type], state.name)
    flags = ["state", state.icon_index]
    create_popup(text, rules, flags)
  end
  
  #--------------------------------------------------------------------------
  # new method: make_miss_popups
  #--------------------------------------------------------------------------
  def make_miss_popups(user, item)
    return if dead?
    if @result.missed
      text = YEA::BATTLE::POPUP_SETTINGS[:missed]
      rules = "DEFAULT"
      create_popup(text, rules)
    end
    if @result.evaded
      text = YEA::BATTLE::POPUP_SETTINGS[:evaded]
      rules = "DEFAULT"
      create_popup(text, rules)
    end
    if @result.hit? && !@result.success
      text = YEA::BATTLE::POPUP_SETTINGS[:failed]
      rules = "DEFAULT"
      create_popup(text, rules)
    end
    if @result.hit? && item.damage.to_hp?
      if @result.hp_damage == 0 && @result.hp_damage == 0
        text = YEA::BATTLE::POPUP_SETTINGS[:nulled]
        rules = "DEFAULT"
        create_popup(text, rules)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: make_rate_popup
  #--------------------------------------------------------------------------
  def make_rate_popup(rate)
    return if rate == 1.0
    flags = []
    if rate > 1.0
      text = YEA::BATTLE::POPUP_SETTINGS[:weakpoint]
      rules = "WEAK_ELE"
      flags.push("weakness")
    elsif rate == 0.0
      text = YEA::BATTLE::POPUP_SETTINGS[:immune]
      rules = "IMMU_ELE"
      flags.push("immune")
    elsif rate < 0.0
      text = YEA::BATTLE::POPUP_SETTINGS[:absorbed]
      rules = "ABSB_ELE"
      flags.push("absorbed")
    else
      text = YEA::BATTLE::POPUP_SETTINGS[:resistant]
      rules = "REST_ELE"
      flags.push("resistant")
    end
    create_popup(text, rules, flags)
  end
  
  #--------------------------------------------------------------------------
  # new method: make_buff_popup
  #--------------------------------------------------------------------------
  def make_buff_popup(param_id, positive = true)
    return unless SceneManager.scene_is?(Scene_Battle)
    return unless alive?
    name = Vocab::param(param_id)
    if positive
      text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:add_buff], name)
      rules = "BUFF"
      buff_level = 1
    else
      text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:add_debuff], name)
      rules = "DEBUFF"
      buff_level = -1
    end
    icon = buff_icon_index(buff_level, param_id)
    flags = ["buff", icon]
    return if @popups.include?([text, rules, flags])
    create_popup(text, rules, flags)
  end
  
end # Game_BattlerBase

#==============================================================================
# �� Game_Battler
#==============================================================================

class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :pseudo_ani_id
  
  #--------------------------------------------------------------------------
  # alias method: on_battle_end
  #--------------------------------------------------------------------------
  alias game_battler_on_battle_end_abe on_battle_end
  def on_battle_end
    game_battler_on_battle_end_abe
    @popups = []
  end
  
  #--------------------------------------------------------------------------
  # alias method: clear_sprite_effects
  #--------------------------------------------------------------------------
  alias game_battler_clear_sprite_effects_abe clear_sprite_effects
  def clear_sprite_effects
    game_battler_clear_sprite_effects_abe
    @pseudo_ani_id = 0
  end
  
  #--------------------------------------------------------------------------
  # alias method: item_apply
  #--------------------------------------------------------------------------
  alias game_battler_item_apply_abe item_apply
  def item_apply(user, item)
    game_battler_item_apply_abe(user, item)
    make_miss_popups(user, item)
  end
  
  #--------------------------------------------------------------------------
  # alias method: make_damage_value
  #--------------------------------------------------------------------------
  alias game_battler_make_damage_value_abe make_damage_value
  def make_damage_value(user, item)
    game_battler_make_damage_value_abe(user, item)
    rate = item_element_rate(user, item)
    make_rate_popup(rate) unless $game_temp.evaluating
  end
  
  #--------------------------------------------------------------------------
  # alias method: execute_damage
  #--------------------------------------------------------------------------
  alias game_battler_execute_damage_abe execute_damage
  def execute_damage(user)
    game_battler_execute_damage_abe(user)
    make_damage_popups(user)
  end
  
  #--------------------------------------------------------------------------
  # alias method: item_effect_recover_hp
  #--------------------------------------------------------------------------
  alias game_battler_item_effect_recover_hp_abe item_effect_recover_hp
  def item_effect_recover_hp(user, item, effect)
    game_battler_item_effect_recover_hp_abe(user, item, effect)
    make_damage_popups(user)
  end
  
  #--------------------------------------------------------------------------
  # alias method: item_effect_recover_mp
  #--------------------------------------------------------------------------
  alias game_battler_item_effect_recover_mp_abe item_effect_recover_mp
  def item_effect_recover_mp(user, item, effect)
    game_battler_item_effect_recover_mp_abe(user, item, effect)
    make_damage_popups(user)
  end
  
  #--------------------------------------------------------------------------
  # alias method: item_effect_gain_tp
  #--------------------------------------------------------------------------
  alias game_battler_item_effect_gain_tp_abe item_effect_gain_tp
  def item_effect_gain_tp(user, item, effect)
    game_battler_item_effect_gain_tp_abe(user, item, effect)
    make_damage_popups(user)
  end
  
  #--------------------------------------------------------------------------
  # alias method: item_user_effect
  #--------------------------------------------------------------------------
  alias game_battler_item_user_effect_abe item_user_effect
  def item_user_effect(user, item)
    game_battler_item_user_effect_abe(user, item)
    @result.restore_damage
  end
  
  #--------------------------------------------------------------------------
  # alias method: add_new_state
  #--------------------------------------------------------------------------
  alias game_battler_add_new_state_abe add_new_state
  def add_new_state(state_id)
    game_battler_add_new_state_abe(state_id)
    make_state_popup(state_id, :add_state) if @states.include?(state_id)
  end
  
  #--------------------------------------------------------------------------
  # alias method: add_buff
  #--------------------------------------------------------------------------
  alias game_battler_add_buff_abe add_buff
  def add_buff(param_id, turns)
    make_buff_popup(param_id, true)
    game_battler_add_buff_abe(param_id, turns)
  end
  
  #--------------------------------------------------------------------------
  # alias method: add_debuff
  #--------------------------------------------------------------------------
  alias game_battler_add_debuff_abe add_debuff
  def add_debuff(param_id, turns)
    make_buff_popup(param_id, false)
    game_battler_add_debuff_abe(param_id, turns)
  end
  
  #--------------------------------------------------------------------------
  # alias method: regenerate_all
  #--------------------------------------------------------------------------
  alias game_battler_regenerate_all_abe regenerate_all
  def regenerate_all
    game_battler_regenerate_all_abe
    return unless alive?
    make_damage_popups(self)
  end
  
  #--------------------------------------------------------------------------
  # new method: can_collapse?
  #--------------------------------------------------------------------------
  def can_collapse?
    return false unless dead?
    unless actor?
      return false unless sprite.battler_visible
      array = [:collapse, :boss_collapse, :instant_collapse]
      return false if array.include?(sprite.effect_type)
    end
    return true
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_mp?
  #--------------------------------------------------------------------------
  def draw_mp?; return true; end
  
  #--------------------------------------------------------------------------
  # new method: draw_tp?
  #--------------------------------------------------------------------------
  def draw_tp?
    return $data_system.opt_display_tp
  end
  
end # Game_Battler

#==============================================================================
# �� Game_Actor
#==============================================================================

class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # overwrite method: perform_damage_effect
  #--------------------------------------------------------------------------
  def perform_damage_effect
    $game_troop.screen.start_shake(5, 5, 10) if YEA::BATTLE::SCREEN_SHAKE
    @sprite_effect_type = :blink if YEA::BATTLE::BLINK_EFFECTS
    Sound.play_actor_damage
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: use_sprite?
  #--------------------------------------------------------------------------
  def use_sprite?; return true; end
    
  #--------------------------------------------------------------------------
  # new method: screen_x
  #--------------------------------------------------------------------------
  def screen_x
    return 0 unless SceneManager.scene_is?(Scene_Battle)
    status_window = SceneManager.scene.status_window
    return 0 if status_window.nil?
    item_rect_width = (status_window.width-24) / $game_party.max_battle_members
    ext = SceneManager.scene.info_viewport.ox
    rect = SceneManager.scene.status_window.item_rect(self.index)
    constant = 128 + 12
    return constant + rect.x + item_rect_width / 2 - ext
  end
  
  #--------------------------------------------------------------------------
  # new method: screen_y
  #--------------------------------------------------------------------------
  def screen_y
    return Graphics.height - 120 unless SceneManager.scene_is?(Scene_Battle)
    return Graphics.height - 120 if SceneManager.scene.status_window.nil?
    return Graphics.height - (SceneManager.scene.status_window.height * 7/8)
  end
  
  #--------------------------------------------------------------------------
  # new method: screen_z
  #--------------------------------------------------------------------------
  def screen_z; return 100; end
  
  #--------------------------------------------------------------------------
  # new method: sprite
  #--------------------------------------------------------------------------
  def sprite
    index = $game_party.battle_members.index(self)
    return SceneManager.scene.spriteset.actor_sprites[index]
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_mp?
  #--------------------------------------------------------------------------
  def draw_mp?
    return true unless draw_tp?
    for skill in skills
      next unless added_skill_types.include?(skill.stype_id)
      return true if skill.mp_cost > 0
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_tp?
  #--------------------------------------------------------------------------
  def draw_tp?
    return false unless $data_system.opt_display_tp
    for skill in skills
      next unless added_skill_types.include?(skill.stype_id)
      return true if skill.tp_cost > 0
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # alias method: input
  #--------------------------------------------------------------------------
  alias game_actor_input_abe input
  def input
    if @actions.nil?
      make_actions
      @action_input_index = 0
    end
    if @actions[@action_input_index].nil?
      @actions[@action_input_index] = Game_Action.new(self)
    end
    return game_actor_input_abe
  end
  
end # Game_Actor

#==============================================================================
# �� Game_Enemy
#==============================================================================

class Game_Enemy < Game_Battler
  
  #--------------------------------------------------------------------------
  # overwrite method: perform_damage_effect
  #--------------------------------------------------------------------------
  def perform_damage_effect
    @sprite_effect_type = :blink if YEA::BATTLE::BLINK_EFFECTS
    Sound.play_enemy_damage
  end
  
  #--------------------------------------------------------------------------
  # new methods: attack_animation_id
  #--------------------------------------------------------------------------
  def atk_animation_id1; return enemy.atk_animation_id1; end
  def atk_animation_id2; return enemy.atk_animation_id2; end
  
  #--------------------------------------------------------------------------
  # new method: sprite
  #--------------------------------------------------------------------------
  def sprite
    return SceneManager.scene.spriteset.enemy_sprites.reverse[self.index]
  end
  
end # Game_Enemy

#==============================================================================
# �� Game_Unit
#==============================================================================

class Game_Unit
  
  #--------------------------------------------------------------------------
  # alias method: make_actions
  #--------------------------------------------------------------------------
  alias game_unit_make_actions_abe make_actions
  def make_actions
    game_unit_make_actions_abe
    refresh_autobattler_status_window
  end
  
  #--------------------------------------------------------------------------
  # new method: refresh_autobattler_status_window
  #--------------------------------------------------------------------------
  def refresh_autobattler_status_window
    return unless SceneManager.scene_is?(Scene_Battle)
    return unless self.is_a?(Game_Party)
    SceneManager.scene.refresh_autobattler_status_window
  end
  
end # Game_Unit

#==============================================================================
# �� Window_PartyCommand
#==============================================================================

class Window_PartyCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # overwrite method: process_handling
  #--------------------------------------------------------------------------
  def process_handling
    return unless open? && active
    return process_dir6 if Input.repeat?(:RIGHT)
    return super
  end
  
  #--------------------------------------------------------------------------
  # new method: process_dir6
  #--------------------------------------------------------------------------
  def process_dir6
    Sound.play_cursor
    Input.update
    deactivate
    call_handler(:dir6)
  end
  
end # Window_PartyCommand

#==============================================================================
# �� Window_ActorCommand
#==============================================================================

class Window_ActorCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # overwrite method: process_handling
  #--------------------------------------------------------------------------
  def process_handling
    return unless open? && active
    return process_dir4 if Input.repeat?(:LEFT)
    return process_dir6 if Input.repeat?(:RIGHT)
    return super
  end
  
  #--------------------------------------------------------------------------
  # new method: process_dir4
  #--------------------------------------------------------------------------
  def process_dir4
    Sound.play_cursor
    Input.update
    deactivate
    call_handler(:cancel)
  end
  
  #--------------------------------------------------------------------------
  # new method: process_dir6
  #--------------------------------------------------------------------------
  def process_dir6
    Sound.play_cursor
    Input.update
    deactivate
    call_handler(:dir6)
  end
  
end # Window_ActorCommand

#==============================================================================
# �� Window_BattleStatus
#==============================================================================

class Window_BattleStatus < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: initialize
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, window_width, window_height)
    self.openness = 0
    @party = $game_party.battle_members.clone
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: col_max
  #--------------------------------------------------------------------------
  def col_max; return $game_party.max_battle_members; end
  
  #--------------------------------------------------------------------------
  # new method: battle_members
  #--------------------------------------------------------------------------
  def battle_members; return $game_party.battle_members; end
  
  #--------------------------------------------------------------------------
  # new method: actor
  #--------------------------------------------------------------------------
  def actor; return battle_members[@index]; end
  
  #--------------------------------------------------------------------------
  # overwrite method: update
  #--------------------------------------------------------------------------
  def update
    super
    return if @party == $game_party.battle_members
    @party = $game_party.battle_members.clone
    refresh
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    return if index.nil?
    clear_item(index)
    actor = battle_members[index]
    rect = item_rect(index)
    return if actor.nil?
    draw_actor_face(actor, rect.x+2, rect.y+2, actor.alive?)
    draw_actor_name(actor, rect.x, rect.y, rect.width-8)
    draw_actor_action(actor, rect.x, rect.y)
    draw_actor_icons(actor, rect.x, line_height*1, rect.width)
    gx = YEA::BATTLE::BATTLESTATUS_HPGAUGE_Y_PLUS
    contents.font.size = YEA::BATTLE::BATTLESTATUS_TEXT_FONT_SIZE
    draw_actor_hp(actor, rect.x+2, line_height*2+gx, rect.width-4)
    if draw_tp?(actor) && draw_mp?(actor)
      dw = rect.width/2-2
      dw += 1 if $imported["YEA-CoreEngine"] && YEA::CORE::GAUGE_OUTLINE
      draw_actor_tp(actor, rect.x+2, line_height*3, dw)
      dw = rect.width - rect.width/2 - 2
      draw_actor_mp(actor, rect.x+rect.width/2, line_height*3, dw)
    elsif draw_tp?(actor) && !draw_mp?(actor)
      draw_actor_tp(actor, rect.x+2, line_height*3, rect.width-4)
    else
      draw_actor_mp(actor, rect.x+2, line_height*3, rect.width-4)
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: item_rect
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = contents.width / $game_party.max_battle_members
    rect.height = contents.height
    rect.x = index * rect.width
    if YEA::BATTLE::BATTLESTATUS_CENTER_FACES
      rect.x += (contents.width - $game_party.members.size * rect.width) / 2
    end
    rect.y = 0
    return rect
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_face
  #--------------------------------------------------------------------------
  def draw_face(face_name, face_index, dx, dy, enabled = true)
    bitmap = Cache.face(face_name)
    fx = [(96 - item_rect(0).width + 1) / 2, 0].max
    fy = face_index / 4 * 96 + 2
    fw = [item_rect(0).width - 4, 92].min
    rect = Rect.new(fx, fy, fw, 92)
    rect = Rect.new(face_index % 4 * 96 + fx, fy, fw, 92)
    contents.blt(dx, dy, bitmap, rect, enabled ? 255 : translucent_alpha)
    bitmap.dispose
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_name
  #--------------------------------------------------------------------------
  def draw_actor_name(actor, dx, dy, dw = 112)
    reset_font_settings
    contents.font.size = YEA::BATTLE::BATTLESTATUS_NAME_FONT_SIZE
    change_color(hp_color(actor))
    draw_text(dx+24, dy, dw-24, line_height, actor.name)
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_actor_action
  #--------------------------------------------------------------------------
  def draw_actor_action(actor, dx, dy)
    draw_icon(action_icon(actor), dx, dy)
  end
  
  #--------------------------------------------------------------------------
  # new method: action_icon
  #--------------------------------------------------------------------------
  def action_icon(actor)
    return Icon.no_action if actor.current_action.nil?
    return Icon.no_action if actor.current_action.item.nil?
    return actor.current_action.item.icon_index
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_tp?
  #--------------------------------------------------------------------------
  def draw_tp?(actor)
    return actor.draw_tp?
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_mp?
  #--------------------------------------------------------------------------
  def draw_mp?(actor)
    return actor.draw_mp?
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_current_and_max_values
  #--------------------------------------------------------------------------
  def draw_current_and_max_values(dx, dy, dw, current, max, color1, color2)
    change_color(color1)
    draw_text(dx, dy, dw, line_height, current.group, 2)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_hp
  #--------------------------------------------------------------------------
  def draw_actor_hp(actor, dx, dy, width = 124)
    draw_gauge(dx, dy, width, actor.hp_rate, hp_gauge_color1, hp_gauge_color2)
    change_color(system_color)
    cy = (Font.default_size - contents.font.size) / 2 + 1
    draw_text(dx+2, dy+cy, 30, line_height, Vocab::hp_a)
    draw_current_and_max_values(dx, dy+cy, width, actor.hp, actor.mhp,
      hp_color(actor), normal_color)
    end
    
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_mp
  #--------------------------------------------------------------------------
  def draw_actor_mp(actor, dx, dy, width = 124)
    draw_gauge(dx, dy, width, actor.mp_rate, mp_gauge_color1, mp_gauge_color2)
    change_color(system_color)
    cy = (Font.default_size - contents.font.size) / 2 + 1
    draw_text(dx+2, dy+cy, 30, line_height, Vocab::mp_a)
    draw_current_and_max_values(dx, dy+cy, width, actor.mp, actor.mmp,
      mp_color(actor), normal_color)
    end
    
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_tp
  #--------------------------------------------------------------------------
  def draw_actor_tp(actor, dx, dy, width = 124)
    draw_gauge(dx, dy, width, actor.tp_rate, tp_gauge_color1, tp_gauge_color2)
    change_color(system_color)
    cy = (Font.default_size - contents.font.size) / 2 + 1
    draw_text(dx+2, dy+cy, 30, line_height, Vocab::tp_a)
    change_color(tp_color(actor))
    draw_text(dx + width - 42, dy+cy, 42, line_height, actor.tp.to_i, 2)
  end
  
end # Window_BattleStatus

#==============================================================================
# �� Window_BattleActor
#==============================================================================

class Window_BattleActor < Window_BattleStatus
  
  #--------------------------------------------------------------------------
  # overwrite method: show
  #--------------------------------------------------------------------------
  def show
    create_flags
    super
  end
  
  #--------------------------------------------------------------------------
  # new method: create_flags
  #--------------------------------------------------------------------------
  def create_flags
    set_select_flag(:any)
    select(0)
    return if $game_temp.battle_aid.nil?
    if $game_temp.battle_aid.need_selection?
      select(0)
      set_select_flag(:dead) if $game_temp.battle_aid.for_dead_friend?
    elsif $game_temp.battle_aid.for_user?
      battler = BattleManager.actor
      id = battler.nil? ? 0 : $game_party.battle_members.index(battler)
      select(id)
      set_select_flag(:user)
    elsif $game_temp.battle_aid.for_all?
      select(0)
      set_select_flag(:all)
      set_select_flag(:all_dead) if $game_temp.battle_aid.for_dead_friend?
    elsif $game_temp.battle_aid.for_random?
      select(0)
      set_select_flag(:random) if $game_temp.battle_aid.for_random?
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: set_flag
  #--------------------------------------------------------------------------
  def set_select_flag(flag)
    @select_flag = flag
    case @select_flag
    when :all, :all_dead, :random
      @cursor_all = true
    else
      @cursor_all = false
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: update_cursor
  #--------------------------------------------------------------------------
  def update_cursor
    if @cursor_all
      cursor_rect.set(0, 0, contents.width, contents.height)
      self.top_row = 0
    elsif @index < 0
      cursor_rect.empty
    else
      ensure_cursor_visible
      cursor_rect.set(item_rect(@index))
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: cursor_movable?
  #--------------------------------------------------------------------------
  def cursor_movable?
    return false if @select_flag == :user
    return super
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return true if $game_temp.battle_aid.nil?
    if $game_temp.battle_aid.need_selection?
      member = $game_party.battle_members[@index]
      return member.dead? if $game_temp.battle_aid.for_dead_friend?
    elsif $game_temp.battle_aid.for_dead_friend?
      for member in $game_party.battle_members
        return true if member.dead?
      end
      return false
    end
    return true
  end
  
end # Window_BattleActor

#==============================================================================
# �� Window_BattleStatusAid
#==============================================================================

class Window_BattleStatusAid < Window_BattleStatus
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :status_window
  
  #--------------------------------------------------------------------------
  # overwrite method: initialize
  #--------------------------------------------------------------------------
  def initialize
    super
    self.visible = false
    self.openness = 255
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_width
  #--------------------------------------------------------------------------
  def window_width; return 128; end
  
  #--------------------------------------------------------------------------
  # overwrite method: show
  #--------------------------------------------------------------------------
  def show
    super
    refresh
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    return if @status_window.nil?
    draw_item(@status_window.index)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: item_rect
  #--------------------------------------------------------------------------
  def item_rect(index)
    return Rect.new(0, 0, contents.width, contents.height)
  end
  
end # Window_BattleStatusAid

#==============================================================================
# �� Window_BattleEnemy
#==============================================================================

class Window_BattleEnemy < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: initialize
  #--------------------------------------------------------------------------
  def initialize(info_viewport)
    super(0, Graphics.height, window_width, fitting_height(1))
    refresh
    self.visible = false
    @info_viewport = info_viewport
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: col_max
  #--------------------------------------------------------------------------
  def col_max; return item_max; end
  
  #--------------------------------------------------------------------------
  # overwrite method: show
  #--------------------------------------------------------------------------
  def show
    create_flags
    super
  end
  
  #--------------------------------------------------------------------------
  # new method: create_flags
  #--------------------------------------------------------------------------
  def create_flags
    set_select_flag(:any)
    select(0)
    return if $game_temp.battle_aid.nil?
    if $game_temp.battle_aid.need_selection?
      select(0)
    elsif $game_temp.battle_aid.for_all?
      select(0)
      set_select_flag(:all)
    elsif $game_temp.battle_aid.for_random?
      select(0)
      set_select_flag(:random)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: set_flag
  #--------------------------------------------------------------------------
  def set_select_flag(flag)
    @select_flag = flag
    case @select_flag
    when :all, :random
      @cursor_all = true
    else
      @cursor_all = false
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: select_all?
  #--------------------------------------------------------------------------
  def select_all?
    return true if @select_flag == :all
    return true if @select_flag == :random
    return false
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: update_cursor
  #--------------------------------------------------------------------------
  def update_cursor
    if @cursor_all
      cursor_rect.set(0, 0, contents.width, contents.height)
      self.top_row = 0
    elsif @index < 0
      cursor_rect.empty
    else
      ensure_cursor_visible
      cursor_rect.set(item_rect(@index))
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: cursor_movable?
  #--------------------------------------------------------------------------
  def cursor_movable?
    return false if @select_flag == :user
    return super
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return true if $game_temp.battle_aid.nil?
    if $game_temp.battle_aid.need_selection?
      member = $game_party.battle_members[@index]
      return member.dead? if $game_temp.battle_aid.for_dead_friend?
    elsif $game_temp.battle_aid.for_dead_friend?
      for member in $game_party.battle_members
        return true if member.dead?
      end
      return false
    end
    return true
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: enemy
  #--------------------------------------------------------------------------
  def enemy; @data[index]; end
  
  #--------------------------------------------------------------------------
  # overwrite method: refresh
  #--------------------------------------------------------------------------
  def refresh
    make_item_list
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: make_item_list
  #--------------------------------------------------------------------------
  def make_item_list
    @data = $game_troop.alive_members
    @data.sort! { |a,b| a.screen_x <=> b.screen_x }
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index); return; end
  
  #--------------------------------------------------------------------------
  # overwrite method: update
  #--------------------------------------------------------------------------
  def update
    super
    return unless active
    enemy.sprite_effect_type = :whiten
    return unless select_all?
    for enemy in $game_troop.alive_members
      enemy.sprite_effect_type = :whiten
    end
  end
  
end # Window_BattleEnemy

#==============================================================================
# �� Window_BattleHelp
#==============================================================================

class Window_BattleHelp < Window_Help
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :actor_window
  attr_accessor :enemy_window
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    if !self.visible and @text != ""
      @text = ""
      return refresh
    end
    update_battler_name
  end
  
  #--------------------------------------------------------------------------
  # update_battler_name
  #--------------------------------------------------------------------------
  def update_battler_name
    return unless @actor_window.active || @enemy_window.active
    if @actor_window.active
      battler = $game_party.battle_members[@actor_window.index]
    elsif @enemy_window.active
      battler = @enemy_window.enemy
    end
    if special_display?
      refresh_special_case(battler)
    else
      refresh_battler_name(battler) if battler_name(battler) != @text
    end
  end
  
  #--------------------------------------------------------------------------
  # battler_name
  #--------------------------------------------------------------------------
  def battler_name(battler)
    text = battler.name.clone
    return text
  end
  
  #--------------------------------------------------------------------------
  # refresh_battler_name
  #--------------------------------------------------------------------------
  def refresh_battler_name(battler)
    contents.clear
    reset_font_settings
    change_color(normal_color)
    @text = battler_name(battler)
    icons = battler.state_icons + battler.buff_icons
    dy = icons.size <= 0 ? line_height / 2 : 0
    draw_text(0, dy, contents.width, line_height, @text, 1)
    dx = (contents.width - (icons.size * 24)) / 2
    draw_actor_icons(battler, dx, line_height, contents.width)
  end
  
  #--------------------------------------------------------------------------
  # special_display?
  #--------------------------------------------------------------------------
  def special_display?
    return false if $game_temp.battle_aid.nil?
    return false if $game_temp.battle_aid.for_user?
    return !$game_temp.battle_aid.need_selection?
  end
  
  #--------------------------------------------------------------------------
  # refresh_special_case
  #--------------------------------------------------------------------------
  def refresh_special_case(battler)
    if $game_temp.battle_aid.for_opponent?
      if $game_temp.battle_aid.for_all?
        text = YEA::BATTLE::HELP_TEXT_ALL_FOES
      else
        case $game_temp.battle_aid.number_of_targets
        when 1
          text = YEA::BATTLE::HELP_TEXT_ONE_RANDOM_FOE
        else
          number = $game_temp.battle_aid.number_of_targets
          text = sprintf(YEA::BATTLE::HELP_TEXT_MANY_RANDOM_FOE, number)
        end
      end
    else # $game_temp.battle_aid.for_friend?
      if $game_temp.battle_aid.for_dead_friend?
        text = YEA::BATTLE::HELP_TEXT_ALL_DEAD_ALLIES
      elsif $game_temp.battle_aid.for_random?
        case $game_temp.battle_aid.number_of_targets
        when 1
          text = YEA::BATTLE::HELP_TEXT_ONE_RANDOM_ALLY
        else
          number = $game_temp.battle_aid.number_of_targets
          text = sprintf(YEA::BATTLE::HELP_TEXT_RANDOM_ALLIES, number)
        end
      else
        text = YEA::BATTLE::HELP_TEXT_ALL_ALLIES
      end
    end
    return if text == @text
    @text = text
    contents.clear
    reset_font_settings
    draw_text(0, 0, contents.width, line_height*2, @text, 1)
  end
  
end # Window_BattleHelp

#==============================================================================
# �� Window_BattleLog
#==============================================================================

class Window_BattleLog < Window_Selectable
  
  #--------------------------------------------------------------------------
  # alias method: display_current_state
  #--------------------------------------------------------------------------
  alias window_battlelog_display_current_state_abe display_current_state
  def display_current_state(subject)
    subject.make_during_state_popup
    return unless YEA::BATTLE::MSG_CURRENT_STATE
    window_battlelog_display_current_state_abe(subject)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_use_item
  #--------------------------------------------------------------------------
  alias window_battlelog_display_use_item_abe display_use_item
  def display_use_item(subject, item)
    return unless YEA::BATTLE::MSG_CURRENT_ACTION
    window_battlelog_display_use_item_abe(subject, item)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_counter
  #--------------------------------------------------------------------------
  alias window_battlelog_display_counter_abe display_counter
  def display_counter(target, item)
    if YEA::BATTLE::MSG_COUNTERATTACK
      window_battlelog_display_counter_abe(target, item)
    else
      Sound.play_evasion
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_reflection
  #--------------------------------------------------------------------------
  alias window_battlelog_display_reflection_abe display_reflection
  def display_reflection(target, item)
    if YEA::BATTLE::MSG_REFLECT_MAGIC
      window_battlelog_display_reflection_abe(target, item)
    else
      Sound.play_reflection
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_substitute
  #--------------------------------------------------------------------------
  alias window_battlelog_display_substitute_abe display_substitute
  def display_substitute(substitute, target)
    return unless YEA::BATTLE::MSG_SUBSTITUTE_HIT
    window_battlelog_display_substitute_abe(substitute, target)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_failure
  #--------------------------------------------------------------------------
  alias window_battlelog_display_failure_abe display_failure
  def display_failure(target, item)
    return unless YEA::BATTLE::MSG_FAILURE_HIT
    window_battlelog_display_failure_abe(target, item)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_critical
  #--------------------------------------------------------------------------
  alias window_battlelog_display_critical_abe display_critical
  def display_critical(target, item)
    return unless YEA::BATTLE::MSG_CRITICAL_HIT
    window_battlelog_display_critical_abe(target, item)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_miss
  #--------------------------------------------------------------------------
  alias window_battlelog_display_miss_abe display_miss
  def display_miss(target, item)
    return unless YEA::BATTLE::MSG_HIT_MISSED
    window_battlelog_display_miss_abe(target, item)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_evasion
  #--------------------------------------------------------------------------
  alias window_battlelog_display_evasion_abe display_evasion
  def display_evasion(target, item)
    if YEA::BATTLE::MSG_EVASION
      window_battlelog_display_evasion_abe(target, item)
    else
      if !item || item.physical?
        Sound.play_evasion
      else
        Sound.play_magic_evasion
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: display_hp_damage
  #--------------------------------------------------------------------------
  def display_hp_damage(target, item)
    return if target.result.hp_damage == 0 && item && !item.damage.to_hp?
    if target.result.hp_damage > 0 && target.result.hp_drain == 0
      target.perform_damage_effect
    end
    Sound.play_recovery if target.result.hp_damage < 0
    return unless YEA::BATTLE::MSG_HP_DAMAGE
    add_text(target.result.hp_damage_text)
    wait
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: display_mp_damage
  #--------------------------------------------------------------------------
  def display_mp_damage(target, item)
    return if target.dead? || target.result.mp_damage == 0
    Sound.play_recovery if target.result.mp_damage < 0
    return unless YEA::BATTLE::MSG_MP_DAMAGE
    add_text(target.result.mp_damage_text)
    wait
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: display_tp_damage
  #--------------------------------------------------------------------------
  def display_tp_damage(target, item)
    return if target.dead? || target.result.tp_damage == 0
    Sound.play_recovery if target.result.tp_damage < 0
    return unless YEA::BATTLE::MSG_TP_DAMAGE
    add_text(target.result.tp_damage_text)
    wait
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_added_states
  #--------------------------------------------------------------------------
  alias window_battlelog_display_added_states_abe display_added_states
  def display_added_states(target)
    return unless YEA::BATTLE::MSG_ADDED_STATES
    window_battlelog_display_added_states_abe(target)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_removed_states
  #--------------------------------------------------------------------------
  alias window_battlelog_display_removed_states_abe display_removed_states
  def display_removed_states(target)
    return unless YEA::BATTLE::MSG_REMOVED_STATES
    window_battlelog_display_removed_states_abe(target)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_changed_buffs
  #--------------------------------------------------------------------------
  alias window_battlelog_display_changed_buffs_abe display_changed_buffs
  def display_changed_buffs(target)
    return unless YEA::BATTLE::MSG_CHANGED_BUFFS
    window_battlelog_display_changed_buffs_abe(target)
  end
  
end # Window_BattleLog

#==============================================================================
# �� Window_SkillList
#==============================================================================

class Window_SkillList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: spacing
  #--------------------------------------------------------------------------
  def spacing
    return 8 if $game_party.in_battle
    return super
  end
  
end # Window_SkillList

#==============================================================================
# �� Window_ItemList
#==============================================================================

class Window_ItemList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: spacing
  #--------------------------------------------------------------------------
  def spacing
    return 8 if $game_party.in_battle
    return super
  end
  
end # Window_ItemList

#==============================================================================
# �� Scene_Battle
#==============================================================================

class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :enemy_window
  attr_accessor :info_viewport
  attr_accessor :spriteset
  attr_accessor :status_window
  attr_accessor :status_aid_window
  attr_accessor :subject
  
  #--------------------------------------------------------------------------
  # alias method: create_spriteset
  #--------------------------------------------------------------------------
  alias scene_battle_create_spriteset_abe create_spriteset
  def create_spriteset
    BattleManager.init_battle_type
    scene_battle_create_spriteset_abe
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_basic
  #--------------------------------------------------------------------------
  alias scene_battle_update_basic_abe update_basic
  def update_basic
    scene_battle_update_basic_abe
    update_debug
  end
  
  #--------------------------------------------------------------------------
  # new method: update_debug
  #--------------------------------------------------------------------------
  def update_debug
    return unless $TEST || $BTEST
    debug_heal_party if Input.trigger?(:F5)
    debug_damage_party if Input.trigger?(:F6)
    debug_fill_tp if Input.trigger?(:F7)
    debug_kill_all if Input.trigger?(:F8)
  end
  
  #--------------------------------------------------------------------------
  # new method: debug_heal_party
  #--------------------------------------------------------------------------
  def debug_heal_party
    Sound.play_recovery
    for member in $game_party.battle_members
      member.recover_all
    end
    @status_window.refresh
  end
  
  #--------------------------------------------------------------------------
  # new method: debug_damage_party
  #--------------------------------------------------------------------------
  def debug_damage_party
    Sound.play_actor_damage
    for member in $game_party.alive_members
      member.hp = 1
      member.mp = 0
      member.tp = 0
    end
    @status_window.refresh
  end
  
  #--------------------------------------------------------------------------
  # new method: debug_fill_tp
  #--------------------------------------------------------------------------
  def debug_fill_tp
    Sound.play_recovery
    for member in $game_party.alive_members
      member.tp = member.max_tp
    end
    @status_window.refresh
  end
  
  #--------------------------------------------------------------------------
  # new method: debug_kill_all
  #--------------------------------------------------------------------------
  def debug_kill_all
    for enemy in $game_troop.alive_members
      enemy.hp = 0
      enemy.perform_collapse_effect
    end
    BattleManager.judge_win_loss
    @log_window.wait
    @log_window.wait_for_effect
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_all_windows
  #--------------------------------------------------------------------------
  alias scene_battle_create_all_windows_abe create_all_windows
  def create_all_windows
    scene_battle_create_all_windows_abe
    create_battle_status_aid_window
    set_help_window
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_info_viewport
  #--------------------------------------------------------------------------
  alias scene_battle_create_info_viewport_abe create_info_viewport
  def create_info_viewport
    scene_battle_create_info_viewport_abe
    @status_window.refresh
  end
  
  #--------------------------------------------------------------------------
  # new method: create_battle_status_aid_window
  #--------------------------------------------------------------------------
  def create_battle_status_aid_window
    @status_aid_window = Window_BattleStatusAid.new
    @status_aid_window.status_window = @status_window
    @status_aid_window.x = Graphics.width - @status_aid_window.width
    @status_aid_window.y = Graphics.height - @status_aid_window.height
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_help_window
  #--------------------------------------------------------------------------
  def create_help_window
    @help_window = Window_BattleHelp.new
    @help_window.hide
  end
  
  #--------------------------------------------------------------------------
  # new method: set_help_window
  #--------------------------------------------------------------------------
  def set_help_window
    @help_window.actor_window = @actor_window
    @help_window.enemy_window = @enemy_window
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_party_command_window
  #--------------------------------------------------------------------------
  alias scene_battle_create_party_command_window_abe create_party_command_window
  def create_party_command_window
    scene_battle_create_party_command_window_abe
    @party_command_window.set_handler(:dir6, method(:command_fight))
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_actor_command_window
  #--------------------------------------------------------------------------
  alias scene_battle_create_actor_command_window_abe create_actor_command_window
  def create_actor_command_window
    scene_battle_create_actor_command_window_abe
    @actor_command_window.set_handler(:dir4, method(:prior_command))
    @actor_command_window.set_handler(:dir6, method(:next_command))
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_skill_window
  #--------------------------------------------------------------------------
  alias scene_battle_create_skill_window_abe create_skill_window
  def create_skill_window
    scene_battle_create_skill_window_abe
    @skill_window.height = @info_viewport.rect.height
    @skill_window.width = Graphics.width - @actor_command_window.width
    @skill_window.y = Graphics.height - @skill_window.height
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_item_window
  #--------------------------------------------------------------------------
  alias scene_battle_create_item_window_abe create_item_window
  def create_item_window
    scene_battle_create_item_window_abe
    @item_window.height = @skill_window.height
    @item_window.width = @skill_window.width
    @item_window.y = Graphics.height - @item_window.height
  end
  
  #--------------------------------------------------------------------------
  # alias method: show_fast?
  #--------------------------------------------------------------------------
  alias scene_battle_show_fast_abe show_fast?
  def show_fast?
    return true if YEA::BATTLE::AUTO_FAST
    return scene_battle_show_fast_abe
  end
  
  #--------------------------------------------------------------------------
  # alias method: next_command
  #--------------------------------------------------------------------------
  alias scene_battle_next_command_abe next_command
  def next_command
    @status_window.show
    redraw_current_status
    @actor_command_window.show
    @status_aid_window.hide
    scene_battle_next_command_abe
  end
  
  #--------------------------------------------------------------------------
  # alias method: prior_command
  #--------------------------------------------------------------------------
  alias scene_battle_prior_command_abe prior_command
  def prior_command
    redraw_current_status
    scene_battle_prior_command_abe
  end
  
  #--------------------------------------------------------------------------
  # new method: redraw_current_status
  #--------------------------------------------------------------------------
  def redraw_current_status
    return if @status_window.index < 0
    @status_window.draw_item(@status_window.index)
  end
  
  #--------------------------------------------------------------------------
  # alias method: command_attack
  #--------------------------------------------------------------------------
  alias scene_battle_command_attack_abe command_attack
  def command_attack
    $game_temp.battle_aid = $data_skills[BattleManager.actor.attack_skill_id]
    scene_battle_command_attack_abe
  end
  
  #--------------------------------------------------------------------------
  # alias method: command_skill
  #--------------------------------------------------------------------------
  alias scene_battle_command_skill_abe command_skill
  def command_skill
    scene_battle_command_skill_abe
    @status_window.hide
    @actor_command_window.hide
    @status_aid_window.show
  end
  
  #--------------------------------------------------------------------------
  # alias method: command_item
  #--------------------------------------------------------------------------
  alias scene_battle_command_item_abe command_item
  def command_item
    scene_battle_command_item_abe
    @status_window.hide
    @actor_command_window.hide
    @status_aid_window.show
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_skill_ok
  #--------------------------------------------------------------------------
  def on_skill_ok
    @skill = @skill_window.item
    $game_temp.battle_aid = @skill
    BattleManager.actor.input.set_skill(@skill.id)
    BattleManager.actor.last_skill.object = @skill
    if @skill.for_opponent?
      select_enemy_selection
    elsif @skill.for_friend?
      select_actor_selection
    else
      @skill_window.hide
      next_command
      $game_temp.battle_aid = nil
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_skill_cancel
  #--------------------------------------------------------------------------
  alias scene_battle_on_skill_cancel_abe on_skill_cancel
  def on_skill_cancel
    scene_battle_on_skill_cancel_abe
    @status_window.show
    @actor_command_window.show
    @status_aid_window.hide
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_item_ok
  #--------------------------------------------------------------------------
  def on_item_ok
    @item = @item_window.item
    $game_temp.battle_aid = @item
    BattleManager.actor.input.set_item(@item.id)
    if @item.for_opponent?
      select_enemy_selection
    elsif @item.for_friend?
      select_actor_selection
    else
      @item_window.hide
      next_command
      $game_temp.battle_aid = nil
    end
    $game_party.last_item.object = @item
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_item_cancel
  #--------------------------------------------------------------------------
  alias scene_battle_on_item_cancel_abe on_item_cancel
  def on_item_cancel
    scene_battle_on_item_cancel_abe
    @status_window.show
    @actor_command_window.show
    @status_aid_window.hide
  end
  
  #--------------------------------------------------------------------------
  # alias method: select_actor_selection
  #--------------------------------------------------------------------------
  alias scene_battle_select_actor_selection_abe select_actor_selection
  def select_actor_selection
    @status_aid_window.refresh
    scene_battle_select_actor_selection_abe
    @status_window.hide
    @skill_window.hide
    @item_window.hide
    @help_window.show
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_actor_ok
  #--------------------------------------------------------------------------
  alias scene_battle_on_actor_ok_abe on_actor_ok
  def on_actor_ok
    $game_temp.battle_aid = nil
    scene_battle_on_actor_ok_abe
    @status_window.show
    if $imported["YEA-BattleCommandList"] && !@confirm_command_window.nil?
      @actor_command_window.visible = !@confirm_command_window.visible
    else
      @actor_command_window.show
    end
    @status_aid_window.hide
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_actor_cancel
  #--------------------------------------------------------------------------
  alias scene_battle_on_actor_cancel_abe on_actor_cancel
  def on_actor_cancel
    BattleManager.actor.input.clear
    @status_aid_window.refresh
    $game_temp.battle_aid = nil
    scene_battle_on_actor_cancel_abe
    case @actor_command_window.current_symbol
    when :skill
      @skill_window.show
    when :item
      @item_window.show
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: select_enemy_selection
  #--------------------------------------------------------------------------
  alias scene_battle_select_enemy_selection_abe select_enemy_selection
  def select_enemy_selection
    @status_aid_window.refresh
    scene_battle_select_enemy_selection_abe
    @help_window.show
  end
  #--------------------------------------------------------------------------
  # alias method: on_enemy_ok
  #--------------------------------------------------------------------------
  alias scene_battle_on_enemy_ok_abe on_enemy_ok
  def on_enemy_ok
    $game_temp.battle_aid = nil
    scene_battle_on_enemy_ok_abe
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_enemy_cancel
  #--------------------------------------------------------------------------
  alias scene_battle_on_enemy_cancel_abe on_enemy_cancel
  def on_enemy_cancel
    BattleManager.actor.input.clear
    @status_aid_window.refresh
    $game_temp.battle_aid = nil
    scene_battle_on_enemy_cancel_abe
    if @skill_window.visible || @item_window.visible
      @help_window.show
    else
      @help_window.hide
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: battle_start
  #--------------------------------------------------------------------------
  alias scene_battle_battle_start_abe battle_start
  def battle_start
    scene_battle_battle_start_abe
    return unless YEA::BATTLE::SKIP_PARTY_COMMAND
    @party_command_window.deactivate
    if BattleManager.input_start
      command_fight 
    else
      turn_start
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: turn_end
  #--------------------------------------------------------------------------
  def turn_end
    all_battle_members.each do |battler|
      battler.on_turn_end
      status_redraw_target(battler)
      @log_window.display_auto_affected_status(battler)
      @log_window.wait_and_clear
    end
    update_party_cooldowns if $imported["YEA-CommandParty"]
    BattleManager.turn_end
    process_event
    start_party_command_selection
    return if end_battle_conditions?
    return unless YEA::BATTLE::SKIP_PARTY_COMMAND
    if BattleManager.input_start
      @party_command_window.deactivate
      command_fight
    else
      @party_command_window.deactivate
      turn_start
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: end_battle_conditions?
  #--------------------------------------------------------------------------
  def end_battle_conditions?
    return true if $game_party.members.empty?
    return true if $game_party.all_dead?
    return true if $game_troop.all_dead?
    return true if BattleManager.aborting?
    return false
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: execute_action
  #--------------------------------------------------------------------------
  def execute_action
    @subject.sprite_effect_type = :whiten if YEA::BATTLE::FLASH_WHITE_EFFECT
    use_item
    @log_window.wait_and_clear
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: apply_item_effects
  #--------------------------------------------------------------------------
  def apply_item_effects(target, item)
    if $imported["YEA-LunaticObjects"]
      lunatic_object_effect(:prepare, item, @subject, target)
    end
    target.item_apply(@subject, item)
    status_redraw_target(@subject)
    status_redraw_target(target) unless target == @subject
    @log_window.display_action_results(target, item)
    if $imported["YEA-LunaticObjects"]
      lunatic_object_effect(:during, item, @subject, target)
    end
    perform_collapse_check(target)
  end
  
  #--------------------------------------------------------------------------
  # overwite method: invoke_counter_attack
  #--------------------------------------------------------------------------
  def invoke_counter_attack(target, item)
    @log_window.display_counter(target, item)
    attack_skill = $data_skills[target.attack_skill_id]
    @subject.item_apply(target, attack_skill)
    status_redraw_target(@subject)
    status_redraw_target(target) unless target == @subject
    @log_window.display_action_results(@subject, attack_skill)
    perform_collapse_check(target)
    perform_collapse_check(@subject)
  end
  
  #--------------------------------------------------------------------------
  # new method: perform_collapse_check
  #--------------------------------------------------------------------------
  def perform_collapse_check(target)
    return if YEA::BATTLE::MSG_ADDED_STATES
    target.perform_collapse_effect if target.can_collapse?
    @log_window.wait
    @log_window.wait_for_effect
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: show_attack_animation
  #--------------------------------------------------------------------------
  def show_attack_animation(targets)
    show_normal_animation(targets, @subject.atk_animation_id1, false)
    wait_for_animation
    show_normal_animation(targets, @subject.atk_animation_id2, true)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: show_normal_animation
  #--------------------------------------------------------------------------
  def show_normal_animation(targets, animation_id, mirror = false)
    animation = $data_animations[animation_id]
    return if animation.nil?
    ani_check = false
    targets.each do |target|
      if ani_check && target.animation_id <= 0
        target.pseudo_ani_id = animation_id
      else
        target.animation_id = animation_id
      end
      target.animation_mirror = mirror
      ani_check = true if animation.to_screen?
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: process_action_end
  #--------------------------------------------------------------------------
  def process_action_end
    @subject.on_action_end
    status_redraw_target(@subject)
    @log_window.display_auto_affected_status(@subject)
    @log_window.wait_and_clear
    @log_window.display_current_state(@subject)
    @log_window.wait_and_clear
    BattleManager.judge_win_loss
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: use_item
  #--------------------------------------------------------------------------
  def use_item
    item = @subject.current_action.item
    @log_window.display_use_item(@subject, item)
    @subject.use_item(item)
    status_redraw_target(@subject)
    if $imported["YEA-LunaticObjects"]
      lunatic_object_effect(:before, item, @subject, @subject)
    end
    process_casting_animation if $imported["YEA-CastAnimations"]
    targets = @subject.current_action.make_targets.compact rescue []
    show_animation(targets, item.animation_id) if show_all_animation?(item)
    targets.each {|target| 
      if $imported["YEA-TargetManager"]
        target = alive_random_target(target, item) if item.for_random?
      end
      item.repeats.times { invoke_item(target, item) } }
    if $imported["YEA-LunaticObjects"]
      lunatic_object_effect(:after, item, @subject, @subject)
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: invoke_item
  #--------------------------------------------------------------------------
  alias scene_battle_invoke_item_abe invoke_item
  def invoke_item(target, item)
    show_animation([target], item.animation_id) if separate_ani?(target, item)
    if target.dead? != item.for_dead_friend?
      @subject.last_target_index = target.index
      return
    end
    scene_battle_invoke_item_abe(target, item)
  end
  
  #--------------------------------------------------------------------------
  # new method: show_all_animation?
  #--------------------------------------------------------------------------
  def show_all_animation?(item)
    return true if item.one_animation
    return false if $data_animations[item.animation_id].nil?
    return false unless $data_animations[item.animation_id].to_screen?
    return true
  end
  
  #--------------------------------------------------------------------------
  # new method: separate_ani?
  #--------------------------------------------------------------------------
  def separate_ani?(target, item)
    return false if item.one_animation
    return false if $data_animations[item.animation_id].nil?
    return false if $data_animations[item.animation_id].to_screen?
    return target.dead? == item.for_dead_friend?
  end
  
  #--------------------------------------------------------------------------
  # new method: status_redraw_target
  #--------------------------------------------------------------------------
  def status_redraw_target(target)
    return unless target.actor?
    @status_window.draw_item($game_party.battle_members.index(target))
  end
  
  #--------------------------------------------------------------------------
  # alias method: start_party_command_selection
  #--------------------------------------------------------------------------
  alias start_party_command_selection_abe start_party_command_selection
  def start_party_command_selection
    @status_window.refresh unless scene_changing?
    start_party_command_selection_abe
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: refresh_status
  #--------------------------------------------------------------------------
  def refresh_status; return; end
  
  #--------------------------------------------------------------------------
  # new method: refresh_autobattler_status_window
  #--------------------------------------------------------------------------
  def refresh_autobattler_status_window
    for member in $game_party.battle_members
      next unless member.auto_battle?
      @status_window.draw_item(member.index)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: hide_extra_gauges
  #--------------------------------------------------------------------------
  def hide_extra_gauges
    # Made for compatibility
  end
  
  #--------------------------------------------------------------------------
  # new method: show_extra_gauges
  #--------------------------------------------------------------------------
  def show_extra_gauges
    # Made for compatibility
  end
  
end # Scene_Battle

#==============================================================================
# 
# �� End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - Battle System Add-On: Free Turn Battle v1.02
# -- Last Updated: 2012.01.15
# -- Level: Normal, Hard
# -- Requires: Yanfly Engine Ace - Ace Battle Engine v1.15+
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-BattleSystem-FTB"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.15 - Bug fixed: Battle victory log doesn't play twice.
# 2012.01.11 - Bug fixed: Dead actors are no longer inputable.
# 2012.01.10 - Finished Script.
# 2012.01.09 - Started Script.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# Free Turn Battle is a type of battle system made for Ace Battle Engine, where
# actors perform their actions immediately (unless under the effects of berserk
# or any other form of autobattle) as they're selected. After all of their
# actions have been performed, the enemies will take their turn in battling the
# actors. This becomes a system where actors and enemies will take turns
# attacking one another as a whole.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# First, set the default battle system for your game to be :ftb by either going
# to the Ace Battle Engine script and setting DEFAULT_BATTLE_SYSTEM as :ftb or
# by using the following script call: 
# 
# $game_system:set_battle_system(:ftb)
# 
# -----------------------------------------------------------------------------
# Actor Notetags - These notetags go in the actors notebox in the database.
# -----------------------------------------------------------------------------
# <ftb actions: +x>
# <ftb actions: -x>
# This increases or decreases the maximum number of actions available to an
# actor by x. While an actor's individual maximum can be any value, it does not
# provide more than the party maximum applied in the module. An actor's total
# maximum cannot go below 1.
# 
# -----------------------------------------------------------------------------
# Class Notetags - These notetags go in the classes notebox in the database.
# -----------------------------------------------------------------------------
# <ftb actions: +x>
# <ftb actions: -x>
# This increases or decreases the maximum number of actions available to an
# actor by x. While an actor's individual maximum can be any value, it does not
# provide more than the party maximum applied in the module. An actor's total
# maximum cannot go below 1.
# 
# -----------------------------------------------------------------------------
# Skill Notetags - These notetags go in the skills notebox in the database.
# -----------------------------------------------------------------------------
# <ftb cost: x>
# This causes the skill to have an FTB cost of x. The FTB Cost does not occur
# for individual chain skills, individual input skills, specialized input
# skills, or instant skills. However, an FTB Cost can be used to put a specific
# requirement on those listed types of skills.
# 
# -----------------------------------------------------------------------------
# Item Notetags - These notetags go in the items notebox in the database.
# -----------------------------------------------------------------------------
# <ftb cost: x>
# This causes the item to have an FTB cost of x. The FTB Cost does not occur
# for instant items. If items cost more actions than the party has available,
# then the items will not appear in the usable item list during battle.
# 
# -----------------------------------------------------------------------------
# Weapon Notetags - These notetags go in the weapons notebox in the database.
# -----------------------------------------------------------------------------
# <ftb actions: +x>
# <ftb actions: -x>
# This increases or decreases the maximum number of actions available to an
# actor by x. While an actor's individual maximum can be any value, it does not
# provide more than the party maximum applied in the module. An actor's total
# maximum cannot go below 1.
# 
# -----------------------------------------------------------------------------
# Armour Notetags - These notetags go in the armour notebox in the database.
# -----------------------------------------------------------------------------
# <ftb actions: +x>
# <ftb actions: -x>
# This increases or decreases the maximum number of actions available to an
# actor by x. While an actor's individual maximum can be any value, it does not
# provide more than the party maximum applied in the module. An actor's total
# maximum cannot go below 1.
# 
# -----------------------------------------------------------------------------
# State Notetags - These notetags go in the state notebox in the database.
# -----------------------------------------------------------------------------
# <ftb actions: +x>
# <ftb actions: -x>
# This increases or decreases the maximum number of actions available to an
# actor by x. While an actor's individual maximum can be any value, it does not
# provide more than the party maximum applied in the module. An actor's total
# maximum cannot go below 1.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
# This script requires Yanfly Engine Ace - Ace Battle Engine v1.15+ and the
# script must be placed under Ace Battle Engine in the script listing.
# 
#==============================================================================

module YEA
  module FTB
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General FTB Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust various general Free Turn Battle constants such as
    # the icons used for actions and no actions, whether or not party members
    # will have limited actions (or unlimited).
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ICON_ACTION = 188      # Icon displayed when there are actions left.
    ICON_EMPTY  = 185      # Icon displayed to indicate a used action.
    
    # For every x% above the base AGI, actors will gain an extra action. Change
    # the value below to adjust the percentage needed.
    EXTRA_FTB_ACTION_BONUS = 0.20
    
    # This is the maximum number of actions that the party can have despite the
    # maximum number of individual actor actions totalling to more than this.
    MAXIMUM_FTB_ACTIONS = 10
    
    # If this setting is on, then each member can only perform a limited amount
    # of actions per turn as opposed to freely performing actions until the
    # party's action usage is depleted.
    LIMITED_ACTIONS_PER_MEMBER = true
    
  end # FTB
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

module YEA
  module REGEXP
  module BASEITEM
    
    FTB_ACTIONS = /<(?:FTB_ACTIONS|ftb actions):[ ]([\+\-]\d+)>/i
    
  end # BASEITEM
  module USABLEITEM
    
    FTB_COST = /<(?:FTB_COST|ftb cost):[ ](\d+)>/i
    
  end # USABLEITEM
  end # REGEXP
end # YEA

#==============================================================================
# ■ Icon
#==============================================================================

module Icon
  
  #--------------------------------------------------------------------------
  # self.ftb_action
  #--------------------------------------------------------------------------
  def self.ftb_action
    return YEA::FTB::ICON_ACTION
  end
  
  #--------------------------------------------------------------------------
  # self.ftb_empty
  #--------------------------------------------------------------------------
  def self.ftb_empty
    return YEA::FTB::ICON_EMPTY
  end
  
end # Icon

#==============================================================================
# ■ DataManager
#==============================================================================

module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_ftb load_database; end
  def self.load_database
    load_database_ftb
    load_notetags_ftb
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_ftb
  #--------------------------------------------------------------------------
  def self.load_notetags_ftb
    groups = [$data_skills, $data_items, $data_actors, $data_classes,
      $data_weapons, $data_armors, $data_states]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_ftb
      end
    end
  end
  
end # DataManager

#==============================================================================
# ■ RPG::BaseItem
#==============================================================================

class RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :ftb_actions
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_ftb
  #--------------------------------------------------------------------------
  def load_notetags_ftb
    @ftb_actions = 0
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::BASEITEM::FTB_ACTIONS
        @ftb_actions = $1.to_i
      end
    } # self.note.split
    #---
  end
  
end # RPG::BaseItem

#==============================================================================
# ■ RPG::UsableItem
#==============================================================================

class RPG::UsableItem < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :ftb_cost
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_ftb
  #--------------------------------------------------------------------------
  def load_notetags_ftb
    @ftb_cost = 1
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::USABLEITEM::FTB_COST
        @ftb_cost = $1.to_i
      end
    } # self.note.split
    #---
  end
  
end # RPG::UsableItem

#==============================================================================
# ■ BattleManager
#==============================================================================

module BattleManager
  
  #--------------------------------------------------------------------------
  # alias method: make_action_orders
  #--------------------------------------------------------------------------
  class <<self; alias make_action_orders_ftb make_action_orders; end
  def self.make_action_orders
    make_action_orders_ftb
    make_ftb_action_orders if btype?(:ftb)
  end
  
  #--------------------------------------------------------------------------
  # new method: make_ftb_action_orders
  #--------------------------------------------------------------------------
  def self.make_ftb_action_orders
    @action_battlers = []
    @action_battlers += $game_party.members unless @surprise
    @action_battlers += $game_troop.members unless @preemptive
    @action_battlers.each { |battler| battler.make_speed }
    @action_battlers.sort! {|a,b| a.screen_x <=> b.screen_x }
  end
  
  #--------------------------------------------------------------------------
  # alias method: judge_win_loss
  #--------------------------------------------------------------------------
  class <<self; alias judge_win_loss_ftb judge_win_loss; end
  def self.judge_win_loss
    if @phase && $game_troop.all_dead? && SceneManager.scene_is?(Scene_Battle)
      SceneManager.scene.hide_ftb_gauge
    end
    judge_win_loss_ftb
  end
  
end # BattleManager

#==============================================================================
# ■ Game_BattlerBase
#==============================================================================

class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # new method: init_ftb_actions
  #--------------------------------------------------------------------------
  def init_ftb_actions
    @used_ftb_actions = 0
  end
  
  #--------------------------------------------------------------------------
  # new method: ftb_actions
  #--------------------------------------------------------------------------
  def ftb_actions
    init_ftb_actions if @used_ftb_actions.nil?
    return @used_ftb_actions
  end
  
  #--------------------------------------------------------------------------
  # new method: max_ftb_actions
  #--------------------------------------------------------------------------
  def max_ftb_actions
    n = make_action_times
    n += agi_bonus_max_ftb_actions
    n += trait_bonus_max_ftb_actions
    return [n, 1].max
  end
  
  #--------------------------------------------------------------------------
  # new method: agi_bonus_max_ftb_actions
  #--------------------------------------------------------------------------
  def agi_bonus_max_ftb_actions
    bonus_agi = agi - param_base(6)
    value_agi = param_base(6) * YEA::FTB::EXTRA_FTB_ACTION_BONUS
    return (bonus_agi / value_agi).to_i
  end
  
  #--------------------------------------------------------------------------
  # new method: trait_bonus_max_ftb_actions
  #--------------------------------------------------------------------------
  def trait_bonus_max_ftb_actions
    n = 0
    if actor?
      n += self.actor.ftb_actions
      n += self.class.ftb_actions
      for equip in equips
        next if equip.nil?
        n += equip.ftb_actions
      end
    end
    for state in states
      next if state.nil?
      n += state.ftb_actions
    end
    return n
  end
  
  #--------------------------------------------------------------------------
  # new method: use_ftb_action
  #--------------------------------------------------------------------------
  def use_ftb_action(value = 1)
    init_ftb_actions if @used_ftb_actions.nil?
    @used_ftb_actions += value
  end
  
  #--------------------------------------------------------------------------
  # alias method: inputable?
  #--------------------------------------------------------------------------
  alias game_battlerbase_inputable_ftb inputable?
  def inputable?
    result = game_battlerbase_inputable_ftb
    return false unless result
    return result unless SceneManager.scene_is?(Scene_Battle)
    return result unless BattleManager.btype?(:ftb)
    return result unless YEA::FTB::LIMITED_ACTIONS_PER_MEMBER
    return max_ftb_actions > ftb_actions
  end
  
  #--------------------------------------------------------------------------
  # alias method: skill_conditions_met?
  #--------------------------------------------------------------------------
  alias game_battlerbase_skill_conditions_met_ftb skill_conditions_met?
  def skill_conditions_met?(skill)
    return false unless ftb_item_conditions_met?(skill)
    return game_battlerbase_skill_conditions_met_ftb(skill)
  end
  
  #--------------------------------------------------------------------------
  # alias method: item_conditions_met?
  #--------------------------------------------------------------------------
  alias game_battlerbase_item_conditions_met_ftb item_conditions_met?
  def item_conditions_met?(item)
    return false unless ftb_item_conditions_met?(item)
    return game_battlerbase_item_conditions_met_ftb(item)
  end
  
  #--------------------------------------------------------------------------
  # new method: ftb_item_conditions_met?
  #--------------------------------------------------------------------------
  def ftb_item_conditions_met?(item)
    return true unless actor?
    return true unless SceneManager.scene_is?(Scene_Battle)
    return true unless BattleManager.btype?(:ftb)
    return true if BattleManager.in_turn?
    return $game_party.ftb_actions_remaining >= item.ftb_cost
  end
  
end # Game_BattlerBase

#==============================================================================
# ■ Game_Battler
#==============================================================================

class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: on_battle_start
  #--------------------------------------------------------------------------
  alias game_battler_on_battle_start_ftb on_battle_start
  def on_battle_start
    game_battler_on_battle_start_ftb
    init_ftb_actions
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_turn_end
  #--------------------------------------------------------------------------
  alias game_battler_on_turn_end_ftb on_turn_end
  def on_turn_end
    game_battler_on_turn_end_ftb
    init_ftb_actions
  end
  
  #--------------------------------------------------------------------------
  # alias method: make_action_times
  #--------------------------------------------------------------------------
  alias game_battler_make_action_times_ftb make_action_times
  def make_action_times
    if SceneManager.scene_is?(Scene_Battle) && BattleManager.btype?(:ftb)
      return make_ftb_action_times
    else
      return game_battler_make_action_times_ftb
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: make_ftb_action_times
  #--------------------------------------------------------------------------
  def make_ftb_action_times
    return action_plus_set.inject(1) {|r, p| p > 0.01 ? r + 1 : r }
  end
  
end # Game_Battler

#==============================================================================
# ■ Game_Actor
#==============================================================================

class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # alias method: next_command
  #--------------------------------------------------------------------------
  alias game_actor_next_command_ftb next_command
  def next_command
    if SceneManager.scene_is?(Scene_Battle) && BattleManager.btype?(:ftb)
      return false
    end
    return game_actor_next_command_ftb
  end
  
  #--------------------------------------------------------------------------
  # alias method: prior_command
  #--------------------------------------------------------------------------
  alias game_actor_prior_command_ftb prior_command
  def prior_command
    if SceneManager.scene_is?(Scene_Battle) && BattleManager.btype?(:ftb)
      return false
    end
    return game_actor_prior_command_ftb
  end
  
end # Game_Actor

#==============================================================================
# ■ Game_Party
#==============================================================================

class Game_Party < Game_Unit
  
  #--------------------------------------------------------------------------
  # alias method: inputable?
  #--------------------------------------------------------------------------
  alias game_party_inputable_ftb inputable?
  def inputable?
    return false unless meet_ftb_requirements?
    return game_party_inputable_ftb
  end
  
  #--------------------------------------------------------------------------
  # new method: meet_ftb_requirements?
  #--------------------------------------------------------------------------
  def meet_ftb_requirements?
    return true unless BattleManager.btype?(:ftb)
    return ftb_actions_remaining > 0
  end
  
  #--------------------------------------------------------------------------
  # new method: ftb_actions_remaining
  #--------------------------------------------------------------------------
  def ftb_actions_remaining
    return ftb_actions_maximum - ftb_actions_used
  end
  
  #--------------------------------------------------------------------------
  # new method: ftb_actions_maximum
  #--------------------------------------------------------------------------
  def ftb_actions_maximum
    n = 0
    for member in $game_party.members
      next unless member.game_battlerbase_inputable_ftb
      n += member.max_ftb_actions
    end
    return [n, YEA::FTB::MAXIMUM_FTB_ACTIONS].min
  end
  
  #--------------------------------------------------------------------------
  # new method: ftb_actions_used
  #--------------------------------------------------------------------------
  def ftb_actions_used
    n = 0
    for member in $game_party.members
      next unless member.game_battlerbase_inputable_ftb
      n += member.ftb_actions
    end
    return n
  end
  
end # Game_Party

#==============================================================================
# ■ Window_BattleStatus
#==============================================================================

class Window_BattleStatus < Window_Selectable
  
  #--------------------------------------------------------------------------
  # alias method: action_icon
  #--------------------------------------------------------------------------
  alias window_battlestatus_action_icon_ftb action_icon
  def action_icon(actor)
    if SceneManager.scene_is?(Scene_Battle) && BattleManager.btype?(:ftb)
      return Icon.ftb_action if act_ftb_valid?(actor)
    end
    return window_battlestatus_action_icon_ftb(actor)
  end
  
  #--------------------------------------------------------------------------
  # new method: act_ftb_valid?
  #--------------------------------------------------------------------------
  def act_ftb_valid?(actor)
    return false unless actor.current_action.nil? ||
      actor.current_action.item.nil?
    return true unless YEA::FTB::LIMITED_ACTIONS_PER_MEMBER
    return actor.max_ftb_actions > actor.ftb_actions
  end
  
end # Window_BattleStatus

#==============================================================================
# ■ Window_FTB_Gauge
#==============================================================================

class Window_FTB_Gauge < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(help_window)
    @help_window = help_window
    super(0, 0, Graphics.width, fitting_height(1))
    self.opacity = 0
    self.contents_opacity = 0
    self.z = 200
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    draw_empty_icons
    draw_filled_icons
  end
  
  #--------------------------------------------------------------------------
  # draw_empty_icons
  #--------------------------------------------------------------------------
  def draw_empty_icons
    n = $game_party.ftb_actions_maximum
    dx = contents.width
    n.times do
      dx -= 24
      draw_icon(Icon.ftb_empty, dx, 0)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_filled_icons
  #--------------------------------------------------------------------------
  def draw_filled_icons
    n = $game_party.ftb_actions_maximum - $game_party.ftb_actions_used
    dx = contents.width
    n.times do
      dx -= 24
      draw_icon(Icon.ftb_action, dx, 0)
    end
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    self.contents_opacity = 0 unless SceneManager.scene_is?(Scene_Battle)
    return unless SceneManager.scene_is?(Scene_Battle)
    return unless BattleManager.btype?(:ftb)
    change_contents_opacity
    change_y_position
  end
  
  #--------------------------------------------------------------------------
  # change_contents_opacity
  #--------------------------------------------------------------------------
  def change_contents_opacity
    rate = BattleManager.in_turn? ? -8 : 8
    self.contents_opacity += rate
  end
  
  #--------------------------------------------------------------------------
  # change_y_position
  #--------------------------------------------------------------------------
  def change_y_position
    self.y = @help_window.visible ? @help_window.height : 0
  end
  
end # Window_FTB_Gauge

#==============================================================================
# ■ Scene_Battle
#==============================================================================

class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: create_all_windows
  #--------------------------------------------------------------------------
  alias scene_battle_create_all_windows_ftb create_all_windows
  def create_all_windows
    scene_battle_create_all_windows_ftb
    create_ftb_gauge
  end
  
  #--------------------------------------------------------------------------
  # new method: create_ftb_gauge
  #--------------------------------------------------------------------------
  def create_ftb_gauge
    @ftb_gauge = Window_FTB_Gauge.new(@help_window)
  end
  
  #--------------------------------------------------------------------------
  # alias method: start_party_command_selection
  #--------------------------------------------------------------------------
  alias start_party_command_selection_ftb start_party_command_selection
  def start_party_command_selection
    start_party_command_selection_ftb
    refresh_ftb_gauge
  end
  
  #--------------------------------------------------------------------------
  # alias method: start_actor_command_selection
  #--------------------------------------------------------------------------
  alias start_actor_command_selection_ftb start_actor_command_selection
  def start_actor_command_selection
    start_actor_command_selection_ftb
    refresh_ftb_gauge
  end
  
  #--------------------------------------------------------------------------
  # new method: refresh_ftb_gauge
  #--------------------------------------------------------------------------
  def refresh_ftb_gauge
    @ftb_gauge.refresh
  end
  
  #--------------------------------------------------------------------------
  # new method: hide_ftb_gauge
  #--------------------------------------------------------------------------
  def hide_ftb_gauge
    @ftb_gauge.hide
  end
  
  #--------------------------------------------------------------------------
  # alias method: next_command
  #--------------------------------------------------------------------------
  alias scene_battle_next_command_ftb next_command
  def next_command
    if ftb_action?
      perform_ftb_action
    else
      scene_battle_next_command_ftb
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: ftb_action?
  #--------------------------------------------------------------------------
  def ftb_action?
    return false unless BattleManager.btype?(:ftb)
    return false if BattleManager.actor.nil?
    return false if BattleManager.actor.current_action.nil?
    action = BattleManager.actor.current_action.item
    return !action.nil?
  end
  
  #--------------------------------------------------------------------------
  # new method: perform_ftb_action
  #--------------------------------------------------------------------------
  def perform_ftb_action
    hide_ftb_action_windows
    @subject = BattleManager.actor
    item = @subject.current_action.item
    execute_action
    process_event
    loop do
      @subject.remove_current_action
      break if $game_troop.all_dead?
      break unless @subject.current_action
      @subject.current_action.prepare
      execute_action if @subject.current_action.valid?
    end
    return if $game_troop.alive_members.size <= 0
    process_action_end
    consume_ftb_action(item)
    @subject.make_actions
    @subject = nil
    show_ftb_action_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: consume_ftb_action
  #--------------------------------------------------------------------------
  def consume_ftb_action(item)
    @subject.use_ftb_action(item.ftb_cost) unless item.nil?
    refresh_ftb_gauge
  end
  
  #--------------------------------------------------------------------------
  # new method: hide_ftb_action_windows
  #--------------------------------------------------------------------------
  def hide_ftb_action_windows
    @info_viewport.visible = true
    @status_aid_window.hide
    @status_window.show
    @actor_command_window.show
  end
  
  #--------------------------------------------------------------------------
  # new method: show_ftb_action_windows
  #--------------------------------------------------------------------------
  def show_ftb_action_windows
    @info_viewport.visible = true
    end_ftb_action
  end
  
  #--------------------------------------------------------------------------
  # new method: end_ftb_action
  #--------------------------------------------------------------------------
  def end_ftb_action
    if $game_party.inputable?
      select_next_member
    else
      status_redraw_target(BattleManager.actor)
      BattleManager.next_command
      turn_start
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: select_next_member
  #--------------------------------------------------------------------------
  def select_next_member
    status_redraw_target(BattleManager.actor)
    last_index = $game_party.battle_members.size - 1
    for member in $game_party.battle_members.reverse
      break if member.inputable?
      last_index -= 1
    end
    next_command if next_ftb_member?(last_index)
    return if BattleManager.actor.nil?
    if BattleManager.actor.index >= last_index && !BattleManager.actor.inputable?
      prior_command
    else
      start_actor_command_selection
      status_redraw_target(BattleManager.actor)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: next_ftb_member?
  #--------------------------------------------------------------------------
  def next_ftb_member?(last_index)
    actor = BattleManager.actor
    return true if actor.nil?
    return false if actor.max_ftb_actions > actor.ftb_actions
    return false if BattleManager.actor.index >= last_index
    return BattleManager.actor.index != last_index
  end
  
  #--------------------------------------------------------------------------
  # alias method: hide_extra_gauges
  #--------------------------------------------------------------------------
  alias scene_battle_hide_extra_gauges_ftb hide_extra_gauges
  def hide_extra_gauges
    scene_battle_hide_extra_gauges_ftb
    @ftb_gauge.hide
  end
  
  #--------------------------------------------------------------------------
  # alias method: show_extra_gauges
  #--------------------------------------------------------------------------
  alias scene_battle_show_extra_gauges_ftb show_extra_gauges
  def show_extra_gauges
    scene_battle_show_extra_gauges_ftb
    @ftb_gauge.show
  end
  
end # Scene_Battle

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - Combat Log Display v1.02
# -- Last Updated: 2012.01.24
# -- Level: Easy
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-CombatLogDisplay"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.24 - Bug Fixed: Confirm window crash with Battle Command List.
# 2012.01.16 - Prevented subsequent line inserts.
# 2011.12.10 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# Sometimes text appears way too fast in the battle system or sometimes players
# may miss what kind of information was delivered on-screen. For times like
# that, being able to access the combat log would be important. The combat log
# records all of the text that appears in the battle log window at the top.
# The player can access the combat log display any time during action selection
# phase. Sometimes, players can even review over the combat log to try and
# figure out any kinds of patterns enemies may even have.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module COMBAT_LOG
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Combat Log Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Adjust the settings here to modify how the combat log works for your
    # game. You can change the command name and extra text that gets fitted
    # into the combat log over time. If you don't want specific text to appear,
    # just set the text to "" and nothing will show.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMAND_NAME      = "CombatLog"    # Command list name.
    LINE_COLOUR       = 0              # Line colour for separators.
    LINE_COLOUR_ALPHA = 48             # Opacity of the line colour.
    TEXT_BATTLE_START = "\\c[4]Battle Start!"           # Battle start text.
    TEXT_TURN_NUMBER  = "\\c[4]Turn Number: \\c[6]%d"   # Turn number text.
    
  end # COMBAT_LOG
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

#==============================================================================
# ■ Window_BattleLog
#==============================================================================

class Window_BattleLog < Window_Selectable
  
  #--------------------------------------------------------------------------
  # new method: combatlog_window=
  #--------------------------------------------------------------------------
  def combatlog_window=(window)
    @combatlog_window = window
  end
  
  #--------------------------------------------------------------------------
  # new method: combatlog
  #--------------------------------------------------------------------------
  def combatlog(text)
    return if @combatlog_window.nil?
    return if text == ""
    @combatlog_window.add_line(text)
  end
  
  #--------------------------------------------------------------------------
  # alias method: add_text
  #--------------------------------------------------------------------------
  alias window_battlelog_add_text_cld add_text
  def add_text(text)
    combatlog(text)
    window_battlelog_add_text_cld(text)
  end
  
  #--------------------------------------------------------------------------
  # alias method: replace_text
  #--------------------------------------------------------------------------
  alias window_battlelog_replace_text_cld replace_text
  def replace_text(text)
    combatlog(text)
    window_battlelog_replace_text_cld(text)
  end
  
  #--------------------------------------------------------------------------
  # Start Ace Battle Engine Compatibility
  #--------------------------------------------------------------------------
  if $imported["YEA-BattleEngine"]
  
  #--------------------------------------------------------------------------
  # alias method: display_current_state
  #--------------------------------------------------------------------------
  alias window_battlelog_display_current_state_cld display_current_state
  def display_current_state(subject)
    window_battlelog_display_current_state_cld(subject)
    return if YEA::BATTLE::MSG_CURRENT_STATE
    return if subject.most_important_state_text.empty?
    combatlog(subject.name + subject.most_important_state_text)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_use_item
  #--------------------------------------------------------------------------
  alias window_battlelog_display_use_item_cld display_use_item
  def display_use_item(subject, item)
    window_battlelog_display_use_item_cld(subject, item)
    return if YEA::BATTLE::MSG_CURRENT_ACTION
    if item.is_a?(RPG::Skill)
      combatlog(subject.name + item.message1)
      unless item.message2.empty?
        combatlog(item.message2)
      end
    else
      combatlog(sprintf(Vocab::UseItem, subject.name, item.name))
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_counter
  #--------------------------------------------------------------------------
  alias window_battlelog_display_counter_cld display_counter
  def display_counter(target, item)
    window_battlelog_display_counter_cld(target, item)
    return if YEA::BATTLE::MSG_COUNTERATTACK
    combatlog(sprintf(Vocab::CounterAttack, target.name))
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_reflection
  #--------------------------------------------------------------------------
  alias window_battlelog_display_reflection_cld display_reflection
  def display_reflection(target, item)
    window_battlelog_display_reflection_cld(target, item)
    return if YEA::BATTLE::MSG_REFLECT_MAGIC
    combatlog(sprintf(Vocab::MagicReflection, target.name))
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_substitute
  #--------------------------------------------------------------------------
  alias window_battlelog_display_substitute_cld display_substitute
  def display_substitute(substitute, target)
    window_battlelog_display_substitute_cld(substitute, target)
    return if YEA::BATTLE::MSG_SUBSTITUTE_HIT
    combatlog(sprintf(Vocab::Substitute, substitute.name, target.name))
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_failure
  #--------------------------------------------------------------------------
  alias window_battlelog_display_failure_cld display_failure
  def display_failure(target, item)
    window_battlelog_display_failure_cld(target, item)
    return if YEA::BATTLE::MSG_FAILURE_HIT
    if target.result.hit? && !target.result.success
      combatlog(sprintf(Vocab::ActionFailure, target.name))
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_critical
  #--------------------------------------------------------------------------
  alias window_battlelog_display_critical_cld display_critical
  def display_critical(target, item)
    window_battlelog_display_critical_cld(target, item)
    return if YEA::BATTLE::MSG_CRITICAL_HIT
    if target.result.critical
      text = target.actor? ? Vocab::CriticalToActor : Vocab::CriticalToEnemy
      combatlog(text)
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_miss
  #--------------------------------------------------------------------------
  alias window_battlelog_display_miss_cld display_miss
  def display_miss(target, item)
    window_battlelog_display_miss_cld(target, item)
    return if YEA::BATTLE::MSG_HIT_MISSED
    if !item || item.physical?
      fmt = target.actor? ? Vocab::ActorNoHit : Vocab::EnemyNoHit
    else
      fmt = Vocab::ActionFailure
    end
    combatlog(sprintf(fmt, target.name))
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_evasion
  #--------------------------------------------------------------------------
  alias window_battlelog_display_evasion_cld display_evasion
  def display_evasion(target, item)
    window_battlelog_display_evasion_cld(target, item)
    return if YEA::BATTLE::MSG_EVASION
    if !item || item.physical?
      fmt = Vocab::Evasion
    else
      fmt = Vocab::MagicEvasion
    end
    combatlog(sprintf(fmt, target.name))
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_hp_damage
  #--------------------------------------------------------------------------
  alias window_battlelog_display_hp_damage_cld display_hp_damage
  def display_hp_damage(target, item)
    window_battlelog_display_hp_damage_cld(target, item)
    return if YEA::BATTLE::MSG_HP_DAMAGE
    return if target.result.hp_damage == 0 && item && !item.damage.to_hp?
    combatlog(target.result.hp_damage_text)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_mp_damage
  #--------------------------------------------------------------------------
  alias window_battlelog_display_mp_damage_cld display_mp_damage
  def display_mp_damage(target, item)
    window_battlelog_display_mp_damage_cld(target, item)
    return if YEA::BATTLE::MSG_MP_DAMAGE
    combatlog(target.result.mp_damage_text)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_tp_damage
  #--------------------------------------------------------------------------
  alias window_battlelog_display_tp_damage_cld display_tp_damage
  def display_tp_damage(target, item)
    window_battlelog_display_tp_damage_cld(target, item)
    return if YEA::BATTLE::MSG_TP_DAMAGE
    combatlog(target.result.tp_damage_text)
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_added_states
  #--------------------------------------------------------------------------
  alias window_battlelog_display_added_states_cld display_added_states
  def display_added_states(target)
    window_battlelog_display_added_states_cld(target)
    return if YEA::BATTLE::MSG_ADDED_STATES
    target.result.added_state_objects.each do |state|
      state_msg = target.actor? ? state.message1 : state.message2
      next if state_msg.empty?
      combatlog(target.name + state_msg)
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_removed_states
  #--------------------------------------------------------------------------
  alias window_battlelog_display_removed_states_cld display_removed_states
  def display_removed_states(target)
    window_battlelog_display_removed_states_cld(target)
    return if YEA::BATTLE::MSG_REMOVED_STATES
    target.result.removed_state_objects.each do |state|
      next if state.message4.empty?
      combatlog(target.name + state.message4)
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: display_buffs
  #--------------------------------------------------------------------------
  alias window_battlelog_display_buffs_cld display_buffs
  def display_buffs(target, buffs, fmt)
    window_battlelog_display_buffs_cld(target, buffs, fmt)
    return if YEA::BATTLE::MSG_CHANGED_BUFFS
    buffs.each do |param_id|
      combatlog(sprintf(fmt, target.name, Vocab::param(param_id)))
    end
  end
  
  #--------------------------------------------------------------------------
  # End Ace Battle Engine Compatibility
  #--------------------------------------------------------------------------
  end # $imported["YEA-BattleEngine"]
  
end # Window_BattleLog

#==============================================================================
# ■ Window_CombatLog
#==============================================================================

class Window_CombatLog < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize
    @data = []
    super(0, 0, Graphics.width, Graphics.height-120)
    deactivate
    hide
  end
  
  #--------------------------------------------------------------------------
  # add_line
  #--------------------------------------------------------------------------
  def add_line(text)
    return if text == "-" && @data[@data.size - 1] == "-"
    @data.push(text)
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return @data.size; end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    text = @data[index]
    return if text.nil?
    rect = item_rect_for_text(index)
    if text == "-"
      draw_horz_line(rect.y)
    else
      draw_text_ex(rect.x, rect.y, text)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_horz_line
  #--------------------------------------------------------------------------
  def draw_horz_line(y)
    line_y = y + line_height / 2 - 1
    contents.fill_rect(4, line_y, contents_width-8, 2, line_colour)
  end
  
  #--------------------------------------------------------------------------
  # line_colour
  #--------------------------------------------------------------------------
  def line_colour
    colour = text_color(YEA::COMBAT_LOG::LINE_COLOUR)
    colour.alpha = YEA::COMBAT_LOG::LINE_COLOUR_ALPHA
    return colour
  end
  
  #--------------------------------------------------------------------------
  # show
  #--------------------------------------------------------------------------
  def show
    super
    refresh
    activate
    select([item_max-1, 0].max)
  end
  
  #--------------------------------------------------------------------------
  # hide
  #--------------------------------------------------------------------------
  def hide
    deactivate
    super
  end
  
end # Window_CombatLog

#==============================================================================
# ■ Window_PartyCommand
#==============================================================================

class Window_PartyCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # alias method: make_command_list
  #--------------------------------------------------------------------------
  alias window_partycommand_make_command_list_cld make_command_list
  def make_command_list
    window_partycommand_make_command_list_cld
    return if $imported["YEA-BattleCommandList"]
    add_command(YEA::COMBAT_LOG::COMMAND_NAME, :combatlog)
  end
  
end # Window_PartyCommand

#==============================================================================
# ■ Scene_Battle
#==============================================================================

class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: create_log_window
  #--------------------------------------------------------------------------
  alias scene_battle_create_log_window_cld create_log_window
  def create_log_window
    scene_battle_create_log_window_cld
    create_combatlog_window
  end
  
  #--------------------------------------------------------------------------
  # new method: create_combatlog_window
  #--------------------------------------------------------------------------
  def create_combatlog_window
    @combatlog_window = Window_CombatLog.new
    @log_window.combatlog_window = @combatlog_window
    @combatlog_window.set_handler(:cancel, method(:close_combatlog))
    @combatlog_window.add_line("-")
    @combatlog_window.add_line(YEA::COMBAT_LOG::TEXT_BATTLE_START)
    @combatlog_window.add_line("-")
  end
  
  #--------------------------------------------------------------------------
  # new method: open_combatlog
  #--------------------------------------------------------------------------
  def open_combatlog
    @combatlog_window.show
  end
  
  #--------------------------------------------------------------------------
  # new method: close_combatlog
  #--------------------------------------------------------------------------
  def close_combatlog
    @combatlog_window.hide
    if $imported["YEA-BattleCommandList"]
      if !@confirm_command_window.nil? && @confirm_command_window.visible
        @confirm_command_window.activate
      else
        @party_command_window.activate
      end
    else
      @party_command_window.activate
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_party_command_window
  #--------------------------------------------------------------------------
  alias create_party_command_window_cld create_party_command_window
  def create_party_command_window
    create_party_command_window_cld
    @party_command_window.set_handler(:combatlog, method(:open_combatlog))
  end
  
  #--------------------------------------------------------------------------
  # alias method: turn_start
  #--------------------------------------------------------------------------
  alias scene_battle_turn_start_cld turn_start
  def turn_start
    scene_battle_turn_start_cld
    @combatlog_window.add_line("-")
    text = sprintf(YEA::COMBAT_LOG::TEXT_TURN_NUMBER, $game_troop.turn_count)
    @combatlog_window.add_line(text)
    @combatlog_window.add_line("-")
  end
  
  #--------------------------------------------------------------------------
  # alias method: execute_action
  #--------------------------------------------------------------------------
  alias scene_battle_execute_action_cld execute_action
  def execute_action
    @combatlog_window.add_line("-")
    scene_battle_execute_action_cld
    @combatlog_window.add_line("-")
  end
  
  #--------------------------------------------------------------------------
  # alias method: turn_end
  #--------------------------------------------------------------------------
  alias scene_battle_turn_end_cld turn_end
  def turn_end
    scene_battle_turn_end_cld
    @combatlog_window.add_line("-")
  end
  
end # Scene_Battle

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - Battle Engine Add-On: Enemy HP Bars v1.10
# -- Last Updated: 2012.02.10
# -- Level: Easy, Normal
# -- Requires: YEA - Ace Battle Engine v1.00+.
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-EnemyHPBars"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.02.10 - Bug Fixed: AoE selection doesn't reveal hidden enemies.
# 2012.02.01 - Bug Fixed: Back and front of gauge randomly don't appear.
# 2012.01.11 - Efficiency update.
# 2012.01.04 - Compatibility Update: Area of Effect
# 2011.12.28 - Efficiency update.
#            - Bug Fixed: HP bars didn't disappear after a heal.
# 2011.12.26 - Bug Fixed: HP bars were not depleting.
# 2011.12.23 - Efficiency update.
# 2011.12.10 - Bug Fixed: HP bars no longer appear when dead and an AoE skill
#              has been selected.
# 2011.12.08 - New feature. Hide HP Bars until defeated once.
# 2011.12.06 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script shows HP gauges on enemies as they're selected for targeting or
# whenever they're damaged. The HP gauges will actually slide downward or
# upward as the enemies take damage.
# 
# Included in v1.01 is the option to require the player having slain an enemy
# once before enemies of that type will show their HP gauge.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Enemy Notetags - These notetags go in the enemy notebox in the database.
# -----------------------------------------------------------------------------
# <back gauge: x>
# Changes the colour of the enemy HP back gauge to x where x is the text colour
# used from the "Window" skin image under Graphics\System.
# 
# <hp gauge 1: x>
# <hp gauge 2: x>
# Changes the colour of the enemy HP HP gauge to x where x is the text colour
# used from the "Window" skin image under Graphics\System.
# 
# <hide gauge>
# <show gauge>
# Hides/shows HP gauge for enemies in battle. These gauges appear whenever the
# enemy is targeted for battle or whenever the enemy takes HP damage. Note that
# using the <show gauge> tag will bypass the requirement for needing to defeat
# an enemy once if that setting is enabled.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
# This script requires Yanfly Engine Ace - Ace Battle Engine v1.00+ and the
# script must be placed under Ace Battle Engine in the script listing.
# 
#==============================================================================

module YEA
  module BATTLE
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Enemy HP Gauges -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Adjust the settings for the enemy HP gauges. You can choose to show the
    # enemy HP gauges by default, the size of the gauge, the colour of the
    # gauge, and the back colour of the gauge.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    SHOW_ENEMY_HP_GAUGE    = true   # Display Enemy HP Gauge?
    ANIMATE_HP_GAUGE       = true   # Animate the HP gauge?
    DEFEAT_ENEMIES_FIRST   = false  # Must defeat enemy first to show HP?
    ENEMY_GAUGE_WIDTH      = 128    # How wide the enemy gauges are.
    ENEMY_GAUGE_HEIGHT     = 12     # How tall the enemy gauges are.
    ENEMY_HP_GAUGE_COLOUR1 = 20     # Colour 1 for HP.
    ENEMY_HP_GAUGE_COLOUR2 = 21     # Colour 2 for HP.
    ENEMY_BACKGAUGE_COLOUR = 19     # Gauge Back colour.
    
  end # BATTLE
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

if $imported["YEA-BattleEngine"]

module YEA
  module REGEXP
  module ENEMY
    
    HIDE_GAUGE = /<(?:HIDE_GAUGE|hide gauge)>/i
    SHOW_GAUGE = /<(?:SHOW_GAUGE|show gauge)>/i
    
    BACK_GAUGE = /<(?:BACK_GAUGE|back gauge):[ ]*(\d+)>/i
    HP_GAUGE_1 = /<(?:HP_GAUGE_1|hp gauge 1):[ ]*(\d+)>/i
    HP_GAUGE_2 = /<(?:HP_GAUGE_2|hp gauge 2):[ ]*(\d+)>/i
    
  end # ENEMY
  end # REGEXP
end # YEA

#==============================================================================
# ■ DataManager
#==============================================================================

module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_ehpb load_database; end
  def self.load_database
    load_database_ehpb
    load_notetags_ehpb
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_ehpb
  #--------------------------------------------------------------------------
  def self.load_notetags_ehpb
    groups = [$data_enemies]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_ehpb
      end
    end
  end
  
end # DataManager

#==============================================================================
# ■ RPG::Enemy
#==============================================================================

class RPG::Enemy < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :show_gauge
  attr_accessor :require_death_show_gauge
  attr_accessor :back_gauge_colour
  attr_accessor :hp_gauge_colour1
  attr_accessor :hp_gauge_colour2
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_ehpb
  #--------------------------------------------------------------------------
  def load_notetags_ehpb
    @show_gauge = YEA::BATTLE::SHOW_ENEMY_HP_GAUGE
    @require_death_show_gauge = YEA::BATTLE::DEFEAT_ENEMIES_FIRST
    @back_gauge_colour = YEA::BATTLE::ENEMY_BACKGAUGE_COLOUR
    @hp_gauge_colour1 = YEA::BATTLE::ENEMY_HP_GAUGE_COLOUR1
    @hp_gauge_colour2 = YEA::BATTLE::ENEMY_HP_GAUGE_COLOUR2
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::ENEMY::HIDE_GAUGE
        @show_gauge = false
      when YEA::REGEXP::ENEMY::SHOW_GAUGE
        @show_gauge = true
        @require_death_show_gauge = false
      when YEA::REGEXP::ENEMY::BACK_GAUGE
        @back_gauge_colour = [$1.to_i, 31].min
      when YEA::REGEXP::ENEMY::HP_GAUGE_1
        @hp_gauge_colour1 = [$1.to_i, 31].min
      when YEA::REGEXP::ENEMY::HP_GAUGE_2
        @hp_gauge_colour2 = [$1.to_i, 31].min
      end
    } # self.note.split
    #---
  end
  
end # RPG::Enemy

#==============================================================================
# ■ Sprite_Battler
#==============================================================================

class Sprite_Battler < Sprite_Base
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias sprite_battler_initialize_ehpb initialize
  def initialize(viewport, battler = nil)
    sprite_battler_initialize_ehpb(viewport, battler)
    create_enemy_gauges
  end
  
  #--------------------------------------------------------------------------
  # alias method: dispose
  #--------------------------------------------------------------------------
  alias sprite_battler_dispose_ehpb dispose
  def dispose
    sprite_battler_dispose_ehpb
    dispose_enemy_gauges
  end
  
  #--------------------------------------------------------------------------
  # alias method: update
  #--------------------------------------------------------------------------
  alias sprite_battler_update_ehpb update
  def update
    sprite_battler_update_ehpb
    update_enemy_gauges
  end
  
  #--------------------------------------------------------------------------
  # new method: create_enemy_gauges
  #--------------------------------------------------------------------------
  def create_enemy_gauges
    return if @battler.nil?
    return if @battler.actor?
    return unless @battler.enemy.show_gauge
    @back_gauge_viewport = Enemy_HP_Gauge_Viewport.new(@battler, self, :back)
    @hp_gauge_viewport = Enemy_HP_Gauge_Viewport.new(@battler, self, :hp)
  end
  
  #--------------------------------------------------------------------------
  # new method: dispose_enemy_gauges
  #--------------------------------------------------------------------------
  def dispose_enemy_gauges
    @back_gauge_viewport.dispose unless @back_gauge_viewport.nil?
    @hp_gauge_viewport.dispose unless @hp_gauge_viewport.nil?
  end
  
  #--------------------------------------------------------------------------
  # new method: update_enemy_gauges
  #--------------------------------------------------------------------------
  def update_enemy_gauges
    @back_gauge_viewport.update unless @back_gauge_viewport.nil?
    @hp_gauge_viewport.update unless @hp_gauge_viewport.nil?
  end
  
  #--------------------------------------------------------------------------
  # new method: update_enemy_gauge_value
  #--------------------------------------------------------------------------
  def update_enemy_gauge_value
    @back_gauge_viewport.new_hp_updates unless @back_gauge_viewport.nil?
    @hp_gauge_viewport.new_hp_updates unless @hp_gauge_viewport.nil?
  end
  
end # Sprite_Battler

#==============================================================================
# ■ Game_BattlerBase
#==============================================================================

class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :hidden
  
  #--------------------------------------------------------------------------
  # alias method: refresh
  #--------------------------------------------------------------------------
  alias game_battlerbase_refresh_ehpb refresh
  def refresh
    game_battlerbase_refresh_ehpb
    return unless SceneManager.scene_is?(Scene_Battle)
    return if actor?
    sprite.update_enemy_gauge_value
  end
  
end # Game_BattlerBase

#==============================================================================
# ■ Game_Battler
#==============================================================================

class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: die
  #--------------------------------------------------------------------------
  alias game_battler_die_ehpb die
  def die
    game_battler_die_ehpb
    return if actor?
    $game_party.add_defeated_enemy(@enemy_id)
  end
  
  #--------------------------------------------------------------------------
  # alias method: hp=
  #--------------------------------------------------------------------------
  alias game_battlerbase_hpequals_ehpb hp=
  def hp=(value)
    game_battlerbase_hpequals_ehpb(value)
    return unless SceneManager.scene_is?(Scene_Battle)
    return if actor?
    return if value == 0
    sprite.update_enemy_gauge_value
  end
  
end # Game_Battler

#==============================================================================
# ■ Game_Party
#==============================================================================

class Game_Party < Game_Unit
  
  #--------------------------------------------------------------------------
  # alias method: init_all_items
  #--------------------------------------------------------------------------
  alias game_party_init_all_items_ehpb init_all_items
  def init_all_items
    game_party_init_all_items_ehpb
    @defeated_enemies = []
  end
  
  #--------------------------------------------------------------------------
  # new method: defeated_enemies
  #--------------------------------------------------------------------------
  def defeated_enemies
    @defeated_enemies = [] if @defeated_enemies.nil?
    return @defeated_enemies
  end
  
  #--------------------------------------------------------------------------
  # new method: add_defeated_enemy
  #--------------------------------------------------------------------------
  def add_defeated_enemy(id)
    @defeated_enemies = [] if @defeated_enemies.nil?
    @defeated_enemies.push(id) unless @defeated_enemies.include?(id)
  end
  
end # Game_Party

#==============================================================================
# ■ Enemy_HP_Gauge_Viewport
#==============================================================================

class Enemy_HP_Gauge_Viewport < Viewport
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(battler, sprite, type)
    @battler = battler
    @base_sprite = sprite
    @type = type
    dw = YEA::BATTLE::ENEMY_GAUGE_WIDTH
    dw += 2 if @type == :back
    @start_width = dw
    dh = YEA::BATTLE::ENEMY_GAUGE_HEIGHT
    dh += 2 if @type == :back
    rect = Rect.new(0, 0, dw, dh)
    @current_hp = @battler.hp
    @current_mhp = @battler.mhp
    @target_gauge_width = target_gauge_width
    @gauge_rate = 1.0
    setup_original_hide_gauge
    super(rect)
    self.z = 125
    create_gauge_sprites
    self.visible = false
    update_position
  end
  
  #--------------------------------------------------------------------------
  # dispose
  #--------------------------------------------------------------------------
  def dispose
    @sprite.bitmap.dispose unless @sprite.bitmap.nil?
    @sprite.dispose
    super
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    self.visible = gauge_visible?
    @sprite.ox += 4 if YEA::BATTLE::ANIMATE_HP_GAUGE
    update_position
    update_gauge
    @visible_counter -= 1
  end
  
  #--------------------------------------------------------------------------
  # setup_original_hide_gauge
  #--------------------------------------------------------------------------
  def setup_original_hide_gauge
    @original_hide = @battler.enemy.require_death_show_gauge
    return unless @original_hide
    if YEA::BATTLE::DEFEAT_ENEMIES_FIRST
      enemy_id = @battler.enemy_id
      @original_hide = !$game_party.defeated_enemies.include?(enemy_id)
    end
  end
  
  #--------------------------------------------------------------------------
  # create_gauge_sprites
  #--------------------------------------------------------------------------
  def create_gauge_sprites
    @sprite = Plane.new(self)
    dw = self.rect.width * 2
    @sprite.bitmap = Bitmap.new(dw, self.rect.height)
    case @type
    when :back
      colour1 = Colour.text_colour(@battler.enemy.back_gauge_colour)
      colour2 = Colour.text_colour(@battler.enemy.back_gauge_colour)
    when :hp
      colour1 = Colour.text_colour(@battler.enemy.hp_gauge_colour1)
      colour2 = Colour.text_colour(@battler.enemy.hp_gauge_colour2)
    end
    dx = 0
    dy = 0
    dw = self.rect.width
    dh = self.rect.height
    @gauge_width = target_gauge_width
    @sprite.bitmap.gradient_fill_rect(dx, dy, dw, dh, colour1, colour2)
    @sprite.bitmap.gradient_fill_rect(dw, dy, dw, dh, colour2, colour1)
    @visible_counter = 0
  end
  
  #--------------------------------------------------------------------------
  # update_visible
  #--------------------------------------------------------------------------
  def gauge_visible?
    update_original_hide
    return false if @original_hide
    return false if case_original_hide?
    return true if @visible_counter > 0
    return true if @gauge_width != @target_gauge_width
    if SceneManager.scene_is?(Scene_Battle)
      return false if SceneManager.scene.enemy_window.nil?
      unless @battler.dead?
        if SceneManager.scene.enemy_window.active
          return true if SceneManager.scene.enemy_window.enemy == @battler
          return true if SceneManager.scene.enemy_window.select_all?
          return true if highlight_aoe?
        end
      end
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # highlight_aoe?
  #--------------------------------------------------------------------------
  def highlight_aoe?
    return false unless $imported["YEA-AreaofEffect"]
    return false if @battler.enemy? && @battler.hidden
    return SceneManager.scene.enemy_window.hightlight_aoe?(@battler)
  end
  
  #--------------------------------------------------------------------------
  # new_hp_updates
  #--------------------------------------------------------------------------
  def new_hp_updates
    return if @current_hp == @battler.hp && @current_mhp == @battler.mhp
    @current_hp = @battler.hp
    @current_mhp = @battler.mhp
    return if @gauge_rate == target_gauge_rate
    @gauge_rate = target_gauge_rate
    @target_gauge_width = target_gauge_width
    @visible_counter = 60
  end
  
  #--------------------------------------------------------------------------
  # case_original_hide?
  #--------------------------------------------------------------------------
  def case_original_hide?
    return false if !@battler.enemy.require_death_show_gauge
    if YEA::BATTLE::DEFEAT_ENEMIES_FIRST
      enemy_id = @battler.enemy_id
      return true unless $game_party.defeated_enemies.include?(enemy_id)
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # update_original_hide
  #--------------------------------------------------------------------------
  def update_original_hide
    return unless @original_hide
    return if @battler.dead?
    enemy_id = @battler.enemy_id
    @original_hide = false if $game_party.defeated_enemies.include?(enemy_id)
  end
  
  #--------------------------------------------------------------------------
  # update_position
  #--------------------------------------------------------------------------
  def update_position
    dx = @battler.screen_x - @start_width / 2
    dy = @battler.screen_y
    self.rect.x = dx
    self.rect.y = dy
    dh = self.rect.height + 1
    dh += 2 unless @type == :back
    dy = [@battler.screen_y, Graphics.height - dh - 120].min
    dy += 1 unless @type == :back
    self.rect.y = dy
  end
  
  #--------------------------------------------------------------------------
  # update_gauge
  #--------------------------------------------------------------------------
  def update_gauge
    return if @gauge_width == @target_gauge_width
    rate = 3
    @target_gauge_width = target_gauge_width
    if @gauge_width > @target_gauge_width
      @gauge_width = [@gauge_width - rate, @target_gauge_width].max
    elsif @gauge_width < @target_gauge_width
      @gauge_width = [@gauge_width + rate, @target_gauge_width].min
    end
    @visible_counter = @gauge_width == 0 ? 10 : 60
    return if @type == :back
    self.rect.width = @gauge_width
  end
  
  #--------------------------------------------------------------------------
  # target_gauge_rate
  #--------------------------------------------------------------------------
  def target_gauge_rate
    return @current_hp.to_f / @current_mhp.to_f
  end
  
  #--------------------------------------------------------------------------
  # target_gauge_width
  #--------------------------------------------------------------------------
  def target_gauge_width
    return [@current_hp * @start_width / @current_mhp, @start_width].min
  end
  
end # Enemy_HP_Gauge_Viewport

end # $imported["YEA-BattleEngine"]

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================




#==============================================================================
# 
# ▼ Yanfly Engine Ace - Enemy Target Info v1.02
# -- Last Updated: 2012.01.01
# -- Level: Normal
# -- Requires: YEA - Ace Battle Engine v1.10+.
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-EnemyTargetInfo"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.01 - Bug Fixed: <scan info: all> didn't work properly.
# 2011.12.30 - Bug Fixed: Crash when using Ace Battle Engine's F8 debug.
# 2011.12.29 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# The enemy target info window can be activated in battle to show enemy data
# at the bottom of the screen. Information can be revealed straight from the
# start or requires the player to actively reveal the information on their own
# through either defeating the enemies, using skills on them, or scanning them
# in various ways produced by the script.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Skill Notetags - These notetags go in the skill notebox in the database.
# -----------------------------------------------------------------------------
# <scan info: all>
# This will scan the target enemy of all properties that are shown in the
# comparison windows. Unless the enemy has a permanent hide tag, all of the
# data becomes available.
# 
# <scan info: parameters>
# This will scan the target enemy's parameters and reveal them to the player
# unless the enemy has a permanent hide tag.
# 
# <scan info: elements>
# This will scan the target enemy's elemental resistances and reveal them to
# the player unless the enemy has a permanent hide tag.
# 
# <scan info: states>
# This will scan the target enemy's state resistances and reveal them to the
# player unless the enemy has a permanent hide tag.
# 
# <scan element: x>
# <scan element: x, x>
# This will scan the target enemy's elemental resistance for element x. Insert
# multiple of these tags to scan more elements. If you have the automatic scan
# element setting on in the module, all skills and items will automatically
# scan whatever element the skill or item deals damage with innately.
# 
# <scan state: x>
# <scan state: x, x>
# This will scan the target enemy's state resistance for element x. Insert
# multiple of these tags to scan more states. If you have the automatic scan
# state setting on in the module, all skills and items will automatically
# scan whatever state the skill or item inflicts innately.
# 
# -----------------------------------------------------------------------------
# Item Notetags - These notetags go in the item notebox in the database.
# -----------------------------------------------------------------------------
# <scan info: all>
# This will scan the target enemy of all properties that are shown in the
# comparison windows. Unless the enemy has a permanent hide tag, all of the
# data becomes available.
# 
# <scan info: parameters>
# This will scan the target enemy's parameters and reveal them to the player
# unless the enemy has a permanent hide tag.
# 
# <scan info: elements>
# This will scan the target enemy's elemental resistances and reveal them to
# the player unless the enemy has a permanent hide tag.
# 
# <scan info: states>
# This will scan the target enemy's state resistances and reveal them to the
# player unless the enemy has a permanent hide tag.
# 
# <scan element: x>
# <scan element: x, x>
# This will scan the target enemy's elemental resistance for element x. Insert
# multiple of these tags to scan more elements. If you have the automatic scan
# element setting on in the module, all skills and items will automatically
# scan whatever element the skill or item deals damage with innately.
# 
# <scan state: x>
# <scan state: x, x>
# This will scan the target enemy's state resistance for element x. Insert
# multiple of these tags to scan more states. If you have the automatic scan
# state setting on in the module, all skills and items will automatically
# scan whatever state the skill or item inflicts innately.
# 
# -----------------------------------------------------------------------------
# Enemy Notetags - These notetags go in the enemies notebox in the database.
# -----------------------------------------------------------------------------
# <hide info: all>
# <show info: all>
# These notetags will set the enemy to either always hide all of their battle
# information or to always show all of their info. The tags will override
# each other if both are used simultaneously.
# 
# <hide info: parameters>
# <show info: parameters>
# These notetags will set the enemy to either always hide their parameter
# information or to always show their parameter info. The tags will override
# each other if both are used simultaneously.
# 
# <hide info: elements>
# <show info: elements>
# These notetags will set the enemy to either always hide their element
# information or to always show their element info. The tags will override
# each other if both are used simultaneously.
# 
# <hide info: states>
# <show info: states>
# These notetags will set the enemy to either always hide their state
# information or to always show their state info. The tags will override
# each other if both are used simultaneously.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
# This script requires Yanfly Engine Ace - Ace Battle Engine v1.10+ and the
# script must be placed under Ace Battle Engine in the script listing.
# 
#==============================================================================

module YEA
  module ENEMY_INFO
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Info Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These are the general settings revolving around the info windows shown in
    # battle such as the sound effect played, the button used to open up the
    # menus, the page orders, and the info text.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    INFO_SFX = RPG::SE.new("Book2", 80, 150) # SFX played for Info Window.
    
    # Button used to toggle the Info Window. Keep in mind that L and R are
    # used for moving between pages so it's best to not use those.
    INFO_BUTTON = :SHIFT
    
    # This sets the page order in which data is displayed for the player. The
    # player can switch pages by pressing L or R.
    PAGE_ORDER =[
      :parameters,
      :elements,
      :states,
    ] # Do not remove this.
    
    # If testplay is being used, reveal all battle information for non-hidden
    # enemy information?
    SHOW_DEBUG_ALL = true
    
    # The follow adjusts the settings regarding the help window. If this
    # setting is on, the the help info will be displayed.
    SHOW_HELP_INFO = true
    HELP_WINDOW_Y  = 72    # Y location of the help window.
    
    # This is the text displayed to let the player know how to activate and
    # show the info windows.
    HELP_INFO_SHOW = "\e}Press \eC[4]SHIFT\eC[0] to show target info."
    
    # This is the text displayed to let the player know how to switch between
    # pages for the info windows.
    HELP_INFO_SWITCH = "\e}Press \eC[4]L\eC[0] or \eC[4]R\eC[0] to switch info."
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Page Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The general page shows the stats of the battlers. The player can compare
    # and contrast the stats of both battlers relative to each other. The
    # settings here adjust the font size, the text displayed if parameters are
    # hidden, and whether or not to show parameters by default?
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    PARAM_FONT_SIZE     = 20       # Font size used for parameters.
    HIDDEN_PARAM_TEXT   = "???"    # Text used if parameters are hidden.
    
    # Show the parameters by default? If false, the enemy must be defeated once
    # or scanned to show the those parameters.
    DEFAULT_SHOW_PARAMS = false
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Element Page Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The elements page shows the elemental resistances of the battlers. The
    # player can compare and contrast the resistances relative to each other.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ELE_FONT_SIZE   = 20       # Font size used for element resistances.
    HIDDEN_ELE_TEXT = "???"    # Text used if element resistances are hidden.
    SHOWN_ELEMENTS  = [3..10]  # Elements shown. Maximum of 8 can be shown.
    ELEMENT_ICONS   ={         # Contains element icon information.
    # Element ID => Icon,
               3 =>  96, # Fire
               4 =>  97, # Ice
               5 =>  98, # Thunder
               6 =>  99, # Water
               7 => 100, # Earth
               8 => 101, # Wind
               9 => 102, # Holy
              10 => 103, # Dark
    } # Do not remove this.
    
    # Show the elemental resistances by default? If false, a skill with the
    # specific element must be used on the enemy to reveal the element data if
    # the AUTO_SCAN_ELEMENT setting is set to true.
    DEFAULT_SHOW_ELEMENTS = false
    
    # If this is set to true, then skills with elemental properties will
    # automatically scan the specific elemental resistance of that enemy type
    # when used against that enemy.
    AUTO_SCAN_ELEMENT = true
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - States Page Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The states page shows the state resistances of the battlers. The player
    # can compare and contrast the resistances relative to each other.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    STATE_FONT_SIZE   = 20     # Font size used for state resistances.
    HIDDEN_STATE_TEXT = "???"  # Text used if state resistances are hidden.
    SHOWN_STATES = [7..14]     # States shown. Maximum of 8 can be shown.
    
    # Show the state resistances by default? If false, a skill with the
    # specific state must be used on the enemy to reveal the element data if
    # the AUTO_SCAN_STATES setting is set to true.
    DEFAULT_SHOW_STATES = false
    
    # If this is set to true, then skills with state applying properties will
    # automatically scan the specific state resistance of that enemy type
    # when used against that enemy.
    AUTO_SCAN_STATES = true
    
  end # ENEMY_INFO
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

if $imported["YEA-BattleEngine"]

module YEA
  module ENEMY_INFO
    module_function
    #--------------------------------------------------------------------------
    # convert_integer_array
    #--------------------------------------------------------------------------
    def convert_integer_array(array)
      result = []
      array.each { |i|
        case i
        when Range; result |= i.to_a
        when Integer; result |= [i]
        end }
      return result
    end
    #--------------------------------------------------------------------------
    # converted_contants
    #--------------------------------------------------------------------------
    SHOWN_ELEMENTS = convert_integer_array(SHOWN_ELEMENTS)
    SHOWN_STATES = convert_integer_array(SHOWN_STATES)
  end # ENEMY_INFO
  module REGEXP
  module ENEMY
    
    HIDE_INFO = /<(?:HIDE_INFO|hide info):[ ](.*)>/i
    SHOW_INFO = /<(?:SHOW_INFO|show info):[ ](.*)>/i
    
  end # ENEMY
  module USABLEITEM
    
    SCAN_INFO = /<(?:SCAN_INFO|scan info):[ ](.*)>/i
    SCAN_ELE = /<(?:SCAN_ELE|scan ele|scan element):[ ]*(\d+(?:\s*,\s*\d+)*)>/i
    SCAN_STATE = /<(?:SCAN_STATE|scan state):[ ]*(\d+(?:\s*,\s*\d+)*)>/i
    
  end # USABLEITEM
  end # REGEXP
end # YEA

#==============================================================================
# ■ Icon
#==============================================================================

module Icon
  
  #--------------------------------------------------------------------------
  # self.element
  #--------------------------------------------------------------------------
  def self.element(id)
    return 0 unless YEA::ENEMY_INFO::ELEMENT_ICONS.include?(id)
    return YEA::ENEMY_INFO::ELEMENT_ICONS[id]
  end
    
end # Icon

#==============================================================================
# ■ Numeric
#==============================================================================

class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric

#==============================================================================
# ■ DataManager
#==============================================================================

module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_etin load_database; end
  def self.load_database
    load_database_etin
    load_notetags_etin
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_etin
  #--------------------------------------------------------------------------
  def self.load_notetags_etin
    groups = [$data_enemies, $data_skills, $data_items]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_etin
      end
    end
  end
  
end # DataManager

#==============================================================================
# ■ RPG::Enemy
#==============================================================================

class RPG::Enemy < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :hide_info
  attr_accessor :show_info
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_etin
  #--------------------------------------------------------------------------
  def load_notetags_etin
    @hide_info = []
    @show_info = []
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::ENEMY::HIDE_INFO
        case $1.upcase
        when "PARAM", "PARAMETER", "PARAMETERS"
          @hide_info.push(:param)
          @show_info.delete(:param)
        when "ELE", "ELEMENT", "ELEMENTS"
          @hide_info.push(:ele)
          @show_info.delete(:ele)
        when "STATE", "STATES"
          @hide_info.push(:state)
          @show_info.delete(:state)
        when "ALL"
          @hide_info.push(:all)
          @show_info.delete(:all)
        end
      #---
      when YEA::REGEXP::ENEMY::SHOW_INFO
        case $1.upcase
        when "PARAM", "PARAMETER", "PARAMETERS"
          @show_info.push(:param)
          @hide_info.delete(:param)
        when "ELE", "ELEMENT", "ELEMENTS"
          @show_info.push(:ele)
          @hide_info.delete(:ele)
        when "STATE", "STATES"
          @show_info.push(:state)
          @hide_info.delete(:state)
        when "ALL"
          @show_info.push(:all)
          @hide_info.delete(:all)
        end
      #---
      end
    } # self.note.split
    #---
  end
  
end # RPG::Enemy

#==============================================================================
# ■ RPG::UsableItem
#==============================================================================

class RPG::UsableItem < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :scan_info
  attr_accessor :scan_ele
  attr_accessor :scan_state
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_etin
  #--------------------------------------------------------------------------
  def load_notetags_etin
    @scan_info = []
    @scan_ele = []
    @scan_state = []
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::USABLEITEM::SCAN_INFO
        case $1.upcase
        when "PARAM", "PARAMETER", "PARAMETERS"
          @scan_info.push(:param)
        when "ELE", "ELEMENT", "ELEMENTS"
          @scan_info.push(:ele)
        when "STATE", "STATES"
          @scan_info.push(:state)
        when "ALL"
          @scan_info.push(:all)
        end
      #---
      when YEA::REGEXP::USABLEITEM::SCAN_ELE
        $1.scan(/\d+/).each { |num| 
        @scan_ele.push(num.to_i) if num.to_i > 0 }
      when YEA::REGEXP::USABLEITEM::SCAN_STATE
        $1.scan(/\d+/).each { |num| 
        @scan_state.push(num.to_i) if num.to_i > 0 }
      #---
      end
    } # self.note.split
    #---
    @scan_ele.push(self.damage.element_id) if YEA::ENEMY_INFO::AUTO_SCAN_ELEMENT
    if YEA::ENEMY_INFO::AUTO_SCAN_STATES
      for effect in @effects
        next unless effect.code == 21
        next unless effect.data_id > 0
        @scan_state.push(effect.data_id)
      end
    end
  end
  
end # RPG::UsableItem

#==============================================================================
# ■ Game_System
#==============================================================================

class Game_System
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias game_system_initialize_eti initialize
  def initialize
    game_system_initialize_eti
    initialize_enemy_info_data
  end
  
  #--------------------------------------------------------------------------
  # new method: initialize_enemy_info_data
  #--------------------------------------------------------------------------
  def initialize_enemy_info_data
    @param_enemies = [] if @param_enemies.nil?
    @ele_enemies = {} if @ele_enemies.nil?
    @state_enemies = {} if @state_enemies.nil?
  end
  
  #--------------------------------------------------------------------------
  # new method: info_param_enemies
  #--------------------------------------------------------------------------
  def info_param_enemies
    initialize_enemy_info_data if @param_enemies.nil?
    return @param_enemies
  end
  
  #--------------------------------------------------------------------------
  # new method: add_info_param_enemies
  #--------------------------------------------------------------------------
  def add_info_param_enemies(id)
    initialize_enemy_info_data if @param_enemies.nil?
    @param_enemies.push(id) unless @param_enemies.include?(id)
  end
  
  #--------------------------------------------------------------------------
  # new method: info_ele_enemies
  #--------------------------------------------------------------------------
  def info_ele_enemies(ele_id)
    initialize_enemy_info_data if @ele_enemies.nil?
    @ele_enemies[ele_id] = [] if @ele_enemies[ele_id].nil?
    return @ele_enemies[ele_id]
  end
  
  #--------------------------------------------------------------------------
  # new method: add_info_ele_enemies
  #--------------------------------------------------------------------------
  def add_info_ele_enemies(ele_id, id)
    initialize_enemy_info_data if @ele_enemies.nil?
    @ele_enemies[ele_id] = [] if @ele_enemies[ele_id].nil?
    @ele_enemies[ele_id].push(id) unless @ele_enemies[ele_id].include?(id)
  end
  
  #--------------------------------------------------------------------------
  # new method: info_state_enemies
  #--------------------------------------------------------------------------
  def info_state_enemies(state_id)
    initialize_enemy_info_data if @state_enemies.nil?
    @state_enemies[state_id] = [] if @state_enemies[state_id].nil?
    return @state_enemies[state_id]
  end
  
  #--------------------------------------------------------------------------
  # new method: add_info_state_enemies
  #--------------------------------------------------------------------------
  def add_info_state_enemies(state_id, id)
    initialize_enemy_info_data if @state_enemies.nil?
    @state_enemies[state_id] = [] if @state_enemies[state_id].nil?
    @state_enemies[state_id].push(id) if !@state_enemies[state_id].include?(id)
  end
  
end # Game_System

#==============================================================================
# ■ Game_BattlerBase
#==============================================================================

class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # new method: show_info_param?
  #--------------------------------------------------------------------------
  def show_info_param?
    return true if YEA::ENEMY_INFO::SHOW_DEBUG_ALL && ($TEST || $BTEST)
    return YEA::ENEMY_INFO::DEFAULT_SHOW_PARAMS
  end
  
  #--------------------------------------------------------------------------
  # new method: show_info_element?
  #--------------------------------------------------------------------------
  def show_info_element?(ele_id)
    return true if YEA::ENEMY_INFO::SHOW_DEBUG_ALL && ($TEST || $BTEST)
    return YEA::ENEMY_INFO::DEFAULT_SHOW_ELEMENTS
  end
  
  #--------------------------------------------------------------------------
  # new method: show_info_state?
  #--------------------------------------------------------------------------
  def show_info_state?(state_id)
    return true if YEA::ENEMY_INFO::SHOW_DEBUG_ALL && ($TEST || $BTEST)
    return YEA::ENEMY_INFO::DEFAULT_SHOW_STATES
  end
  
end # Game_BattlerBase

#==============================================================================
# ■ Game_Battler
#==============================================================================

class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: die
  #--------------------------------------------------------------------------
  alias game_battler_die_eti die
  def die
    game_battler_die_eti
    return if actor?
    $game_system.add_info_param_enemies(@enemy_id)
  end
  
  #--------------------------------------------------------------------------
  # alias method: item_user_effect
  #--------------------------------------------------------------------------
  alias game_battler_item_user_effect_eti item_user_effect
  def item_user_effect(user, item)
    game_battler_item_user_effect_eti(user, item)
    scan_enemy_info_effect(user, item)
  end
  
  #--------------------------------------------------------------------------
  # new method: scan_enemy_info_effect
  #--------------------------------------------------------------------------
  def scan_enemy_info_effect(user, item)
    return if self.actor?
    return unless user.actor?
    #---
    for info in item.scan_info
      case info
      when :all
        $game_system.add_info_param_enemies(@enemy_id)
        for i in 0...$data_system.elements.size
          $game_system.add_info_ele_enemies(i, @enemy_id)
        end
        for i in 0...$data_states.size
          $game_system.add_info_state_enemies(i, @enemy_id)
        end
      when :param
        $game_system.add_info_param_enemies(@enemy_id)
      when :ele
        for i in 0...$data_system.elements.size
          $game_system.add_info_ele_enemies(i, @enemy_id)
        end
      when :state
        for i in 0...$data_states.size
          $game_system.add_info_state_enemies(i, @enemy_id)
        end
      end
    end
    #---
    for ele_id in item.scan_ele
      $game_system.add_info_ele_enemies(ele_id, @enemy_id)
    end
    for state_id in item.scan_state
      $game_system.add_info_state_enemies(state_id, @enemy_id)
    end
  end
  
end # Game_Battler

#==============================================================================
# ■ Game_Actor
#==============================================================================

class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # new method: show_info_param?
  #--------------------------------------------------------------------------
  def show_info_param?
    return true
  end
  
  #--------------------------------------------------------------------------
  # new method: show_info_element?
  #--------------------------------------------------------------------------
  def show_info_element?(ele_id)
    return true
  end
  
  #--------------------------------------------------------------------------
  # new method: show_info_state?
  #--------------------------------------------------------------------------
  def show_info_state?(state_id)
    return true
  end
  
end # Game_Actor

#==============================================================================
# ■ Game_Enemy
#==============================================================================

class Game_Enemy < Game_Battler
  
  #--------------------------------------------------------------------------
  # new method: show_info_param?
  #--------------------------------------------------------------------------
  def show_info_param?
    return false if enemy.hide_info.include?(:param)
    return false if enemy.hide_info.include?(:all)
    return true if enemy.show_info.include?(:param)
    return true if enemy.show_info.include?(:all)
    return true if $game_system.info_param_enemies.include?(@enemy_id)
    return super
  end
  
  #--------------------------------------------------------------------------
  # new method: show_info_element?
  #--------------------------------------------------------------------------
  def show_info_element?(ele_id)
    return false if enemy.hide_info.include?(:ele)
    return false if enemy.hide_info.include?(:all)
    return true if enemy.show_info.include?(:ele)
    return true if enemy.show_info.include?(:all)
    return true if $game_system.info_ele_enemies(ele_id).include?(@enemy_id)
    return super(ele_id)
  end
  
  #--------------------------------------------------------------------------
  # new method: show_info_state?
  #--------------------------------------------------------------------------
  def show_info_state?(state_id)
    return false if enemy.hide_info.include?(:state)
    return false if enemy.hide_info.include?(:all)
    return true if enemy.show_info.include?(:state)
    return true if enemy.show_info.include?(:all)
    return true if $game_system.info_state_enemies(state_id).include?(@enemy_id)
    return super(state_id)
  end
  
end # Game_Enemy

#==============================================================================
# ■ Window_Comparison
#==============================================================================

class Window_Comparison < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(type)
    dx = type == :actor ? 0 : Graphics.width / 2
    dh = fitting_height(4)
    super(dx, Graphics.height - dh, Graphics.width / 2, dh)
    @button = YEA::ENEMY_INFO::INFO_BUTTON
    @battler = nil
    @type = type
    @page = 0
    hide
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return unless @type == :enemy
    process_enemy_window_input
    return unless self.visible
    reveal(SceneManager.scene.enemy_window.enemy)
  end
  
  #--------------------------------------------------------------------------
  # process_enemy_window_input
  #--------------------------------------------------------------------------
  def process_enemy_window_input
    return unless SceneManager.scene_is?(Scene_Battle)
    return unless SceneManager.scene.enemy_window.active
    return if SceneManager.scene.enemy_window.select_all?
    SceneManager.scene.toggle_enemy_info if Input.trigger?(@button)
    return unless self.visible
    SceneManager.scene.enemy_info_page_up if Input.trigger?(:L)
    SceneManager.scene.enemy_info_page_down if Input.trigger?(:R)
  end
  
  #--------------------------------------------------------------------------
  # reveal
  #--------------------------------------------------------------------------
  def reveal(battler)
    return if @battler == battler
    @battler = battler
    refresh
    show
  end
  
  #--------------------------------------------------------------------------
  # clear
  #--------------------------------------------------------------------------
  def clear
    @battler = nil
    @page = 0
    hide
  end
  
  #--------------------------------------------------------------------------
  # actor
  #--------------------------------------------------------------------------
  def actor; return BattleManager.actor; end
  
  #--------------------------------------------------------------------------
  # enemy
  #--------------------------------------------------------------------------
  def enemy; return SceneManager.scene.enemy_window.enemy; end
  
  #--------------------------------------------------------------------------
  # page_up
  #--------------------------------------------------------------------------
  def page_up
    @page = @page == 0 ? YEA::ENEMY_INFO::PAGE_ORDER.size - 1 : @page - 1
    refresh
  end
  
  #--------------------------------------------------------------------------
  # page_down
  #--------------------------------------------------------------------------
  def page_down
    @page = @page == YEA::ENEMY_INFO::PAGE_ORDER.size - 1 ? 0 : @page + 1
    refresh
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    draw_page(@page)
  end
  
  #--------------------------------------------------------------------------
  # draw_page
  #--------------------------------------------------------------------------
  def draw_page(page_id)
    return if @battler.nil?
    case YEA::ENEMY_INFO::PAGE_ORDER[page_id]
    when :parameters
      @battler = actor if @type == :actor
      draw_parameters
    when :elements
      @battler = enemy if @type == :actor
      draw_parameters if @type == :actor
      draw_elements if @type == :enemy
    when :states
      @battler = enemy if @type == :actor
      draw_parameters if @type == :actor
      draw_states if @type == :enemy
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_parameters
  #--------------------------------------------------------------------------
  def draw_parameters
    draw_text(4, 0, contents.width, line_height, @battler.name)
    dx = contents.width / 2
    contents.font.size = YEA::ENEMY_INFO::PARAM_FONT_SIZE
    draw_param(2, 0, line_height*1); draw_param(3, dx, line_height*1)
    draw_param(4, 0, line_height*2); draw_param(5, dx, line_height*2)
    draw_param(6, 0, line_height*3); draw_param(7, dx, line_height*3)
  end
  
  #--------------------------------------------------------------------------
  # draw_param
  #--------------------------------------------------------------------------
  def draw_param(param_id, dx, dy)
    dw = contents.width / 2
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw - 2, line_height - 2)
    contents.fill_rect(rect, colour)
    #---
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::param(param_id))
    change_color(normal_color)
    if @battler.show_info_param?
      text = @battler.param(param_id).group
    else
      text = YEA::ENEMY_INFO::HIDDEN_PARAM_TEXT
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_elements
  #--------------------------------------------------------------------------
  def draw_elements
    dx = 0; dy = 0
    contents.font.size = YEA::ENEMY_INFO::ELE_FONT_SIZE
    for ele_id in YEA::ENEMY_INFO::SHOWN_ELEMENTS
      draw_element_info(ele_id, dx, dy)
      dx = dx == 0 ? contents.width / 2 : 0
      dy += dx == 0 ? line_height : 0
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_element_info
  #--------------------------------------------------------------------------
  def draw_element_info(ele_id, dx, dy)
    dw = contents.width / 2
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw - 2, line_height - 2)
    contents.fill_rect(rect, colour)
    #---
    draw_icon(Icon.element(ele_id), dx, dy)
    change_color(system_color)
    draw_text(dx+24, dy, dw-24, line_height, $data_system.elements[ele_id])
    change_color(normal_color)
    if @battler.show_info_element?(ele_id)
      text = sprintf("%d%%", (@battler.element_rate(ele_id) * 100).to_i)
    else
      text = YEA::ENEMY_INFO::HIDDEN_ELE_TEXT
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_states
  #--------------------------------------------------------------------------
  def draw_states
    dx = 0; dy = 0
    contents.font.size = YEA::ENEMY_INFO::ELE_FONT_SIZE
    for state_id in YEA::ENEMY_INFO::SHOWN_STATES
      draw_state_info(state_id, dx, dy)
      dx = dx == 0 ? contents.width / 2 : 0
      dy += dx == 0 ? line_height : 0
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_state_info
  #--------------------------------------------------------------------------
  def draw_state_info(state_id, dx, dy)
    dw = contents.width / 2
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw - 2, line_height - 2)
    contents.fill_rect(rect, colour)
    #---
    draw_icon($data_states[state_id].icon_index, dx, dy)
    change_color(system_color)
    draw_text(dx+24, dy, dw-24, line_height, $data_states[state_id].name)
    change_color(normal_color)
    if @battler.show_info_state?(state_id)
      text = sprintf("%d%%", (@battler.state_rate(state_id) * 100).to_i)
    else
      text = YEA::ENEMY_INFO::HIDDEN_STATE_TEXT
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
end # Window_Comparison

#==============================================================================
# ■ Window_ComparisonHelp
#==============================================================================

class Window_ComparisonHelp < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(info_window)
    dy = YEA::ENEMY_INFO::HELP_WINDOW_Y
    super(-12, dy, Graphics.width + 24, fitting_height(1))
    @info_window = info_window
    self.opacity = 0
    self.z = 300
    @text = ""
    hide
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return unless YEA::ENEMY_INFO::SHOW_HELP_INFO
    update_visibility
    update_text
  end
  
  #--------------------------------------------------------------------------
  # update_visibility
  #--------------------------------------------------------------------------
  def update_visibility
    return unless SceneManager.scene_is?(Scene_Battle)
    return if SceneManager.scene.enemy_window.select_all?
    self.visible = SceneManager.scene.enemy_window.active
  end
  
  #--------------------------------------------------------------------------
  # update_text
  #--------------------------------------------------------------------------
  def update_text
    return unless self.visible
    if @info_window.visible
      text = YEA::ENEMY_INFO::HELP_INFO_SWITCH
    else
      text = YEA::ENEMY_INFO::HELP_INFO_SHOW
    end
    return if @text == text
    @text = text
    refresh
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    draw_background
    draw_text_ex(4, 0, @text)
  end
  
  #--------------------------------------------------------------------------
  # draw_background
  #--------------------------------------------------------------------------
  def draw_background
    temp_rect = Rect.new(0, 0, contents.width / 2, contents.height)
    colour1 = Color.new(0, 0, 0, 192)
    colour2 = Color.new(0, 0, 0, 0)
    contents.gradient_fill_rect(temp_rect, colour1, colour2)
  end
  
end # Window_ComparisonHelp

#==============================================================================
# ■ Scene_Battle
#==============================================================================

class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: create_all_windows
  #--------------------------------------------------------------------------
  alias scene_battle_create_all_windows_eti create_all_windows
  def create_all_windows
    scene_battle_create_all_windows_eti
    create_comparison_windows
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_comparison_windows
  #--------------------------------------------------------------------------
  def create_comparison_windows
    @actor_info_window = Window_Comparison.new(:actor)
    @enemy_info_window = Window_Comparison.new(:enemy)
    @info_help_window = Window_ComparisonHelp.new(@enemy_info_window)
  end
  
  #--------------------------------------------------------------------------
  # new method: toggle_enemy_info
  #--------------------------------------------------------------------------
  def toggle_enemy_info
    YEA::ENEMY_INFO::INFO_SFX.play
    if @enemy_info_window.visible
      hide_comparison_windows
    else
      show_comparison_windows
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: enemy_info_page_up
  #--------------------------------------------------------------------------
  def enemy_info_page_up
    YEA::ENEMY_INFO::INFO_SFX.play
    @actor_info_window.page_up
    @enemy_info_window.page_up
  end
  
  #--------------------------------------------------------------------------
  # new method: enemy_info_page_down
  #--------------------------------------------------------------------------
  def enemy_info_page_down
    YEA::ENEMY_INFO::INFO_SFX.play
    @actor_info_window.page_down
    @enemy_info_window.page_down
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_enemy_ok
  #--------------------------------------------------------------------------
  alias scene_battle_on_enemy_ok_eti on_enemy_ok
  def on_enemy_ok
    hide_comparison_windows
    scene_battle_on_enemy_ok_eti
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_enemy_cancel
  #--------------------------------------------------------------------------
  alias scene_battle_on_enemy_cancel_eti on_enemy_cancel
  def on_enemy_cancel
    hide_comparison_windows
    scene_battle_on_enemy_cancel_eti
  end
  
  #--------------------------------------------------------------------------
  # new method: show_comparison_windows
  #--------------------------------------------------------------------------
  def show_comparison_windows
    @actor_info_window.reveal(BattleManager.actor)
    @enemy_info_window.reveal(@enemy_window.enemy)
    @info_viewport.visible = false
    @skill_window.y = Graphics.height * 2
    @item_window.y = Graphics.height * 2
    @status_aid_window.y = Graphics.height * 2
  end
  
  #--------------------------------------------------------------------------
  # new method: hide_comparison_windows
  #--------------------------------------------------------------------------
  def hide_comparison_windows
    @actor_info_window.clear
    @enemy_info_window.clear
    @info_viewport.visible = true
    @skill_window.y = Graphics.height - @skill_window.height
    @item_window.y = Graphics.height - @item_window.height
    @status_aid_window.y = Graphics.height - @status_aid_window.height
  end
  
end # Scene_Battle

end # $imported["YEA-BattleEngine"]

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================





#==============================================================================
# 
# �� Yanfly Engine Ace - Victory Aftermath v1.04
# -- Last Updated: 2014.03.019
# -- Level: Easy, Normal, Hard
# -- Requires: n/a
# -- Special Thanks: Yami for Bug Fixes.
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-VictoryAftermath"] = true

#==============================================================================
# �� Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2014.03.19 - Fixed a bug where if the battle ends with a stat buff/debuff and
#              it will display the wrong parameters.
# 2012.01.07 - Compatibility Update: JP Manager
# 2012.01.01 - Bug Fixed: Quote tags were mislabeled.
# 2011.12.26 - Compatibility Update: Command Autobattle
# 2011.12.16 - Started Script and Finished.
# 
#==============================================================================
# �� Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# At the end of each battle, RPG Maker VX Ace by default shows text saying that
# the party has gained so-and-so EXP while this person leveled up and your
# party happened to find these drops. This script changes that text into
# something more visual for your players to see. Active battle members will be
# seen gaining EXP, any kind of level up changes, and a list of the items
# obtained through drops.
# 
#==============================================================================
# �� Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below �� Materials/�f�� but above �� Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Actor Notetags - These notetags go in the actors notebox in the database.
# -----------------------------------------------------------------------------
# <win quotes>
#  string
#  string
# </win quotes>
# Sets the win quote for the actor. The strings are continuous and can use
# text codes. Use \n for a line break. Type in what you want the actor to say
# for the particular win quote. Use [New Quote] in between the two tags to
# start up a new quote.
# 
# <level quotes>
#  string
#  string
# </level quotes>
# Sets the level up quote for the actor. The strings are continuous and can use
# text codes. Use \n for a line break. Type in what you want the actor to say
# for the particular win quote. Use [New Quote] in between the two tags to
# start up a new quote.
# 
# <drops quotes>
#  string
#  string
# </drops quotes>
# Sets the drops quote for the actor. The strings are continuous and can use
# text codes. Use \n for a line break. Type in what you want the actor to say
# for the particular win quote. Use [New Quote] in between the two tags to
# start up a new quote.
# 
# -----------------------------------------------------------------------------
# Class Notetags - These notetags go in the class notebox in the database.
# -----------------------------------------------------------------------------
# <win quotes>
#  string
#  string
# </win quotes>
# Sets the win quote for the class. The strings are continuous and can use
# text codes. Use \n for a line break. Type in what you want the actor to say
# for the particular win quote. Use [New Quote] in between the two tags to
# start up a new quote.
# 
# <level quotes>
#  string
#  string
# </level quotes>
# Sets the level up quote for the class. The strings are continuous and can use
# text codes. Use \n for a line break. Type in what you want the actor to say
# for the particular win quote. Use [New Quote] in between the two tags to
# start up a new quote.
# 
# <drops quotes>
#  string
#  string
# </drops quotes>
# Sets the drops quote for the class. The strings are continuous and can use
# text codes. Use \n for a line break. Type in what you want the actor to say
# for the particular win quote. Use [New Quote] in between the two tags to
# start up a new quote.
# 
#==============================================================================
# �� Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module VICTORY_AFTERMATH
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These are various settings that are used throughout the Victory Aftermath
    # portion of a battle. Adjust them as you see fit.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    VICTORY_BGM  = RPG::BGM.new("Field1", 100, 100)    # Victory BGM
    VICTORY_TICK = RPG::SE.new("Decision1", 100, 150)  # EXP ticking SFX
    LEVEL_SOUND  = RPG::SE.new("Up4", 80, 150)         # Level Up SFX
    SKILLS_TEXT  = "New Skills"                        # New skills text title.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Important Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These are some important settings so please set them up properly. This
    # section includes a switch that allows you to skip the victory aftermath
    # phase (for those back to back battles and making them seamless) and it
    # also allows you to declare a common event to run after each battle. If
    # you do not wish to use either of these features, set them to 0. The
    # common event will run regardless of win or escape.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    SKIP_AFTERMATH_SWITCH  = 0  # If switch on, skip aftermath. 0 to disable.
    SKIP_MUSIC_SWITCH      = 0  # If switch on, skip music. 0 to disable.
    AFTERMATH_COMMON_EVENT = 0  # Runs common event after battle. 0 to disable.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Top Text Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Here, you can adjust the various text that appears in the window that
    # appears at the top of the screen.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    TOP_TEAM         = "%s's Cuntrades"           # Team name used.
    TOP_VICTORY_TEXT = "%s fucking won!"   # Text used to display victory.
    TOP_LEVEL_UP     = "%s got more retarded!"  # Text used to display level up.
    TOP_SPOILS       = "Victory Shit!"     # Text used for spoils.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - EXP Gauge Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Adjust how the EXP Gauge appears for the Victory Aftermath here. This
    # includes the text display, the font size, the colour of the gauges, and
    # more. Adjust it all here.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    VICTORY_EXP  = "+%sEXP"      # Text used to display EXP.
    EXP_PERCENT  = "%1.2f%%"     # The way EXP percentage will be displayed.
    LEVELUP_TEXT = "LEVEL UP!"   # Text to replace percentage when leveled.
    MAX_LVL_TEXT = "MAX LEVEL"   # Text to replace percentage when max level.
    FONTSIZE_EXP = 20            # Font size used for EXP.
    EXP_TICKS    = 15            # Ticks to full EXP
    EXP_GAUGE1   = 12            # "Window" skin text colour for gauge.
    EXP_GAUGE2   = 4             # "Window" skin text colour for gauge.
    LEVEL_GAUGE1 = 13            # "Window" skin text colour for leveling.
    LEVEL_GAUGE2 = 5             # "Window" skin text colour for leveling.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Victory Messages -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # In the Victory Aftermath, actors can say unique things. This is the pool
    # of quotes used for actors without any custom victory quotes. Note that
    # actors with custom quotes will take priority over classes with custom
    # quotes, which will take priority over these default quotes. Use \n for
    # a line break in the quotes.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    HEADER_TEXT = "\e>\eC[6]%s\eC[0]\e<\n"  # Always at start of messages.
    FOOTER_TEXT = ""                        # Always at end of messages.
    
    # Win Quotes are what the actors say when a battle is won.
    VICTORY_QUOTES ={
    # :type   => Quotes
      #------------------------------------------------------------------------
      :win    => [ # Occurs as initial victory quote.
                   '"We won! What an exciting fight!"',
                   '"I didn\'t even break a sweat."',
                   '"That wasn\'t so tough."',
                   '"Let\'s fight something harder!"',
                 ],# Do not remove this.
      #------------------------------------------------------------------------
      :level  => [ # Occurs as initial victory quote.
                   '"Yes! Level up!"',
                   '"I\'ve gotten stronger!"',
                   '"Try to keep up with me!"',
                   '"I\'ve grown again!"',
                 ],# Do not remove this.
      #------------------------------------------------------------------------
      :drops  => [ # Occurs as initial victory quote.
                   '"I\'ll be taking these."',
                   '"To the victor goes the spoils."',
                   '"The enemies dropped something!"',
                   '"Hey, what\'s this?"',
                 ],# Do not remove this.
      #------------------------------------------------------------------------
    } # Do not remove this.
    
  end # VICTORY_AFTERMATH
end # YEA

#==============================================================================
# �� Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

module YEA
  module REGEXP
  module BASEITEM
    
    NEW_QUOTE = /\[(?:NEW_QUOTE|new quote)\]/i
    
    WIN_QUOTE_ON    = /<(?:WIN_QUOTES|win quote|win quotes)>/i
    WIN_QUOTE_OFF   = /<\/(?:WIN_QUOTES|win quote|win quotes)>/i
    LEVEL_QUOTE_ON  = /<(?:LEVEL_QUOTES|level quote|level quotes)>/i
    LEVEL_QUOTE_OFF = /<\/(?:LEVEL_QUOTES|level quote|level quotes)>/i
    DROPS_QUOTE_ON  = /<(?:DROPS_QUOTES|drops quote|drops quotes)>/i
    DROPS_QUOTE_OFF = /<\/(?:DROPS_QUOTES|drops quote|drops quotes)>/i
    
  end # BASEITEM
  end # REGEXP
end # YEA

#==============================================================================
# �� Switch
#==============================================================================

module Switch
  
  #--------------------------------------------------------------------------
  # self.skip_aftermath
  #--------------------------------------------------------------------------
  def self.skip_aftermath
    return false if YEA::VICTORY_AFTERMATH::SKIP_AFTERMATH_SWITCH <= 0
    return $game_switches[YEA::VICTORY_AFTERMATH::SKIP_AFTERMATH_SWITCH]
  end
  
  #--------------------------------------------------------------------------
  # self.skip_aftermath_music
  #--------------------------------------------------------------------------
  def self.skip_aftermath_music
    return false if YEA::VICTORY_AFTERMATH::SKIP_MUSIC_SWITCH <=0
    return $game_switches[YEA::VICTORY_AFTERMATH::SKIP_MUSIC_SWITCH]
  end
    
end # Switch

#==============================================================================
# �� Numeric
#==============================================================================

class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric

#==============================================================================
# �� DataManager
#==============================================================================

module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_va load_database; end
  def self.load_database
    load_database_va
    load_notetags_va
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_va
  #--------------------------------------------------------------------------
  def self.load_notetags_va
    groups = [$data_actors, $data_classes]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_va
      end
    end
  end
  
end # DataManager

#==============================================================================
# �� RPG::BaseItem
#==============================================================================

class RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :win_quotes
  attr_accessor :level_quotes
  attr_accessor :drops_quotes
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_va
  #--------------------------------------------------------------------------
  def load_notetags_va
    @win_quotes = ["too fucking easy"]
    @level_quotes = ["i feel dumber"]
    @drops_quotes = ["free shit, i like it"]
    @victory_quote_type = nil
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::BASEITEM::WIN_QUOTE_ON
        @victory_quote_type = :win_quote
      when YEA::REGEXP::BASEITEM::WIN_QUOTE_OFF
        @victory_quote_type = nil
      when YEA::REGEXP::BASEITEM::LEVEL_QUOTE_ON
        @victory_quote_type = :level_quote
      when YEA::REGEXP::BASEITEM::LEVEL_QUOTE_OFF
        @victory_quote_type = nil
      when YEA::REGEXP::BASEITEM::DROPS_QUOTE_ON
        @victory_quote_type = :drops_quote
      when YEA::REGEXP::BASEITEM::DROPS_QUOTE_OFF
        @victory_quote_type = nil
      #---
      when YEA::REGEXP::BASEITEM::NEW_QUOTE
        case @victory_quote_type
        when nil; next
        when :win_quote;   @win_quotes.push("")
        when :level_quote; @level_quotes.push("")
        when :drops_quote; @drops_quotes.push("")
        end
      #---
      else
        case @victory_quote_type
        when nil; next
        when :win_quote;   @win_quotes[@win_quotes.size-1] += line.to_s
        when :level_quote; @level_quotes[@level_quotes.size-1] += line.to_s
        when :drops_quote; @drops_quotes[@drops_quotes.size-1] += line.to_s
        end
      end
    } # self.note.split
    #---
    return unless self.is_a?(RPG::Class)
    quotes = YEA::VICTORY_AFTERMATH::VICTORY_QUOTES
    @win_quotes = quotes[:win].clone if @win_quotes == [""]
    @level_quotes = quotes[:level].clone if @level_quotes == [""]
    @drops_quotes = quotes[:drops].clone if @drops_quotes == [""]
  end
  
end # RPG::BaseItem

#==============================================================================
# �� BattleManager
#==============================================================================

module BattleManager
  
  #--------------------------------------------------------------------------
  # overwrite method: self.process_victory
  #--------------------------------------------------------------------------
  def self.process_victory
    if $imported["YEA-CommandAutobattle"]
      SceneManager.scene.close_disable_autobattle_window
    end
    return skip_aftermath if Switch.skip_aftermath
    play_battle_end_me
    gain_jp if $imported["YEA-JPManager"]
    display_exp
    gain_exp
    gain_gold
    gain_drop_items
    close_windows
    SceneManager.return
    replay_bgm_and_bgs
    battle_end(0)
    return true
  end
  
  #--------------------------------------------------------------------------
  # new method: self.skip_aftermath
  #--------------------------------------------------------------------------
  def self.skip_aftermath
    $game_party.all_members.each do |actor|
      actor.gain_exp($game_troop.exp_total)
    end
    $game_party.gain_gold($game_troop.gold_total)
    $game_troop.make_drop_items.each do |item|
      $game_party.gain_item(item, 1)
    end
    close_windows
    SceneManager.return
    replay_bgm_and_bgs
    battle_end(0)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: self.play_battle_end_me
  #--------------------------------------------------------------------------
  def self.play_battle_end_me
    return if Switch.skip_aftermath_music
    $game_system.battle_end_me.play
    YEA::VICTORY_AFTERMATH::VICTORY_BGM.play
  end
  
  #--------------------------------------------------------------------------
  # new method: self.set_victory_text
  #--------------------------------------------------------------------------
  def self.set_victory_text(actor, type)
    text = "" + sprintf(YEA::VICTORY_AFTERMATH::HEADER_TEXT, actor.name)
    text += actor.victory_quotes(type)[rand(actor.victory_quotes(type).size)]
    text += YEA::VICTORY_AFTERMATH::FOOTER_TEXT
    $game_message.face_name = actor.face_name
    $game_message.face_index = actor.face_index
    $game_message.add(text)
    wait_for_message
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: self.display_exp
  #--------------------------------------------------------------------------
  def self.display_exp
    SceneManager.scene.show_victory_display_exp
    actor = $game_party.random_target
    @victory_actor = actor
    set_victory_text(@victory_actor, :win)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: self.gain_exp
  #--------------------------------------------------------------------------
  def self.gain_exp
    $game_party.all_members.each do |actor|
      temp_actor = Marshal.load(Marshal.dump(actor))
      actor.gain_exp($game_troop.exp_total)
      next if actor.level == temp_actor.level
      SceneManager.scene.show_victory_level_up(actor, temp_actor)
      set_victory_text(actor, :level)
      wait_for_message
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: self.gain_gold
  #--------------------------------------------------------------------------
  def self.gain_gold
    $game_party.gain_gold($game_troop.gold_total)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: self.gain_drop_items
  #--------------------------------------------------------------------------
  def self.gain_drop_items
    drops = []
    $game_troop.make_drop_items.each do |item|
      $game_party.gain_item(item, 1)
      drops.push(item)
    end
    SceneManager.scene.show_victory_spoils($game_troop.gold_total, drops)
    set_victory_text(@victory_actor, :drops)
    wait_for_message
  end
  
  #--------------------------------------------------------------------------
  # new method: self.close_windows
  #--------------------------------------------------------------------------
  def self.close_windows
    SceneManager.scene.close_victory_windows
  end
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias battle_end_va battle_end; end
  def self.battle_end(result)
    battle_end_va(result)
    return if result == 2
    return if YEA::VICTORY_AFTERMATH::AFTERMATH_COMMON_EVENT <= 0
    event_id = YEA::VICTORY_AFTERMATH::AFTERMATH_COMMON_EVENT
    $game_temp.reserve_common_event(event_id)
  end
  
end # BattleManager

#==============================================================================
# �� Game_Actor
#==============================================================================

class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # overwrite method: gain_exp
  #--------------------------------------------------------------------------
  def gain_exp(exp)
    enabled = !SceneManager.scene_is?(Scene_Battle)
    change_exp(self.exp + (exp * final_exp_rate).to_i, enabled)
  end
  
  #--------------------------------------------------------------------------
  # new method: victory_quotes
  #--------------------------------------------------------------------------
  def victory_quotes(type)
    case type
    when :win
      return self.actor.win_quotes if self.actor.win_quotes != [""]
      return self.class.win_quotes
    when :level
      return self.actor.level_quotes if self.actor.level_quotes != [""]
      return self.class.level_quotes
    when :drops
      return self.actor.drops_quotes if self.actor.drops_quotes != [""]
      return self.class.drops_quotes
    else
      return ["NOTEXT"]
    end
  end
  
end # Game_Actor

#==============================================================================
# �� Window_VictoryTitle
#==============================================================================

class Window_VictoryTitle < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, Graphics.width, fitting_height(1))
    self.z = 200
    self.openness = 0
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh(message = "")
    contents.clear
    draw_text(0, 0, contents.width, line_height, message, 1)
  end
  
end # Window_VictoryTitle

#==============================================================================
# �� Window_VictoryEXP_Back
#==============================================================================

class Window_VictoryEXP_Back < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize
    super(0, fitting_height(1), Graphics.width, window_height)
    self.z = 200
    self.openness = 0
  end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height
    return Graphics.height - fitting_height(4) - fitting_height(1)
  end
  
  #--------------------------------------------------------------------------
  # col_max
  #--------------------------------------------------------------------------
  def col_max; return item_max; end
  
  #--------------------------------------------------------------------------
  # spacing
  #--------------------------------------------------------------------------
  def spacing; return 8; end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return $game_party.battle_members.size; end
  
  #--------------------------------------------------------------------------
  # open
  #--------------------------------------------------------------------------
  def open
    @exp_total = $game_troop.exp_total
    super
  end
  
  #--------------------------------------------------------------------------
  # item_rect
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = item_width
    rect.height = contents.height
    rect.x = index % col_max * (item_width + spacing)
    rect.y = index / col_max * item_height
    return rect
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    actor = $game_party.battle_members[index]
    return if actor.nil?
    rect = item_rect(index)
    reset_font_settings
    draw_actor_name(actor, rect)
    draw_exp_gain(actor, rect)
    draw_jp_gain(actor, rect)
    draw_actor_face(actor, rect)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_name
  #--------------------------------------------------------------------------
  def draw_actor_name(actor, rect)
    name = actor.name
    draw_text(rect.x, rect.y+line_height, rect.width, line_height, name, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_face
  #--------------------------------------------------------------------------
  def draw_actor_face(actor, rect)
    face_name = actor.face_name
    face_index = actor.face_index
    bitmap = Cache.face(face_name)
    rw = [rect.width, 96].min
    face_rect = Rect.new(face_index % 4 * 96, face_index / 4 * 96, rw, 96)
    rx = (rect.width - rw) / 2 + rect.x
    contents.blt(rx, rect.y + line_height * 2, bitmap, face_rect, 255)
  end
  
  #--------------------------------------------------------------------------
  # draw_exp_gain
  #--------------------------------------------------------------------------
  def draw_exp_gain(actor, rect)
    dw = rect.width - (rect.width - [rect.width, 96].min) / 2
    dy = rect.y + line_height * 3 + 96
    fmt = YEA::VICTORY_AFTERMATH::VICTORY_EXP
    text = sprintf(fmt, actor_exp_gain(actor).group)
    contents.font.size = YEA::VICTORY_AFTERMATH::FONTSIZE_EXP
    change_color(power_up_color)
    draw_text(rect.x, dy, dw, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # actor_exp_gain
  #--------------------------------------------------------------------------
  def actor_exp_gain(actor)
    n = @exp_total * actor.final_exp_rate
    return n.to_i
  end
  
  #--------------------------------------------------------------------------
  # draw_jp_gain
  #--------------------------------------------------------------------------
  def draw_jp_gain(actor, rect)
    return unless $imported["YEA-JPManager"]
    dw = rect.width - (rect.width - [rect.width, 96].min) / 2
    dy = rect.y + line_height * 4 + 96
    fmt = YEA::JP::VICTORY_AFTERMATH
    text = sprintf(fmt, actor_jp_gain(actor).group, Vocab::jp)
    contents.font.size = YEA::VICTORY_AFTERMATH::FONTSIZE_EXP
    change_color(power_up_color)
    draw_text(rect.x, dy, dw, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # actor_jp_gain
  #--------------------------------------------------------------------------
  def actor_jp_gain(actor)
    n = actor.battle_jp_earned
    if actor.exp + actor_exp_gain(actor) > actor.exp_for_level(actor.level + 1)
      n += YEA::JP::LEVEL_UP unless actor.max_level?
    end
    return n
  end
  
end # Window_VictoryEXP_Back

#==============================================================================
# �� Window_VictoryEXP_Front
#==============================================================================

class Window_VictoryEXP_Front < Window_VictoryEXP_Back
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize
    super
    self.back_opacity = 0
    @ticks = 0
    @counter = 30
    contents.font.size = YEA::VICTORY_AFTERMATH::FONTSIZE_EXP
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    update_tick
  end
  
  #--------------------------------------------------------------------------
  # update_tick
  #--------------------------------------------------------------------------
  def update_tick
    return unless self.openness >= 255
    return unless self.visible
    return if complete_ticks?
    @counter -= 1
    return unless @counter <= 0
    return if @ticks >= YEA::VICTORY_AFTERMATH::EXP_TICKS
    YEA::VICTORY_AFTERMATH::VICTORY_TICK.play
    @counter = 4
    @ticks += 1
    refresh
  end
  
  #--------------------------------------------------------------------------
  # complete_ticks?
  #--------------------------------------------------------------------------
  def complete_ticks?
    for actor in $game_party.battle_members
      total_ticks = YEA::VICTORY_AFTERMATH::EXP_TICKS
      bonus_exp = actor_exp_gain(actor) * @ticks / total_ticks
      now_exp = actor.exp - actor.current_level_exp + bonus_exp
      next_exp = actor.next_level_exp - actor.current_level_exp
      rate = now_exp * 1.0 / next_exp
      return false if rate < 1.0
    end
    return true
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    actor = $game_party.battle_members[index]
    return if actor.nil?
    rect = item_rect(index)
    draw_actor_exp(actor, rect)
  end
  
  #--------------------------------------------------------------------------
  # exp_gauge1
  #--------------------------------------------------------------------------
  def exp_gauge1; return text_color(YEA::VICTORY_AFTERMATH::EXP_GAUGE1); end
  
  #--------------------------------------------------------------------------
  # exp_gauge2
  #--------------------------------------------------------------------------
  def exp_gauge2; return text_color(YEA::VICTORY_AFTERMATH::EXP_GAUGE2); end
  
  #--------------------------------------------------------------------------
  # lvl_gauge1
  #--------------------------------------------------------------------------
  def lvl_gauge1; return text_color(YEA::VICTORY_AFTERMATH::LEVEL_GAUGE1); end
  
  #--------------------------------------------------------------------------
  # lvl_gauge2
  #--------------------------------------------------------------------------
  def lvl_gauge2; return text_color(YEA::VICTORY_AFTERMATH::LEVEL_GAUGE2); end
  
  #--------------------------------------------------------------------------
  # draw_actor_exp
  #--------------------------------------------------------------------------
  def draw_actor_exp(actor, rect)
    if actor.max_level?
      draw_exp_gauge(actor, rect, 1.0)
      return
    end
    total_ticks = YEA::VICTORY_AFTERMATH::EXP_TICKS
    bonus_exp = actor_exp_gain(actor) * @ticks / total_ticks
    now_exp = actor.exp - actor.current_level_exp + bonus_exp
    next_exp = actor.next_level_exp - actor.current_level_exp
    rate = now_exp * 1.0 / next_exp
    draw_exp_gauge(actor, rect, rate)
  end
  
  #--------------------------------------------------------------------------
  # draw_exp_gauge
  #--------------------------------------------------------------------------
  def draw_exp_gauge(actor, rect, rate)
    rate = [[rate, 1.0].min, 0.0].max
    dx = (rect.width - [rect.width, 96].min) / 2 + rect.x
    dy = rect.y + line_height * 2 + 96
    dw = [rect.width, 96].min
    colour1 = rate >= 1.0 ? lvl_gauge1 : exp_gauge1
    colour2 = rate >= 1.0 ? lvl_gauge2 : exp_gauge2
    draw_gauge(dx, dy, dw, rate, colour1, colour2)
    fmt = YEA::VICTORY_AFTERMATH::EXP_PERCENT
    text = sprintf(fmt, [rate * 100, 100.00].min)
    if [rate * 100, 100.00].min == 100.00
      text = YEA::VICTORY_AFTERMATH::LEVELUP_TEXT
      text = YEA::VICTORY_AFTERMATH::MAX_LVL_TEXT if actor.max_level?
    end
    draw_text(dx, dy, dw, line_height, text, 1)
  end
  
end # Window_VictoryEXP_Front

#==============================================================================
# �� Window_VictoryLevelUp
#==============================================================================

class Window_VictoryLevelUp < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize
    super(0, fitting_height(1), Graphics.width, window_height)
    self.z = 200
    hide
  end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height
    return Graphics.height - fitting_height(4) - fitting_height(1)
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh(actor, temp_actor)
    contents.clear
    reset_font_settings
    YEA::VICTORY_AFTERMATH::LEVEL_SOUND.play
    draw_actor_changes(actor, temp_actor)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_changes
  #--------------------------------------------------------------------------
  def draw_actor_changes(actor, temp_actor)
    dx = contents.width / 16
    draw_actor_image(actor, temp_actor, dx)
    draw_param_names(actor, dx)
    draw_former_stats(temp_actor)
    draw_arrows
    draw_newer_stats(actor, temp_actor)
    draw_new_skills(actor, temp_actor)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_image
  #--------------------------------------------------------------------------
  def draw_actor_image(actor, temp_actor, dx)
    draw_text(dx, line_height, 96, line_height, actor.name, 1)
    draw_actor_face(actor, dx, line_height * 2)
    exp = actor.exp - temp_actor.exp
    text = sprintf(YEA::VICTORY_AFTERMATH::VICTORY_EXP, exp.group)
    change_color(power_up_color)
    contents.font.size = YEA::VICTORY_AFTERMATH::FONTSIZE_EXP
    draw_text(0, line_height * 2 + 96, dx + 96, line_height, text, 2)
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # draw_param_names
  #--------------------------------------------------------------------------
  def draw_param_names(actor, dx)
    dx += 108
    change_color(system_color)
    text = Vocab.level
    draw_text(dx, 0, contents.width - dx, line_height, text)
    dy = 0
    for i in 0...8
      dy += line_height
      text = Vocab.param(i)
      draw_text(dx, dy, contents.width - dx, line_height, text)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_former_stats
  #--------------------------------------------------------------------------
  def draw_former_stats(actor)
    dw = contents.width / 2 - 12
    dy = 0
    change_color(normal_color)
    draw_text(0, dy, dw, line_height, actor.level.group, 2)
    for i in 0...8
      dy += line_height
      draw_text(0, dy, dw, line_height, actor.param_base(i).group, 2)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_arrows
  #--------------------------------------------------------------------------
  def draw_arrows
    dx = contents.width / 2 - 12
    dy = 0
    change_color(system_color)
    for i in 0..8
      draw_text(dx, dy, 24, line_height, "��", 1)
      dy += line_height
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_newer_stats
  #--------------------------------------------------------------------------
  def draw_newer_stats(actor, temp_actor)
    dx = contents.width / 2 + 12
    dw = contents.width - dx
    dy = 0
    change_color(param_change_color(actor.level - temp_actor.level))
    draw_text(dx, dy, dw, line_height, actor.level.group, 0)
    for i in 0...8
      dy += line_height
      change_color(param_change_color(actor.param_base(i) - temp_actor.param_base(i)))
      draw_text(dx, dy, dw, line_height, actor.param_base(i).group, 0)
    end
  end
  #--------------------------------------------------------------------------
  # draw_new_skills
  #--------------------------------------------------------------------------
  def draw_new_skills(actor, temp_actor)
    return if temp_actor.skills.size == actor.skills.size
    dw = 172 + 24
    dx = contents.width - dw
    change_color(system_color)
    text = YEA::VICTORY_AFTERMATH::SKILLS_TEXT
    draw_text(dx, 0, dw, line_height, text, 0)
  end
  
end # Window_VictoryLevelUp

#==============================================================================
# �� Window_VictorySkills
#==============================================================================

class Window_VictorySkills < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize
    dy = fitting_height(1) + 24
    dw = 172 + 24 + 24
    dh = Graphics.height - fitting_height(4) - fitting_height(1) - 24
    super(Graphics.width - dw, dy, dw, dh)
    self.opacity = 0
    self.z = 200
    hide
  end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return @data.nil? ? 0 : @data.size; end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh(actor, temp_actor)
    contents.clear
    if actor.skills.size == temp_actor.skills.size
      unselect
      @data = []
      create_contents
      return
    end
    @data = actor.skills - temp_actor.skills
    if @data.size > 8
      select(0)
      activate
    else
      unselect
      deactivate
    end
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def draw_item(index)
    rect = item_rect(index)
    skill = @data[index]
    return if skill.nil?
    rect.width -= 4
    draw_item_name(skill, rect.x, rect.y, true)
  end
  
end # Window_VictorySkills

#==============================================================================
# �� Window_VictorySpoils
#==============================================================================

class Window_VictorySpoils < Window_ItemList
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize
    super(0, fitting_height(1), Graphics.width, window_height)
    self.z = 200
    hide
  end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height
    return Graphics.height - fitting_height(4) - fitting_height(1)
  end
  
  #--------------------------------------------------------------------------
  # spacing
  #--------------------------------------------------------------------------
  def spacing; return 32; end
  
  #--------------------------------------------------------------------------
  # make
  #--------------------------------------------------------------------------
  def make(gold, drops)
    @gold = gold
    @drops = drops
    refresh
    select(0)
    activate
  end
  
  #--------------------------------------------------------------------------
  # make_item_list
  #--------------------------------------------------------------------------
  def make_item_list
    @data = [nil]
    items = {}
    weapons = {}
    armours = {}
    @goods = {}
    for item in @drops
      case item
      when RPG::Item
        items[item] = 0 if items[item].nil?
        items[item] += 1
      when RPG::Weapon
        weapons[item] = 0 if weapons[item].nil?
        weapons[item] += 1
      when RPG::Armor
        armours[item] = 0 if armours[item].nil?
        armours[item] += 1
      end
    end
    items = items.sort { |a,b| a[0].id <=> b[0].id }
    weapons = weapons.sort { |a,b| a[0].id <=> b[0].id }
    armours = armours.sort { |a,b| a[0].id <=> b[0].id }
    for key in items; @goods[key[0]] = key[1]; @data.push(key[0]); end
    for key in weapons; @goods[key[0]] = key[1]; @data.push(key[0]); end
    for key in armours; @goods[key[0]] = key[1]; @data.push(key[0]); end
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    rect = item_rect(index)
    reset_font_settings
    if item.nil?
      draw_gold(rect)
      return
    end
    rect.width -= 4
    draw_item_name(item, rect.x, rect.y, true, rect.width - 24)
    draw_item_number(rect, item)
  end
  
  #--------------------------------------------------------------------------
  # draw_gold
  #--------------------------------------------------------------------------
  def draw_gold(rect)
    text = Vocab.currency_unit
    draw_currency_value(@gold, text, rect.x, rect.y, rect.width)
  end
  
  #--------------------------------------------------------------------------
  # draw_item_number
  #--------------------------------------------------------------------------
  def draw_item_number(rect, item)
    number = @goods[item].group
    if $imported["YEA-AdjustLimits"]
      contents.font.size = YEA::LIMIT::ITEM_FONT
      text = sprintf(YEA::LIMIT::ITEM_PREFIX, number)
      draw_text(rect, text, 2)
    else
      draw_text(rect, sprintf(":%s", number), 2)
    end
  end
  
end # Window_VictorySpoils

#==============================================================================
# �� Scene_Battle
#==============================================================================

class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: create_all_windows
  #--------------------------------------------------------------------------
  alias scene_battle_create_all_windows_va create_all_windows
  def create_all_windows
    scene_battle_create_all_windows_va
    create_victory_aftermath_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: create_victory_aftermath_windows
  #--------------------------------------------------------------------------
  def create_victory_aftermath_windows
    @victory_title_window = Window_VictoryTitle.new
    @victory_exp_window_back = Window_VictoryEXP_Back.new
    @victory_exp_window_front = Window_VictoryEXP_Front.new
    @victory_level_window = Window_VictoryLevelUp.new
    @victory_level_skills = Window_VictorySkills.new
    @victory_spoils_window = Window_VictorySpoils.new
  end
  
  #--------------------------------------------------------------------------
  # new method: show_victory_display_exp
  #--------------------------------------------------------------------------
  def show_victory_display_exp
    @victory_title_window.open
    name = $game_party.battle_members[0].name
    fmt = YEA::VICTORY_AFTERMATH::TOP_TEAM
    name = sprintf(fmt, name) if $game_party.battle_members.size > 1
    fmt = YEA::VICTORY_AFTERMATH::TOP_VICTORY_TEXT
    text = sprintf(fmt, name)
    @victory_title_window.refresh(text)
    #---
    @victory_exp_window_back.open
    @victory_exp_window_back.refresh
    @victory_exp_window_front.open
    @victory_exp_window_front.refresh
  end
  
  #--------------------------------------------------------------------------
  # new method: show_victory_level_up
  #--------------------------------------------------------------------------
  def show_victory_level_up(actor, temp_actor)
    @victory_exp_window_back.hide
    @victory_exp_window_front.hide
    #---
    fmt = YEA::VICTORY_AFTERMATH::TOP_LEVEL_UP
    text = sprintf(fmt, actor.name)
    @victory_title_window.refresh(text)
    #---
    @victory_level_window.show
    @victory_level_window.refresh(actor, temp_actor)
    @victory_level_skills.show
    @victory_level_skills.refresh(actor, temp_actor)
  end
  
  #--------------------------------------------------------------------------
  # new method: show_victory_spoils
  #--------------------------------------------------------------------------
  def show_victory_spoils(gold, drops)
    @victory_exp_window_back.hide
    @victory_exp_window_front.hide
    @victory_level_window.hide
    @victory_level_skills.hide
    #---
    text = YEA::VICTORY_AFTERMATH::TOP_SPOILS
    @victory_title_window.refresh(text)
    #---
    @victory_spoils_window.show
    @victory_spoils_window.make(gold, drops)
  end
  
  #--------------------------------------------------------------------------
  # new method: close_victory_windows
  #--------------------------------------------------------------------------
  def close_victory_windows
    @victory_title_window.close
    @victory_exp_window_back.close
    @victory_exp_window_front.close
    @victory_level_window.close
    @victory_level_skills.close
    @victory_spoils_window.close
    wait(16)
  end
  
end # Scene_Battle

#==============================================================================
# 
# �� End of File
# 
#==============================================================================





#==============================================================================
# 
# ?\ Yanfly Engine Ace - Ace Save Engine v1.03
# -- Last Updated: 2012.07.22
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-SaveEngine"] = true

#==============================================================================
# ?\ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.07.22 - Fixed: Location Drawing.
# 2012.01.23 - Anti-crash method added for removed maps.
# 2011.12.26 - Compatibility Update: New Game+
# 2011.12.26 - Started Script and Finished.
# 
#==============================================================================
# ?\ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script provides a new save interface for the player. Along with a new
# interface, the player can also load and delete saves straight from the menu
# itself. This will in turn make the save command from the Main Menu always
# available, but the save option within the new save menu will be enabled
# depending on whether or not it is allowed or disallowed. From the interface,
# the player is given more information regarding the save file including the
# the location the player saved at, the amount of gold available, and any
# variables that you want to show the player as well.
# 
#==============================================================================
# ?\ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ?\ Materials/�ef?T but above ?\ Main. Remember to save.
# 
# For first time installers, be warned that loading this script the first time
# may not display all information in the status window for save files made
# before the installation of this script. To remedy this, just load up the save
# and save the file again.
# 
#==============================================================================
# ?\ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module SAVE
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Slot Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts how the slot window appears on the left side of the
    # screen. This also adjusts the maximum number of saves a player can make,
    # the way the slot names appear, and the icons used.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    MAX_FILES = 24         # Maximum saves a player can make. Default: 16
    SLOT_NAME = "File %s"  # How the file slots will be named.
    
    # These are the icons
    SAVE_ICON  = 368       # Icon used to indicate a save is present.
    EMPTY_ICON = 375       # Icon used to indicate an empty file.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Action Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts how the action window appears, the sound effect
    # played when deleting files, and what appears in the help window above.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ACTION_LOAD   = "Load"           # Text used for loading games.
    ACTION_SAVE   = "Save"           # Text used for saving games.
    ACTION_DELETE = "Delete"         # Text used for deleting games.
    DELETE_SOUND  = RPG::SE.new("Collapse3", 100, 100) # Sound for deleting.
    
    # These text settings adjust what displays in the help window.
    SELECT_HELP = "Please select a file slot."
    LOAD_HELP   = "Loads the data from the saved game."
    SAVE_HELP   = "Saves the current progress in your game."
    DELETE_HELP = "Deletes all data from this save file."
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Status Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts how the status window appears in the middle of the
    # screen (that displays the game's data) such as the total playtime, total
    # times saved, total gold, the party's current location, and the variables
    # to be displayed.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    EMPTY_TEXT = "No Save Data"      # Text used when no save data is present.
    PLAYTIME   = "Playtime"          # Text used for total playtime.
    TOTAL_SAVE = "Total Saves: "     # Text used to indicate total saves.
    TOTAL_GOLD = "Total Gold: "      # Text used to indicate total gold.
    LOCATION   = "Location: "        # Text used to indicate current location.
    
    # These variables will be shown in each of the two columns for those who
    # would want to display more information than just what's shown. Input the
    # variables into the arrays below to designate what data will be shown.
    COLUMN1_VARIABLES = [1, 2, 3]
    COLUMN2_VARIABLES = [4, 5, 6]
    
  end # SAVE
end # YEA

#==============================================================================
# ?\ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

#==============================================================================
# ?! Icon
#==============================================================================

module Icon
  
  #--------------------------------------------------------------------------
  # self.save_icon
  #--------------------------------------------------------------------------
  def self.save_icon; return YEA::SAVE::SAVE_ICON; end
  
  #--------------------------------------------------------------------------
  # self.empty_icon
  #--------------------------------------------------------------------------
  def self.empty_icon; return YEA::SAVE::EMPTY_ICON; end
    
end # Icon

#==============================================================================
# ?! Numeric
#==============================================================================

class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric

#==============================================================================
# ?! DataManager
#==============================================================================

module DataManager
  
  #--------------------------------------------------------------------------
  # overwrite method: savefile_max
  #--------------------------------------------------------------------------
  def self.savefile_max
    return YEA::SAVE::MAX_FILES
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: self.make_save_header
  #--------------------------------------------------------------------------
  def self.make_save_header
    header = {}
    header[:characters]    = $game_party.characters_for_savefile
    header[:playtime_s]    = $game_system.playtime_s
    header[:system]        = Marshal.load(Marshal.dump($game_system))
    header[:timer]         = Marshal.load(Marshal.dump($game_timer))
    header[:message]       = Marshal.load(Marshal.dump($game_message))
    header[:switches]      = Marshal.load(Marshal.dump($game_switches))
    header[:variables]     = Marshal.load(Marshal.dump($game_variables))
    header[:self_switches] = Marshal.load(Marshal.dump($game_self_switches))
    header[:actors]        = Marshal.load(Marshal.dump($game_actors))
    header[:party]         = Marshal.load(Marshal.dump($game_party))
    header[:troop]         = Marshal.load(Marshal.dump($game_troop))
    header[:map]           = Marshal.load(Marshal.dump($game_map))
    header[:player]        = Marshal.load(Marshal.dump($game_player))
    header
  end
  
end # DataManager

#==============================================================================
# ?! Window_MenuCommand
#==============================================================================

class Window_MenuCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # overwrite method: save_enabled
  #--------------------------------------------------------------------------
  def save_enabled; return true; end
  
end # Window_MenuCommand

#==============================================================================
# ?! Window_FileList
#==============================================================================

class Window_FileList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy)
    super(dx, dy, 128, Graphics.height - dy)
    refresh
    activate
    select(SceneManager.scene.first_savefile_index)
  end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return DataManager.savefile_max; end
  
  #--------------------------------------------------------------------------
  # current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?
    header = DataManager.load_header(index)
    return false if header.nil? && SceneManager.scene_is?(Scene_Load)
    return true
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    header = DataManager.load_header(index)
    enabled = !header.nil?
    rect = item_rect(index)
    rect.width -= 4
    draw_icon(save_icon?(header), rect.x, rect.y, enabled)
    change_color(normal_color, enabled)
    text = sprintf(YEA::SAVE::SLOT_NAME, (index + 1).group)
    draw_text(rect.x+24, rect.y, rect.width-24, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # save_icon?
  #--------------------------------------------------------------------------
  def save_icon?(header)
    return Icon.empty_icon if header.nil?
    return Icon.save_icon
  end
  
end # Window_FileList

#==============================================================================
# ?! Window_FileStatus
#==============================================================================

class Window_FileStatus < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, file_window)
    super(dx, dy, Graphics.width - dx, Graphics.height - dy)
    @file_window = file_window
    @current_index = @file_window.index
    refresh
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return if @file_window.index < 0
    return if @current_index == @file_window.index
    @current_index = @file_window.index
    refresh
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    @header = DataManager.load_header(@file_window.index)
    if @header.nil?
      draw_empty
    else
      draw_save_contents
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_empty
  #--------------------------------------------------------------------------
  def draw_empty
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(0, 0, contents.width, contents.height)
    contents.fill_rect(rect, colour)
    text = YEA::SAVE::EMPTY_TEXT
    change_color(system_color)
    draw_text(rect, text, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_slot
  #--------------------------------------------------------------------------
  def draw_save_slot(dx, dy, dw)
    reset_font_settings
    change_color(system_color)
    text = sprintf(YEA::SAVE::SLOT_NAME, "")
    draw_text(dx, dy, dw, line_height, text)
    cx = text_size(text).width
    change_color(normal_color)
    draw_text(dx+cx, dy, dw-cx, line_height, (@file_window.index+1).group)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_playtime
  #--------------------------------------------------------------------------
  def draw_save_playtime(dx, dy, dw)
    return if @header[:playtime_s].nil?
    reset_font_settings
    change_color(system_color)
    draw_text(dx, dy, dw, line_height, YEA::SAVE::PLAYTIME, 0)
    change_color(normal_color)
    draw_text(dx, dy, dw, line_height, @header[:playtime_s], 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_total_saves
  #--------------------------------------------------------------------------
  def draw_save_total_saves(dx, dy, dw)
    return if @header[:system].nil?
    reset_font_settings
    change_color(system_color)
    text = YEA::SAVE::TOTAL_SAVE
    draw_text(dx, dy, dw, line_height, text)
    cx = text_size(text).width
    change_color(normal_color)
    draw_text(dx+cx, dy, dw-cx, line_height, @header[:system].save_count.group)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_gold
  #--------------------------------------------------------------------------
  def draw_save_gold(dx, dy, dw)
    return if @header[:party].nil?
    reset_font_settings
    change_color(system_color)
    draw_text(dx, dy, dw, line_height, YEA::SAVE::TOTAL_GOLD)
    text = Vocab::currency_unit
    draw_text(dx, dy, dw, line_height, text, 2)
    cx = text_size(text).width
    change_color(normal_color)
    text = @header[:party].gold.group
    draw_text(dx, dy, dw-cx, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_location
  #--------------------------------------------------------------------------
  def draw_save_location(dx, dy, dw)
    return if @header[:map].nil?
    reset_font_settings
    change_color(system_color)
    draw_text(dx, dy, dw, line_height, YEA::SAVE::LOCATION)
    change_color(normal_color)
    cx = text_size(YEA::SAVE::LOCATION).width
    return if $data_mapinfos[@header[:map].map_id].nil?
    text = @header[:map].display_name
    text = $data_mapinfos[@header[:map].map_id].name if text == ""
    draw_text(dx+cx, dy, dw-cx, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_characters
  #--------------------------------------------------------------------------
  def draw_save_characters(dx, dy)
    return if @header[:party].nil?
    reset_font_settings
    make_font_smaller
    dw = (contents.width - dx) / @header[:party].max_battle_members
    dx += dw/2
    for member in @header[:party].battle_members
      next if member.nil?
      member = @header[:actors][member.id]
      change_color(normal_color)
      draw_actor_graphic(member, dx, dy)
      text = member.name
      draw_text(dx-dw/2, dy, dw, line_height, text, 1)
      text = member.level.group
      draw_text(dx-dw/2, dy-line_height, dw-4, line_height, text, 2)
      cx = text_size(text).width
      change_color(system_color)
      text = Vocab::level_a
      draw_text(dx-dw/2, dy-line_height, dw-cx-4, line_height, text, 2)
      dx += dw
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_save_column1
  #--------------------------------------------------------------------------
  def draw_save_column1(dx, dy, dw)
    data = YEA::SAVE::COLUMN1_VARIABLES
    draw_column_data(data, dx, dy, dw)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_column2
  #--------------------------------------------------------------------------
  def draw_save_column2(dx, dy, dw)
    data = YEA::SAVE::COLUMN2_VARIABLES
    draw_column_data(data, dx, dy, dw)
  end
  
  #--------------------------------------------------------------------------
  # draw_column_data
  #--------------------------------------------------------------------------
  def draw_column_data(data, dx, dy, dw)
    return if @header[:variables].nil?
    reset_font_settings
    for variable_id in data
      next if $data_system.variables[variable_id].nil?
      change_color(system_color)
      name = $data_system.variables[variable_id]
      draw_text(dx, dy, dw, line_height, name, 0)
      value = @header[:variables][variable_id].group
      change_color(normal_color)
      draw_text(dx, dy, dw, line_height, value, 2)
      dy += line_height
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_save_contents
  #--------------------------------------------------------------------------
  def draw_save_contents
    draw_save_slot(4, 0, contents.width/2-8)
    draw_save_playtime(contents.width/2+4, 0, contents.width/2-8)
    draw_save_total_saves(4, line_height, contents.width/2-8)
    draw_save_gold(contents.width/2+4, line_height, contents.width/2-8)
    draw_save_location(4, line_height*2, contents.width-8)
    draw_save_characters(0, line_height*5 + line_height/3)
    draw_save_column1(16, line_height*7, contents.width/2-48)
    draw_save_column2(contents.width/2+16, line_height*7, contents.width/2-48)
  end
  
end # Window_FileStatus

#==============================================================================
# ?! Window_FileAction
#==============================================================================

class Window_FileAction < Window_HorzCommand
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, file_window)
    @file_window = file_window
    super(dx, dy)
    deactivate
    unselect
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; Graphics.width - 128; end
  
  #--------------------------------------------------------------------------
  # col_max
  #--------------------------------------------------------------------------
  def col_max; return 3; end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return if @file_window.index < 0
    return if @current_index == @file_window.index
    @current_index = @file_window.index
    refresh
  end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    @header = DataManager.load_header(@file_window.index)
    add_load_command
    add_save_command
    add_delete_command
  end
  
  #--------------------------------------------------------------------------
  # add_load_command
  #--------------------------------------------------------------------------
  def add_load_command
    add_command(YEA::SAVE::ACTION_LOAD, :load, load_enabled?)
  end
  
  #--------------------------------------------------------------------------
  # load_enabled?
  #--------------------------------------------------------------------------
  def load_enabled?
    return false if @header.nil?
    return true
  end
  
  #--------------------------------------------------------------------------
  # add_save_command
  #--------------------------------------------------------------------------
  def add_save_command
    add_command(YEA::SAVE::ACTION_SAVE, :save, save_enabled?)
  end
  
  #--------------------------------------------------------------------------
  # save_enabled?
  #--------------------------------------------------------------------------
  def save_enabled?
    return false if @header.nil? && SceneManager.scene_is?(Scene_Load)
    return false if SceneManager.scene_is?(Scene_Load)
    return false if $game_system.save_disabled
    return true
  end
  
  #--------------------------------------------------------------------------
  # add_delete_command
  #--------------------------------------------------------------------------
  def add_delete_command
    add_command(YEA::SAVE::ACTION_DELETE, :delete, delete_enabled?)
  end
  
  #--------------------------------------------------------------------------
  # delete_enabled?
  #--------------------------------------------------------------------------
  def delete_enabled?
    return false if @header.nil?
    return true
  end
  
  #--------------------------------------------------------------------------
  # update_help
  #--------------------------------------------------------------------------
  def update_help
    case current_symbol
    when :load; @help_window.set_text(YEA::SAVE::LOAD_HELP)
    when :save; @help_window.set_text(YEA::SAVE::SAVE_HELP)
    when :delete; @help_window.set_text(YEA::SAVE::DELETE_HELP)
    end
  end
  
end # Window_FileAction

#==============================================================================
# ?! Scene_File
#==============================================================================

class Scene_File < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # overwrite method: start
  #--------------------------------------------------------------------------
  def start
    super
    create_all_windows
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: terminate
  #--------------------------------------------------------------------------
  def terminate
    super
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: update
  #--------------------------------------------------------------------------
  def update
    super
  end
  
  #--------------------------------------------------------------------------
  # new method: create_all_windows
  #--------------------------------------------------------------------------
  def create_all_windows
    create_help_window
    create_file_window
    create_action_window
    create_status_window
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_help_window
  #--------------------------------------------------------------------------
  def create_help_window
    @help_window = Window_Help.new
    @help_window.set_text(YEA::SAVE::SELECT_HELP)
  end
  
  #--------------------------------------------------------------------------
  # new method: create_file_window
  #--------------------------------------------------------------------------
  def create_file_window
    wy = @help_window.height
    @file_window = Window_FileList.new(0, wy)
    @file_window.set_handler(:ok, method(:on_file_ok))
    @file_window.set_handler(:cancel, method(:return_scene))
  end
  
  #--------------------------------------------------------------------------
  # new method: create_action_window
  #--------------------------------------------------------------------------
  def create_action_window
    wx = @file_window.width
    wy = @help_window.height
    @action_window = Window_FileAction.new(wx, wy, @file_window)
    @action_window.help_window = @help_window
    @action_window.set_handler(:cancel, method(:on_action_cancel))
    @action_window.set_handler(:load, method(:on_action_load))
    @action_window.set_handler(:save, method(:on_action_save))
    @action_window.set_handler(:delete, method(:on_action_delete))
  end
  
  #--------------------------------------------------------------------------
  # new method: create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    wx = @action_window.x
    wy = @action_window.y + @action_window.height
    @status_window = Window_FileStatus.new(wx, wy, @file_window)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_file_ok
  #--------------------------------------------------------------------------
  def on_file_ok
    @action_window.activate
    index = SceneManager.scene_is?(Scene_Load) ? 0 : 1
    @action_window.select(index)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_action_cancel
  #--------------------------------------------------------------------------
  def on_action_cancel
    @action_window.unselect
    @file_window.activate
    @help_window.set_text(YEA::SAVE::SELECT_HELP)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_action_load
  #--------------------------------------------------------------------------
  def on_action_load
    if DataManager.load_game(@file_window.index)
      on_load_success
    else
      Sound.play_buzzer
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_load_success
  #--------------------------------------------------------------------------
  def on_load_success
    Sound.play_load
    fadeout_all
    $game_system.on_after_load
    SceneManager.goto(Scene_Map)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_action_save
  #--------------------------------------------------------------------------
  def on_action_save
    @action_window.activate
    if DataManager.save_game(@file_window.index)
      on_save_success
      refresh_windows
    else
      Sound.play_buzzer
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_save_success
  #--------------------------------------------------------------------------
  def on_save_success; Sound.play_save; end
  
  #--------------------------------------------------------------------------
  # new method: on_action_delete
  #--------------------------------------------------------------------------
  def on_action_delete
    @action_window.activate
    DataManager.delete_save_file(@file_window.index)
    on_delete_success
    refresh_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: on_delete_success
  #--------------------------------------------------------------------------
  def on_delete_success
    YEA::SAVE::DELETE_SOUND.play
  end
  
  #--------------------------------------------------------------------------
  # new method: refresh_windows
  #--------------------------------------------------------------------------
  def refresh_windows
    @file_window.refresh
    @action_window.refresh
    @status_window.refresh
  end
  
end # Scene_File

#==============================================================================
# ?! Scene_Save
#==============================================================================

class Scene_Save < Scene_File
  
  #--------------------------------------------------------------------------
  # overwrite method: on_savefile_ok
  #--------------------------------------------------------------------------
  def on_savefile_ok; super; end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_save_success
  #--------------------------------------------------------------------------
  def on_save_success; super; end
  
end # help_window_text

#==============================================================================
# ?! Scene_Load
#==============================================================================

class Scene_Load < Scene_File
  
  #--------------------------------------------------------------------------
  # overwrite method: on_savefile_ok
  #--------------------------------------------------------------------------
  def on_savefile_ok; super; end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_load_success
  #--------------------------------------------------------------------------
  def on_load_success; super; end
  
end # Scene_Load

#==============================================================================
# 
# ?\ End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - System Options v1.00
# -- Last Updated: 2012.01.01
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-SystemOptions"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.01 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script replaces the "Game End" option in the Main Menu with a "System"
# menu where the player can adjust various settings in the game. Of them, the
# player can change the window colour, the volume for BGM, BGS, SFX, set
# automatic dashing, message text to display instantly, and speed up battles by
# hiding battle animations.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Script Calls - These commands are used with script calls.
# -----------------------------------------------------------------------------
# $game_system.volume_change(:bgm, x)
# $game_system.volume_change(:bgs, x)
# $game_system.volume_change(:sfx, x)
# Unlike the previous Yanfly Engines, this version does not bind volume to a
# variable. Use the script call to change the bgm, bgs, or sfx sound rate by
# x increment. Use a negative value to lower the volume.
#
# $game_system.set_volume(:bgm, x)
# $game_system.set_volume(:bgs, x)
# $game_system.set_volume(:sfx, x)
# Use this script call to set the bgm, bgs, or sfx volume directly. (x should
# be between 0 and 100.)
# 
# $game_system.set_autodash(true)
# $game_system.set_autodash(false)
# Turns autodash on (true) or off (false).
# 
# $game_system.set_instantmsg(true)
# $game_system.set_instantmsg(false)
# Turns instant messages on (true) or off (false).
# 
# $game_system.set_animations(true)
# $game_system.set_animations(false)
# Turns battle animations on (true) or off (false).
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module SYSTEM
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Setting -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These are the general settings that govern the System settings. This will
    # change the "Game End" vocab, and disable or enable autodash, instant
    # messages, or animations by default.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMAND_NAME = "System"      # Command name used to replace Game End.
    DEFAULT_AUTODASH   = true    # Enable automatic dashing by default?
    DEFAULT_INSTANTMSG = false   # Enable instant message text by default?
    DEFAULT_ANIMATIONS = true    # Enable battle animations by default?
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Command Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust the commands shown in the command list. Add, remove
    # or rearrange the commands as you see fit. Here's a list of which commands
    # do what:
    # 
    # -------------------------------------------------------------------------
    # :command         Description
    # -------------------------------------------------------------------------
    # :blank           Inserts an empty blank space.
    # 
    # :window_red      Changes the red tone for all windows.
    # :window_grn      Changes the green tone for all windows.
    # :window_blu      Changes the blue tone for all windows.
    # 
    # :volume_bgm      Changes the BGM volume used.
    # :volume_bgs      Changes the BGS volume used.
    # :volume_sfx      Changes the SFX volume used.
    # 
    # :autodash        Sets the player to automatically dash.
    # :instantmsg      Sets message text to appear instantly.
    # :animations      Enables battle animations or disables them.
    # 
    # :to_title        Returns to the title screen.
    # :shutdown        Shuts down the game.
    # 
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMANDS =[
      :window_red,   # Changes the red tone for all windows.
      :window_grn,   # Changes the green tone for all windows.
      :window_blu,   # Changes the blue tone for all windows.
      :volume_bgm,   # Changes the BGM volume used.
      :volume_bgs,   # Changes the BGS volume used.
      :volume_sfx,   # Changes the SFX volume used.
      :blank,
      :autodash,     # Sets the player to automatically dash.
      :instantmsg,   # Sets message text to appear instantly.
      :animations,   # Enables battle animations or disables them.
    # :switch_1,     # Custom Switch 1. Adjust settings below.
    # :switch_2,     # Custom Switch 2. Adjust settings below.
    # :variable_1,   # Custom Variable 1. Adjust settings below.
    # :variable_2,   # Custom Variable 2. Adjust settings below.
      :blank,
      :to_title,     # Returns to the title screen.
      :shutdown,     # Shuts down the game.
    ] # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Custom Switches -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # If you want your game to have system options other than just the ones
    # listed above, you can insert custom switches here to produce such an
    # effect. Adjust the settings here as you see fit.
    #--------------------------------------------------------------------------
    CUSTOM_SWITCHES ={
    # -------------------------------------------------------------------------
    # :switch    => [Switch, Name, Off Text, On Text, 
    #                Help Window Description
    #               ], # Do not remove this.
    # -------------------------------------------------------------------------
      :switch_1  => [ 1, "Custom Switch 1", "OFF", "ON",
                     "Help description used for custom switch 1."
                    ],
    # -------------------------------------------------------------------------
      :switch_2  => [ 2, "Custom Switch 2", "OFF", "ON",
                     "Help description used for custom switch 2."
                    ],
    # -------------------------------------------------------------------------
    } # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Custom Variables -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # If you want your game to have system options other than just the ones
    # listed above, you can insert custom variables here to produce such an
    # effect. Adjust the settings here as you see fit.
    #--------------------------------------------------------------------------
    CUSTOM_VARIABLES ={
    # -------------------------------------------------------------------------
    # :variable   => [Switch, Name, Colour1, Colour2, Min, Max,
    #                 Help Window Description
    #                ], # Do not remove this.
    # -------------------------------------------------------------------------
      :variable_1 => [ 1, "Custom Variable 1", 9, 1, -100, 100,
                      "Help description used for custom variable 1."
                     ],
    # -------------------------------------------------------------------------
      :variable_2 => [ 2, "Custom Variable 2", 10, 2, -10, 10,
                      "Help description used for custom variable 2."
                     ],
    # -------------------------------------------------------------------------
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Vocab Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This hash adjusts the vocab used for both the commands and the help
    # description that appears above the command window. Note that for the
    # command help descriptions, you may use text codes. Use \n to linebreak.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMAND_VOCAB ={
    # -------------------------------------------------------------------------
    # :command    => [Command Name, Option1, Option2
    #                 Help Window Description,
    #                ], # Do not remove this.
    # -------------------------------------------------------------------------
      :blank      => ["", "None", "None",
                      ""
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :window_red => ["Window Red", "None", "None",
                      "Change the red colour tone for windows.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :window_grn => ["Window Green", "None", "None",
                      "Change the green colour tone for windows.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :window_blu => ["Window Blue", "None", "None",
                      "Change the blue colour tone for windows.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :volume_bgm => ["BGM Volume", 12, 4, # Options 1 & 2 are Gauge Colours.
                      "Change the volume used for background music.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :volume_bgs => ["BGS Volume", 13, 5, # Options 1 & 2 are Gauge Colours.
                      "Change the volume used for background sound.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :volume_sfx => ["SFX Volume", 14, 6, # Options 1 & 2 are Gauge Colours.
                      "Change the volume used for sound effects.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :autodash   => ["Auto-Dash", "Walk", "Dash",
                      "Automatically dash without holding the run button."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :instantmsg => ["Instant Text", "Normal", "Instant",
                      "Set message text to appear one-by-one or instantly."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :animations => ["Battle Animations", "Hide", "Show",
                      "Hide animations during battle to speed up battles?"
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :to_title   => ["Return to Title Screen", "None", "None",
                      "Go back to the title screen."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :shutdown   => ["Shutdown Game", "None", "None",
                      "Turns off the game."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
    } # Do not remove this.
    
  end # SYSTEM
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

#==============================================================================
# ■ Vocab
#==============================================================================

module Vocab
  
  #--------------------------------------------------------------------------
  # overwrite method: self.game_end
  #--------------------------------------------------------------------------
  def self.game_end
    return YEA::SYSTEM::COMMAND_NAME
  end
  
end # Vocab

#==============================================================================
# ■ RPG::BGM
#==============================================================================

class RPG::BGM < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play(pos = 0)
    if @name.empty?
      Audio.bgm_stop
      @@last = RPG::BGM.new
    else
      volume = @volume
      volume *= $game_system.volume(:bgm) * 0.01 unless $game_system.nil?
      Audio.bgm_play('Audio/BGM/' + @name, volume, @pitch, pos)
      @@last = self.clone
    end
  end
  
end # RPG::BGM

#==============================================================================
# ■ RPG::ME
#==============================================================================

class RPG::ME < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play
    if @name.empty?
      Audio.me_stop
    else
      volume = @volume
      volume *= $game_system.volume(:bgm) * 0.01 unless $game_system.nil?
      Audio.me_play('Audio/ME/' + @name, volume, @pitch)
    end
  end
  
end # RPG::ME

#==============================================================================
# ■ RPG::BGS
#==============================================================================

class RPG::BGS < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play(pos = 0)
    if @name.empty?
      Audio.bgs_stop
      @@last = RPG::BGS.new
    else
      volume = @volume
      volume *= $game_system.volume(:bgs) * 0.01 unless $game_system.nil?
      Audio.bgs_play('Audio/BGS/' + @name, volume, @pitch, pos)
      @@last = self.clone
    end
  end
  
end # RPG::BGS

#==============================================================================
# ■ RPG::SE
#==============================================================================

class RPG::SE < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play
    unless @name.empty?
      volume = @volume
      volume *= $game_system.volume(:sfx) * 0.01 unless $game_system.nil?
      Audio.se_play('Audio/SE/' + @name, volume, @pitch)
    end
  end
  
end # RPG::SE

#==============================================================================
# ■ Game_System
#==============================================================================

class Game_System
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias game_system_initialize_so initialize
  def initialize
    game_system_initialize_so
    init_volume_control
    init_autodash
    init_instantmsg
    init_animations
  end
  
  #--------------------------------------------------------------------------
  # new method: init_volume_control
  #--------------------------------------------------------------------------
  def init_volume_control
    @volume = {}
    @volume[:bgm] = 100
    @volume[:bgs] = 100
    @volume[:sfx] = 100
  end
  
  #--------------------------------------------------------------------------
  # new method: volume
  #--------------------------------------------------------------------------
  def volume(type)
    init_volume_control if @volume.nil?
    return [[@volume[type], 0].max, 100].min
  end

  #--------------------------------------------------------------------------
  # new method: set_volume
  #--------------------------------------------------------------------------
  def set_volume(type, value)
    init_volume_control if @volume.nil?
    @volume[type] = [[value, 0].max, 100].min
    case type
    when :bgm
      RPG::BGM::last.play
    when :bgs
      RPG::BGS::last.play
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: volume_change
  #--------------------------------------------------------------------------
  def volume_change(type, increment)
    set_volume(type, @volume[type] + increment)
  end
  
  #--------------------------------------------------------------------------
  # new method: init_autodash
  #--------------------------------------------------------------------------
  def init_autodash
    @autodash = YEA::SYSTEM::DEFAULT_AUTODASH
  end
  
  #--------------------------------------------------------------------------
  # new method: autodash?
  #--------------------------------------------------------------------------
  def autodash?
    init_autodash if @autodash.nil?
    return @autodash
  end
  
  #--------------------------------------------------------------------------
  # new method: set_autodash
  #--------------------------------------------------------------------------
  def set_autodash(value)
    @autodash = value
  end
  
  #--------------------------------------------------------------------------
  # new method: init_instantmsg
  #--------------------------------------------------------------------------
  def init_instantmsg
    @instantmsg = YEA::SYSTEM::DEFAULT_INSTANTMSG
  end
  
  #--------------------------------------------------------------------------
  # new method: instantmsg?
  #--------------------------------------------------------------------------
  def instantmsg?
    init_instantmsg if @instantmsg.nil?
    return @instantmsg
  end
  
  #--------------------------------------------------------------------------
  # new method: set_instantmsg
  #--------------------------------------------------------------------------
  def set_instantmsg(value)
    @instantmsg = value
  end
  
  #--------------------------------------------------------------------------
  # new method: init_animations
  #--------------------------------------------------------------------------
  def init_animations
    @animations = YEA::SYSTEM::DEFAULT_ANIMATIONS
  end
  
  #--------------------------------------------------------------------------
  # new method: animations?
  #--------------------------------------------------------------------------
  def animations?
    init_animations if @animations.nil?
    return @animations
  end
  
  #--------------------------------------------------------------------------
  # new method: set_animations
  #--------------------------------------------------------------------------
  def set_animations(value)
    @animations = value
  end
  
end # Game_System

#==============================================================================
# ■ Game_Player
#==============================================================================

class Game_Player < Game_Character
  
  #--------------------------------------------------------------------------
  # alias method: dash?
  #--------------------------------------------------------------------------
  alias game_player_dash_so dash?
  def dash?
    if $game_system.autodash?
      return false if @move_route_forcing
      return false if $game_map.disable_dash?
      return false if vehicle
      return !Input.press?(:A)
    else
      return game_player_dash_so
    end
  end
  
end # Game_Player

#==============================================================================
# ■ Scene_Battle
#==============================================================================

class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: show_fast?
  #--------------------------------------------------------------------------
  alias scene_battle_show_fast_so show_fast?
  def show_fast?
    return true unless $game_system.animations?
    return scene_battle_show_fast_so
  end
  
  #--------------------------------------------------------------------------
  # alias method: show_normal_animation
  #--------------------------------------------------------------------------
  alias scene_battle_show_normal_animation_so show_normal_animation
  def show_normal_animation(targets, animation_id, mirror = false)
    return unless $game_system.animations?
    scene_battle_show_normal_animation_so(targets, animation_id, mirror)
  end
  
end # Scene_Battle

#==============================================================================
# ■ Window_Message
#==============================================================================

class Window_Message < Window_Base
  
  #--------------------------------------------------------------------------
  # alias method: clear_flags
  #--------------------------------------------------------------------------
  alias window_message_clear_flags_so clear_flags
  def clear_flags
    window_message_clear_flags_so
    @show_fast = true if $game_system.instantmsg?
  end
  
end # Window_Message

#==============================================================================
# ■ Window_SystemOptions
#==============================================================================

class Window_SystemOptions < Window_Command
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(help_window)
    @help_window = help_window
    super(0, @help_window.height)
    refresh
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return Graphics.width; end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height; return Graphics.height - @help_window.height; end
  
  #--------------------------------------------------------------------------
  # update_help
  #--------------------------------------------------------------------------
  def update_help
    if current_symbol == :custom_switch || current_symbol == :custom_variable
      text = @help_descriptions[current_ext]
    else
      text = @help_descriptions[current_symbol]
    end
    text = "" if text.nil?
    @help_window.set_text(text)
  end
  
  #--------------------------------------------------------------------------
  # ok_enabled?
  #--------------------------------------------------------------------------
  def ok_enabled?
    return true if [:to_title, :shutdown].include?(current_symbol)
    return false
  end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    @help_descriptions = {}
    for command in YEA::SYSTEM::COMMANDS
      case command
      when :blank
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :window_red, :window_grn, :window_blu
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :volume_bgm, :volume_bgs, :volume_sfx
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :autodash, :instantmsg, :animations
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :to_title, :shutdown
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      else
        process_custom_switch(command)
        process_custom_variable(command)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # process_custom_switch
  #--------------------------------------------------------------------------
  def process_custom_switch(command)
    return unless YEA::SYSTEM::CUSTOM_SWITCHES.include?(command)
    name = YEA::SYSTEM::CUSTOM_SWITCHES[command][1]
    add_command(name, :custom_switch, true, command)
    @help_descriptions[command] = YEA::SYSTEM::CUSTOM_SWITCHES[command][4]
  end
  
  #--------------------------------------------------------------------------
  # process_custom_variable
  #--------------------------------------------------------------------------
  def process_custom_variable(command)
    return unless YEA::SYSTEM::CUSTOM_VARIABLES.include?(command)
    name = YEA::SYSTEM::CUSTOM_VARIABLES[command][1]
    add_command(name, :custom_variable, true, command)
    @help_descriptions[command] = YEA::SYSTEM::CUSTOM_VARIABLES[command][6]
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    reset_font_settings
    rect = item_rect(index)
    contents.clear_rect(rect)
    case @list[index][:symbol]
    when :window_red, :window_grn, :window_blu
      draw_window_tone(rect, index, @list[index][:symbol])
    when :volume_bgm, :volume_bgs, :volume_sfx
      draw_volume(rect, index, @list[index][:symbol])
    when :autodash, :instantmsg, :animations
      draw_toggle(rect, index, @list[index][:symbol])
    when :to_title, :shutdown
      draw_text(item_rect_for_text(index), command_name(index), 1)
    when :custom_switch
      draw_custom_switch(rect, index, @list[index][:ext])
    when :custom_variable
      draw_custom_variable(rect, index, @list[index][:ext])
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_window_tone
  #--------------------------------------------------------------------------
  def draw_window_tone(rect, index, symbol)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    tone = $game_system.window_tone
    case symbol
    when :window_red
      rate = (tone.red + 255.0) / 510.0
      colour1 = Color.new(128, 0, 0)
      colour2 = Color.new(255, 0, 0)
      value = tone.red.to_i
    when :window_grn
      rate = (tone.green + 255.0) / 510.0
      colour1 = Color.new(0, 128, 0)
      colour2 = Color.new(0, 255, 0)
      value = tone.green.to_i
    when :window_blu
      rate = (tone.blue + 255.0) / 510.0
      colour1 = Color.new(0, 0, 128)
      colour2 = Color.new(0, 0, 255)
      value = tone.blue.to_i
    end
    draw_gauge(dx, rect.y, contents.width - dx - 48, rate, colour1, colour2)
    draw_text(dx, rect.y, contents.width - dx - 48, line_height, value, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_volume
  #--------------------------------------------------------------------------
  def draw_volume(rect, index, symbol)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    case symbol
    when :volume_bgm
      rate = $game_system.volume(:bgm)
    when :volume_bgs
      rate = $game_system.volume(:bgs)
    when :volume_sfx
      rate = $game_system.volume(:sfx)
    end
    colour1 = text_color(YEA::SYSTEM::COMMAND_VOCAB[symbol][1])
    colour2 = text_color(YEA::SYSTEM::COMMAND_VOCAB[symbol][2])
    value = sprintf("%d%%", rate)
    rate *= 0.01
    draw_gauge(dx, rect.y, contents.width - dx - 48, rate, colour1, colour2)
    draw_text(dx, rect.y, contents.width - dx - 48, line_height, value, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_toggle
  #--------------------------------------------------------------------------
  def draw_toggle(rect, index, symbol)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    case symbol
    when :autodash
      enabled = $game_system.autodash?
    when :instantmsg
      enabled = $game_system.instantmsg?
    when :animations
      enabled = $game_system.animations?
    end
    dx = contents.width/2
    change_color(normal_color, !enabled)
    option1 = YEA::SYSTEM::COMMAND_VOCAB[symbol][1]
    draw_text(dx, rect.y, contents.width/4, line_height, option1, 1)
    dx += contents.width/4
    change_color(normal_color, enabled)
    option2 = YEA::SYSTEM::COMMAND_VOCAB[symbol][2]
    draw_text(dx, rect.y, contents.width/4, line_height, option2, 1)
  end
  
  #--------------------------------------------------------------------------
  # cursor_right
  #--------------------------------------------------------------------------
  def draw_custom_switch(rect, index, ext)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    enabled = $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]]
    dx = contents.width/2
    change_color(normal_color, !enabled)
    option1 = YEA::SYSTEM::CUSTOM_SWITCHES[ext][2]
    draw_text(dx, rect.y, contents.width/4, line_height, option1, 1)
    dx += contents.width/4
    change_color(normal_color, enabled)
    option2 = YEA::SYSTEM::CUSTOM_SWITCHES[ext][3]
    draw_text(dx, rect.y, contents.width/4, line_height, option2, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_custom_variable
  #--------------------------------------------------------------------------
  def draw_custom_variable(rect, index, ext)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    value = $game_variables[YEA::SYSTEM::CUSTOM_VARIABLES[ext][0]]
    colour1 = text_color(YEA::SYSTEM::CUSTOM_VARIABLES[ext][2])
    colour2 = text_color(YEA::SYSTEM::CUSTOM_VARIABLES[ext][3])
    minimum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][4]
    maximum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][5]
    rate = (value - minimum).to_f / [(maximum - minimum).to_f, 0.01].max
    dx = contents.width/2
    draw_gauge(dx, rect.y, contents.width - dx - 48, rate, colour1, colour2)
    draw_text(dx, rect.y, contents.width - dx - 48, line_height, value, 2)
  end
  
  #--------------------------------------------------------------------------
  # cursor_right
  #--------------------------------------------------------------------------
  def cursor_right(wrap = false)
    cursor_change(:right)
    super(wrap)
  end
  
  #--------------------------------------------------------------------------
  # cursor_left
  #--------------------------------------------------------------------------
  def cursor_left(wrap = false)
    cursor_change(:left)
    super(wrap)
  end
  
  #--------------------------------------------------------------------------
  # cursor_change
  #--------------------------------------------------------------------------
  def cursor_change(direction)
    case current_symbol
    when :window_red, :window_blu, :window_grn
      change_window_tone(direction)
    when :volume_bgm, :volume_bgs, :volume_sfx
      change_volume(direction)
    when :autodash, :instantmsg, :animations
      change_toggle(direction)
    when :custom_switch
      change_custom_switch(direction)
    when :custom_variable
      change_custom_variables(direction)
    end
  end
  
  #--------------------------------------------------------------------------
  # change_window_tone
  #--------------------------------------------------------------------------
  def change_window_tone(direction)
    Sound.play_cursor
    value = direction == :left ? -1 : 1
    value *= 10 if Input.press?(:A)
    tone = $game_system.window_tone.clone
    case current_symbol
    when :window_red; tone.red += value
    when :window_grn; tone.green += value
    when :window_blu; tone.blue += value
    end
    $game_system.window_tone = tone
    draw_item(index)
  end
  
  #--------------------------------------------------------------------------
  # change_volume
  #--------------------------------------------------------------------------
  def change_volume(direction)
    Sound.play_cursor
    value = direction == :left ? -1 : 1
    value *= 10 if Input.press?(:A)
    case current_symbol
    when :volume_bgm
      $game_system.volume_change(:bgm, value)
    when :volume_bgs
      $game_system.volume_change(:bgs, value)
    when :volume_sfx
      $game_system.volume_change(:sfx, value)
    end
    draw_item(index)
  end
  
  #--------------------------------------------------------------------------
  # change_toggle
  #--------------------------------------------------------------------------
  def change_toggle(direction)
    value = direction == :left ? false : true
    case current_symbol
    when :autodash
      current_case = $game_system.autodash?
      $game_system.set_autodash(value)
    when :instantmsg
      current_case = $game_system.instantmsg?
      $game_system.set_instantmsg(value)
    when :animations
      current_case = $game_system.animations?
      $game_system.set_animations(value)
    end
    Sound.play_cursor if value != current_case
    draw_item(index)
  end
  
  #--------------------------------------------------------------------------
  # change_custom_switch
  #--------------------------------------------------------------------------
  def change_custom_switch(direction)
    value = direction == :left ? false : true
    ext = current_ext
    current_case = $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]]
    $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]] = value
    Sound.play_cursor if value != current_case
    draw_item(index)
  end
  
  #--------------------------------------------------------------------------
  # change_custom_variables
  #--------------------------------------------------------------------------
  def change_custom_variables(direction)
    Sound.play_cursor
    value = direction == :left ? -1 : 1
    value *= 10 if Input.press?(:A)
    ext = current_ext
    var = YEA::SYSTEM::CUSTOM_VARIABLES[ext][0]
    minimum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][4]
    maximum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][5]
    $game_variables[var] += value
    $game_variables[var] = [[$game_variables[var], minimum].max, maximum].min
    draw_item(index)
  end
  
end # Window_SystemOptions

#==============================================================================
# ■ Scene_Menu
#==============================================================================

class Scene_Menu < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # overwrite method: command_game_end
  #--------------------------------------------------------------------------
  def command_game_end
    SceneManager.call(Scene_System)
  end
  
end # Scene_Menu

#==============================================================================
# ■ Scene_System
#==============================================================================

class Scene_System < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # start
  #--------------------------------------------------------------------------
  def start
    super
    create_help_window
    create_command_window
  end
  
  #--------------------------------------------------------------------------
  # create_command_window
  #--------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_SystemOptions.new(@help_window)
    @command_window.set_handler(:cancel, method(:return_scene))
    @command_window.set_handler(:to_title, method(:command_to_title))
    @command_window.set_handler(:shutdown, method(:command_shutdown))
  end
  
  #--------------------------------------------------------------------------
  # command_to_title
  #--------------------------------------------------------------------------
  def command_to_title
    fadeout_all
    SceneManager.goto(Scene_Title)
  end
  
  #--------------------------------------------------------------------------
  # command_shutdown
  #--------------------------------------------------------------------------
  def command_shutdown
    fadeout_all
    SceneManager.exit
  end
  
end # Scene_System

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - Ace Menu Engine v1.10
# -- Modified by: Doogy, The_Fireplace, rstp14 
# -- Last Updated: 2018.02.27
# -- Level: Normal, Hard
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-AceMenuEngine"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2018.02.27 - Made it possible to draw the JP bar
# 2018.01.25 - Fixed drawing bug where the HP bar was drawn over the MP bar
#            - Made it possible to draw the MP bar if the TP bar is disabled
# 2016.01.17 - Fixed drawing bug found on the latest update, where the MP bar was drawn behind the HP bar.
# 2015.01.17 - Display update MP gauge behave the same way as TP gauge (hidden if no skill use it).
# 2012.01.03 - Compatibility Update: Ace Item Menu
# 2012.01.01 - Compatibility Update: Kread-EX's Synthesis
#            - Compatibility Update: Kread-EX's Grathnode Install
#            - Compatibility Update: Yami's Slot Battle
# 2011.12.23 - Script efficiency optimized.
# 2011.12.19 - Compatibility Update: Class System
# 2011.12.15 - Updated for better menu MP/TP gauge management.
# 2011.12.13 - Compatibility Update: Ace Equip Engine
# 2011.12.07 - Update to allow for switches to also hide custom commands.
# 2011.12.06 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# The menu system in RPG Maker VX Ace is great. However, it lacks the user
# customization that RPG Maker 2003 allowed. With this script, you can add,
# remove, and rearrange menu commands as you see fit. In addition to that, you
# can add in menu commands that lead to common events or even custom commands
# provided through other scripts.
# 
# This script also provides window appearance management such as setting almost
# all command windows to be center aligned or changing the position of the
# help window. You can also opt to show the TP Gauge in the main menu as well
# as in the skill menu.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# Edit the settings in the module below as you see fit.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module MENU
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Menu Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This changes the way menus appear in your game. You can change their
    # alignment, and the location of the help window, Note that any non-Yanfly
    # Engine Ace scripts may not conform to these menu styles.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    HELP_WINDOW_LOCATION = 0     # 0-Top, 1-Middle, 2-Bottom.
    COMMAND_WINDOW_ALIGN = 1     # 0-Left, 1-Middle, 2-Right.
    
    # These settings below adjust the visual appearance of the main menu.
    # Change the settings as you see fit.
    MAIN_MENU_ALIGN = 2         # 0-Left, 1-Middle, 2-Right.
    MAIN_MENU_RIGHT = false      # false-Left, true-Right.
    MAIN_MENU_ROWS  = 10         # Maximum number of rows for main menu.
    DRAW_TP_GAUGE   = true       # If true, draws TP in the main menu.
    DRAW_MP_GAUGE   = false       # If true, draws MP in the main menu.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Main Menu Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust the main menu, the order at which commands appear,
    # what text is displayed, and what the commands are linked to. Here's a
    # list of which commands do what:
    # 
    # -------------------------------------------------------------------------
    # :command         Description
    # -------------------------------------------------------------------------
    # :item            Opens up the item menu. Default menu item.
    # :skill           Opens up the skill menu. Default menu item.
    # :equip           Opens up the equip menu. Default menu item.
    # :status          Opens up the status menu. Default menu item.
    # :formation       Lets player manage party. Default menu item.
    # :save            Opens up the save menu. Default menu item.
    # :game_end        Opens up the shutdown menu. Default menu item.
    # 
    # :class           Requires YEA - Class System
    # 
    # :gogototori      Requires Kread-EX's Go Go Totori! Synthesis
    # :grathnode       Requires Kread-EX's Grathnote Install
    # :sslots          Requires Yami's YSA - Slot Battle
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMANDS =[
      :item,         # Opens up the item menu. Default menu item.
      :skill,        # Opens up the skill menu. Default menu item.
      :equip,        # Opens up the equip menu. Default menu item.
      :class,        # Requires YEA - Class System.
      :status,       # Opens up the status menu. Default menu item.
      :formation,    # Lets player manage party. Default menu item.
    # :event_1,      # Launches Common Event 1. Common Event Command.
    # :event_2,      # Launches Common Event 2. Common Event Command.
    # :debug,        # Opens up debug menu. Custom Command.
    # :shop,         # Opens up a shop to pawn items. Custom Command.
      :save,         # Opens up the save menu. Default menu item.
      :game_end,     # Opens up the shutdown menu. Default menu item.
    ] # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Common Event Commands -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # If you insert one of the following commands into the COMMANDS array, the
    # player can trigger a common event to launch. You can disable certain
    # commands in the menu by binding them to a switch. If you don't want to
    # disable them, set the switch to 0 and it will always be enabled. The
    # ShowSwitch will prevent a command from appear if that switch is false.
    # Set it to 0 for it to have no impact.
    #--------------------------------------------------------------------------
    COMMON_EVENT_COMMANDS ={
    # :command => ["Display Name", EnableSwitch, ShowSwitch, Event ID],
      :event_1 => [        "Camp",           11,          0,        1],
      :event_2 => [   "Synthesis",            0,          0,        2],
    } # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Custom Commands -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # For those who use scripts that may lead to other menu scenes, use this
    # hash to manage custom commands that run specific script calls. You can
    # disable certain commands in the menu by binding them to a switch. If you
    # don't want to disable them, set the switch to 0. The ShowSwitch will
    # prevent a command from appear if that switch is false. Set it to 0 for
    # it to have no impact.
    #--------------------------------------------------------------------------
    CUSTOM_COMMANDS ={
    # :command => ["Display Name", EnableSwitch, ShowSwitch, Handler Method],
      :debug   => [       "Debug",            0,          0, :command_debug],
      :shop    => [        "Shop",           12,          0,  :command_shop],
      :gogototori => ["Synthesis",            0,        0,  :command_totori],
      :grathnode => [ "Grathnode",            0,        0, :command_install],
    } # Do not remove this.
    
  end # MENU
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

#==============================================================================
# ■ Window_MenuCommand
#------------------------------------------------------------------------------
# This class is kept towards the top of the script to provide easier access.
#==============================================================================

class Window_MenuCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # overwrite method: make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    for command in YEA::MENU::COMMANDS
      case command
      #--- Default Commands ---
      when :item
        add_command(Vocab::item,   :item,   main_commands_enabled)
      when :skill
        add_command(Vocab::skill,  :skill,  main_commands_enabled)
      when :equip
        add_command(Vocab::equip,  :equip,  main_commands_enabled)
      when :status
        add_command(Vocab::status, :status, main_commands_enabled)
      when :formation
        add_formation_command
      when :save
        add_original_commands
        add_save_command
      when :game_end
        add_game_end_command
      #--- Yanfly Engine Ace Commands ---
      when :class
        next unless $imported["YEA-ClassSystem"]
        add_class_command
      #--- Imported Commands ---
      when :sslots
        next unless $imported["YSA-SlotBattle"]
        add_sslots_command
      when :grathnode
        next unless $imported["KRX-GrathnodeInstall"]
        process_custom_command(command)
      when :gogototori
        next unless $imported["KRX-AlchemicSynthesis"]
        process_custom_command(command)
      #--- Imported Commands ---
      else
        process_common_event_command(command)
        process_custom_command(command)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: process_common_event_command
  #--------------------------------------------------------------------------
  def process_common_event_command(command)
    return unless YEA::MENU::COMMON_EVENT_COMMANDS.include?(command)
    show = YEA::MENU::COMMON_EVENT_COMMANDS[command][2]
    continue = show <= 0 ? true : $game_switches[show]
    return unless continue
    text = YEA::MENU::COMMON_EVENT_COMMANDS[command][0]
    switch = YEA::MENU::COMMON_EVENT_COMMANDS[command][1]
    ext = YEA::MENU::COMMON_EVENT_COMMANDS[command][3]
    enabled = switch <= 0 ? true : $game_switches[switch]
    add_command(text, command, enabled, ext)
  end
  
  #--------------------------------------------------------------------------
  # new method: process_custom_command
  #--------------------------------------------------------------------------
  def process_custom_command(command)
    return unless YEA::MENU::CUSTOM_COMMANDS.include?(command)
    show = YEA::MENU::CUSTOM_COMMANDS[command][2]
    continue = show <= 0 ? true : $game_switches[show]
    return unless continue
    text = YEA::MENU::CUSTOM_COMMANDS[command][0]
    switch = YEA::MENU::CUSTOM_COMMANDS[command][1]
    enabled = switch <= 0 ? true : $game_switches[switch]
    add_command(text, command, enabled)
  end
  
end # Window_MenuCommand

#==============================================================================
# ■ Menu
#==============================================================================

module Menu
  
  #--------------------------------------------------------------------------
  # self.help_window_location
  #--------------------------------------------------------------------------
  def self.help_window_location
    return YEA::MENU::HELP_WINDOW_LOCATION
  end
  
  #--------------------------------------------------------------------------
  # self.command_window_align
  #--------------------------------------------------------------------------
  def self.command_window_align
    return YEA::MENU::COMMAND_WINDOW_ALIGN
  end
  
  #--------------------------------------------------------------------------
  # self.main_menu_align
  #--------------------------------------------------------------------------
  def self.main_menu_align
    return YEA::MENU::MAIN_MENU_ALIGN
  end
  
  #--------------------------------------------------------------------------
  # self.main_menu_right
  #--------------------------------------------------------------------------
  def self.main_menu_right
    return YEA::MENU::MAIN_MENU_RIGHT
  end
  
end # Menu

#==============================================================================
# ■ Game_Actor
#==============================================================================

class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # new method: draw_mp?
  #--------------------------------------------------------------------------
  def draw_mp?
    for skill in skills
      next unless added_skill_types.include?(skill.stype_id)
      return true if skill.mp_cost > 0
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_tp?
  #--------------------------------------------------------------------------
  def draw_tp?
    return false unless $data_system.opt_display_tp
    for skill in skills
      next unless added_skill_types.include?(skill.stype_id)
      return true if skill.tp_cost > 0
    end
    return false
  end
  
end # Game_Actor

#==============================================================================
# ■ Window_Base
#==============================================================================

class Window_Base < Window
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_simple_status
  #--------------------------------------------------------------------------
  def draw_actor_simple_status(actor, dx, dy)
    dy -= line_height / 2
    draw_actor_name(actor, dx, dy)
    draw_actor_level(actor, dx, dy + line_height * 1)
    draw_actor_icons(actor, dx, dy + line_height * 2)
    dw = contents.width - dx - 124
    draw_actor_class(actor, dx + 120, dy, dw)
    draw_actor_hp(actor, dx + 120, dy + line_height * 1, dw)
    if YEA::MENU::DRAW_TP_GAUGE && actor.draw_tp? && (!actor.draw_mp? || !YEA::MENU::DRAW_MP_GAUGE)
      draw_actor_tp(actor, dx + 120, dy + line_height * 2, dw)
    elsif YEA::MENU::DRAW_TP_GAUGE && YEA::MENU::DRAW_MP_GAUGE && actor.draw_tp? && actor.draw_mp?
      if $imported["YEA-BattleEngine"]
        draw_actor_tp(actor, dx + 120, dy + line_height * 2, dw/2 - 1)
        draw_actor_mp(actor, dx + 120 + dw/2, dy + (line_height * 2), dw/2 + 1)
      else
        draw_actor_mp(actor, dx + 120, dy + line_height * 2, dw/2 - 1)
        draw_actor_tp(actor, dx + 120 + dw/2, dy + line_height * 2, dw/2 + 1)
      end
    elsif YEA::MENU::DRAW_MP_GAUGE && actor.draw_mp?
      draw_actor_mp(actor, dx + 120, dy + line_height * 2, dw)
    end
    return unless $imported["YEA-JPManager"]
    draw_actor_jp(actor, dx + 120, dy, dw)
    
  end
  
end # Window_Base

#==============================================================================
# ■ Window_Command
#==============================================================================

class Window_Command < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: alignment
  #--------------------------------------------------------------------------
  def alignment
    return Menu.command_window_align
  end
  
end # Window_Command

#==============================================================================
# ■ Window_MenuCommand
#==============================================================================

class Window_MenuCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # alias method: init_command_position
  #--------------------------------------------------------------------------
  class <<self; alias init_command_position_ame init_command_position; end
  def self.init_command_position
    init_command_position_ame
    @@last_command_oy = nil
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number
    return [[item_max, YEA::MENU::MAIN_MENU_ROWS].min, 1].max
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: alignment
  #--------------------------------------------------------------------------
  def alignment
    return Menu.main_menu_align
  end
  
  #--------------------------------------------------------------------------
  # alias method: process_ok
  #--------------------------------------------------------------------------
  alias window_menucommand_process_ok_ame process_ok
  def process_ok
    @@last_command_oy = self.oy
    window_menucommand_process_ok_ame
  end
  
  #--------------------------------------------------------------------------
  # alias method: select_last
  #--------------------------------------------------------------------------
  alias window_menucommand_select_last_ame select_last
  def select_last
    window_menucommand_select_last_ame
    self.oy = @@last_command_oy unless @@last_command_oy.nil?
    @@last_command_oy = nil
  end
  
end # Window_MenuCommand

#==============================================================================
# ■ Scene_Menu
#==============================================================================

class Scene_Menu < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # alias method: start
  #--------------------------------------------------------------------------
  alias scene_menu_start_ame start
  def start
    scene_menu_start_ame
    relocate_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: relocate_windows
  #--------------------------------------------------------------------------
  def relocate_windows
    return unless Menu.main_menu_right
    @command_window.x = Graphics.width - @command_window.width
    @gold_window.x = Graphics.width - @gold_window.width
    @status_window.x = 0
  end
  
end # Scene_Menu

#==============================================================================
# ■ Scene_Item
#==============================================================================

class Scene_Item < Scene_ItemBase
  
  #--------------------------------------------------------------------------
  # alias method: start
  #--------------------------------------------------------------------------
  alias scene_item_start_ame start
  def start
    scene_item_start_ame
    return if $imported["YEA-ItemMenu"]
    relocate_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: relocate_windows
  #--------------------------------------------------------------------------
  def relocate_windows
    case Menu.help_window_location
    when 0 # Top
      @help_window.y = 0
      @category_window.y = @help_window.height
      @item_window.y = @category_window.y + @category_window.height
    when 1 # Middle
      @category_window.y = 0
      @help_window.y = @category_window.height
      @item_window.y = @help_window.y + @help_window.height
    else # Bottom
      @category_window.y = 0
      @item_window.y = @category_window.height
      @help_window.y = @item_window.y + @item_window.height
    end
    if $imported["YEA-ItemMenu"]
      @types_window.y = @category_window.y
      @status_window.y = @category_window.y
    end
  end
  
end # Scene_Item

#==============================================================================
# ■ Scene_Skill
#==============================================================================

class Scene_Skill < Scene_ItemBase
  
  #--------------------------------------------------------------------------
  # alias method: start
  #--------------------------------------------------------------------------
  alias scene_skill_start_ame start
  def start
    scene_skill_start_ame
    relocate_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: relocate_windows
  #--------------------------------------------------------------------------
  def relocate_windows
    case Menu.help_window_location
    when 0 # Top
      @help_window.y = 0
      @command_window.y = @help_window.height
      @status_window.y = @help_window.height
      @item_window.y = @status_window.y + @status_window.height
    when 1 # Middle
      @command_window.y = 0
      @status_window.y = 0
      @help_window.y = @status_window.y + @status_window.height
      @item_window.y = @help_window.y + @help_window.height
    else # Bottom
      @command_window.y = 0
      @status_window.y = 0
      @item_window.y = @status_window.y + @status_window.height
      @help_window.y = @item_window.y + @item_window.height
    end
  end
  
end # Scene_Skill

#==============================================================================
# ■ Scene_Equip
#==============================================================================

class Scene_Equip < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # alias method: start
  #--------------------------------------------------------------------------
  alias scene_equip_start_ame start
  def start
    scene_equip_start_ame
    relocate_windows
    relocate_aee_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: relocate_windows
  #--------------------------------------------------------------------------
  def relocate_windows
    return if $imported["YEA-AceEquipEngine"]
    case Menu.help_window_location
    when 0 # Top
      @help_window.y = 0
      @status_window.y = @help_window.height
      @command_window.y = @help_window.height
      @slot_window.y = @command_window.y + @command_window.height
      @item_window.y = @slot_window.y + @slot_window.height
    when 1 # Middle
      @status_window.y = 0
      @command_window.y = 0
      @slot_window.y = @command_window.y + @command_window.height
      @help_window.y = @slot_window.y + @slot_window.height
      @item_window.y = @help_window.y + @help_window.height
    else # Bottom
      @status_window.y = 0
      @command_window.y = 0
      @slot_window.y = @command_window.y + @command_window.height
      @item_window.y = @slot_window.y + @slot_window.height
      @help_window.y = @item_window.y + @item_window.height
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: relocate_aee_windows
  #--------------------------------------------------------------------------
  def relocate_aee_windows
    return unless $imported["YEA-AceEquipEngine"]
    case Menu.help_window_location
    when 0 # Top
      @help_window.y = 0
      @command_window.y = @help_window.height
      @slot_window.y = @command_window.y + @command_window.height
    when 1 # Middle
      @command_window.y = 0
      @help_window.y = @command_window.height
      @slot_window.y = @help_window.y + @help_window.height
    else # Bottom
      @command_window.y = 0
      @slot_window.y = @command_window.height
      @help_window.y = @slot_window.y + @slot_window.height
    end
    @actor_window.y = @command_window.y
    @item_window.y = @slot_window.y
    @status_window.y = @slot_window.y
  end
  
end # Scene_Equip

#==============================================================================
# ■ Scene_Menu
#==============================================================================

class Scene_Menu < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # alias method: create_command_window
  #--------------------------------------------------------------------------
  alias scene_menu_create_command_window_ame create_command_window
  def create_command_window
    scene_menu_create_command_window_ame
    process_common_event_commands
    process_custom_commands
  end
  
  #--------------------------------------------------------------------------
  # new method: process_common_event_commands
  #--------------------------------------------------------------------------
  def process_common_event_commands
    for command in YEA::MENU::COMMANDS
      next unless YEA::MENU::COMMON_EVENT_COMMANDS.include?(command)
      @command_window.set_handler(command, method(:command_common_event))
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: command_common_event
  #--------------------------------------------------------------------------
  def command_common_event
    event_id = @command_window.current_ext
    return return_scene if event_id.nil?
    return return_scene if $data_common_events[event_id].nil?
    $game_temp.reserve_common_event(event_id)
    return_scene
  end
  
  #--------------------------------------------------------------------------
  # new method: process_custom_commands
  #--------------------------------------------------------------------------
  def process_custom_commands
    for command in YEA::MENU::COMMANDS
      next unless YEA::MENU::CUSTOM_COMMANDS.include?(command)
      called_method = YEA::MENU::CUSTOM_COMMANDS[command][3]
      @command_window.set_handler(command, method(called_method))
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: command_debug
  #--------------------------------------------------------------------------
  def command_debug
    SceneManager.call(Scene_Debug)
  end
  
  #--------------------------------------------------------------------------
  # new method: command_shop
  #--------------------------------------------------------------------------
  def command_shop
    goods = []
    SceneManager.call(Scene_Shop)
    SceneManager.scene.prepare(goods, false)
  end
  
  #--------------------------------------------------------------------------
  # new method: command_totori
  #--------------------------------------------------------------------------
  def command_totori
    return unless $imported['KRX-AlchemicSynthesis']
    SceneManager.call(Scene_Alchemy)
  end
  
end # Scene_Menu

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - Ace Item Menu v1.02
# -- Last Updated: 2012.01.05
# -- Level: Normal, Hard
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-ItemMenu"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.05 - Compatibility Update with Equip Dynamic Stats.
# 2012.01.03 - Started Script and Finished.
#            - Compatibility Update with Ace Menu Engine.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# The Ace Item Menu offers more item categorization control and a better layout
# that simulatenously provides information regarding the items to the player,
# while keeping a good amount of the item list visible on screen at once. The
# script can also be customized to rearrange commands and categories.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Item Notetags - These notetags go in the item notebox in the database.
# -----------------------------------------------------------------------------
# <category: string>
# Places this object into the item category for "string". Whenever the selected
# category is highlighted in the Ace Item Menu command window, this object will
# be included and shown in the item window.
# 
# <image: string>
# Uses a picture from Graphics\Pictures\ of your RPG Maker VX Ace Project's
# directory with the filename of "string" (without the extension) as the image
# picture shown in the Ace Item Menu.
# 
# -----------------------------------------------------------------------------
# Weapon Notetags - These notetags go in the weapon notebox in the database.
# -----------------------------------------------------------------------------
# <category: string>
# Places this object into the item category for "string". Whenever the selected
# category is highlighted in the Ace Item Menu command window, this object will
# be included and shown in the item window.
# 
# <image: string>
# Uses a picture from Graphics\Pictures\ of your RPG Maker VX Ace Project's
# directory with the filename of "string" (without the extension) as the image
# picture shown in the Ace Item Menu.
# 
# -----------------------------------------------------------------------------
# Armour Notetags - These notetags go in the armour notebox in the database.
# -----------------------------------------------------------------------------
# <category: string>
# Places this object into the item category for "string". Whenever the selected
# category is highlighted in the Ace Item Menu command window, this object will
# be included and shown in the item window.
# 
# <image: string>
# Uses a picture from Graphics\Pictures\ of your RPG Maker VX Ace Project's
# directory with the filename of "string" (without the extension) as the image
# picture shown in the Ace Item Menu.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module ITEM
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Item Command Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This array adjusts what options appear in the initial item command window
    # before the items are split into separate categories. Add commands, remove
    # commands, or rearrange them. Here's a list of which does what:
    # 
    # -------------------------------------------------------------------------
    # :command         Description
    # -------------------------------------------------------------------------
    # :item            Opens up the various item categories. Default.
    # :weapon          Opens up the various weapon categories. Default.
    # :armor           Opens up the various armour categories. Default.
    # :key_item        Shows a list of the various key items. Default.
    # 
    # :gogototori      Requires Kread-EX's Go Go Totori Synthesis.
    # 
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMANDS =[
      :item,         # Opens up the various item categories. Default.
      :weapon,       # Opens up the various weapon categories. Default.
      :armor,        # Opens up the various armour categories. Default.
      :key_item,     # Shows a list of the various key items. Default.
      :gogototori,   # Requires Kread-EX's Go Go Totori Synthesis.
    # :custom1,      # Custom command 1.
    # :custom2,      # Custom command 2.
    ] # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Item Custom Commands -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # For those who use scripts to that may produce unique effects for the item
    # scene, use this hash to manage the custom commands for the Item Command
    # Window. You can disable certain commands or prevent them from appearing
    # by using switches. If you don't wish to bind them to a switch, set the
    # proper switch to 0 for it to have no impact.
    #--------------------------------------------------------------------------
    CUSTOM_ITEM_COMMANDS ={
    # :command => ["Display Name", EnableSwitch, ShowSwitch, Handler Method],
      :gogototori => ["Synthesis",            0,         0, :command_totori],
      :custom1 => [ "Custom Name",            0,          0, :command_name1],
      :custom2 => [ "Custom Text",           13,          0, :command_name2],
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Item Type Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These arrays adjusts and shows the various item types shown for Items,
    # Weapons, and Armours. Note that when using :category symbols, the
    # specific category shown will be equal to the text used for the Display
    # and the included item must contain a category equal to the Display name.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This array contains the order for the Item categories.
    ITEM_TYPES =[
    # [  :symbol,   "Display"],
      [   :field,     "Field"], # Shows Menu-usable items.
      [  :battle,    "Battle"], # Shows Battle-usable items.
      [:category,   "Special"], # Categorized by <category: string>
      [:category,"Ingredient"], # Categorized by <category: string>
      [:key_item,  "Key Item"], # Shows all key items.
      [     :all,       "All"], # Shows all usable items.
    ] # Do not remove this.
    
    # This array contains the order for the Weapon categories.
    WEAPON_TYPES =[
    # [  :symbol,   "Display"],
      [   :types,  "WPNTYPES"], # Lists all of the individual weapon types.
      [:category,  "Training"], # Categorized by <category: string>
      [:category, "Legendary"], # Categorized by <category: string>
      [     :all,       "All"], # Shows all weapons.
    ] # Do not remove this.
    
    # This array contains the order for the Armour categories.
    ARMOUR_TYPES =[
    # [  :symbol,   "Display"],
      [   :slots,  "ARMSLOTS"], # Lists all of the individual armour slots.
      [   :types,  "ARMTYPES"], # Lists all of the individual armours types.
      [:category,  "Training"], # Categorized by <category: string>
      [:category, "Legendary"], # Categorized by <category: string>
      [     :all,       "All"], # Shows all armours.
    ] # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Item Status Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The item status window displays information about the item in detail.
    # Adjust the settings below to change the way the status window appears.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    STATUS_FONT_SIZE = 20       # Font size used for status window.
    MAX_ICONS_DRAWN  = 10       # Maximum number of icons drawn for states.
    
    # The following adjusts the vocabulary used for the status window. Each
    # of the vocabulary settings are self explanatory.
    VOCAB_STATUS ={
      :empty      => "---",          # Text used when nothing is shown.
      :hp_recover => "HP Heal",      # Text used for HP Recovery.
      :mp_recover => "MP Heal",      # Text used for MP Recovery.
      :tp_recover => "TP Heal",      # Text used for TP Recovery.
      :tp_gain    => "TP Gain",      # Text used for TP Gain.
      :applies    => "Applies",      # Text used for applied states and buffs.
      :removes    => "Removes",      # Text used for removed states and buffs.
    } # Do not remove this.
    
  end # ITEM
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

module YEA
  module REGEXP
  module BASEITEM
    
    CATEGORY = /<(?:CATEGORIES|category):[ ](.*)>/i
    IMAGE    = /<(?:IMAGE|image):[ ](.*)>/i
    
  end # BASEITEM
  end # REGEXP
end # YEA

#==============================================================================
# ■ Numeric
#==============================================================================

class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric

#==============================================================================
# ■ Vocab
#==============================================================================

module Vocab
  
  #--------------------------------------------------------------------------
  # new method: self.item_status
  #--------------------------------------------------------------------------
  def self.item_status(type)
    return YEA::ITEM::VOCAB_STATUS[type]
  end
  
end # Vocab

#==============================================================================
# ■ DataManager
#==============================================================================

module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_aim load_database; end
  def self.load_database
    load_database_aim
    load_notetags_aim
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_aim
  #--------------------------------------------------------------------------
  def self.load_notetags_aim
    groups = [$data_items, $data_weapons, $data_armors]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_aim
      end
    end
  end
  
end # DataManager

#==============================================================================
# ■ RPG::BaseItem
#==============================================================================

class RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :category
  attr_accessor :image
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_aim
  #--------------------------------------------------------------------------
  def load_notetags_aim
    @category = []
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::BASEITEM::CATEGORY
        @category.push($1.upcase.to_s)
      when YEA::REGEXP::BASEITEM::IMAGE
        @image = $1.to_s
      end
    } # self.note.split
    #---
  end
  
end # RPG::BaseItem

#==============================================================================
# ■ Game_Temp
#==============================================================================

class Game_Temp
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :scene_item_index
  attr_accessor :scene_item_oy
  
end # Game_Temp

#==============================================================================
# ■ Window_ItemList
#==============================================================================

class Window_ItemList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    return if item.nil?
    rect = item_rect(index)
    rect.width -= 4
    draw_item_name(item, rect.x, rect.y, enable?(item), rect.width - 24)
    draw_item_number(rect, item)
  end
  
end # Window_ItemList

#==============================================================================
# ■ Window_ItemCommand
#==============================================================================

class Window_ItemCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_reader   :item_window
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(x, y)
    super(x, y)
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; return 4; end
  
  #--------------------------------------------------------------------------
  # process_ok
  #--------------------------------------------------------------------------
  def process_ok
    $game_temp.scene_item_index = index
    $game_temp.scene_item_oy = self.oy
    super
  end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    for command in YEA::ITEM::COMMANDS
      case command
      #--- Default Commands ---
      when :item
        add_command(Vocab::item, :item)
      when :weapon
        add_command(Vocab::weapon, :weapon)
      when :armor
        add_command(Vocab::armor, :armor)
      when :key_item
        add_command(Vocab::key_item, :key_item)
      #--- Imported ---
      when :gogototori
        next unless $imported["KRX-AlchemicSynthesis"]
        process_custom_command(command)
      #--- Custom Commands ---
      else
        process_custom_command(command)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # process_custom_command
  #--------------------------------------------------------------------------
  def process_custom_command(command)
    return unless YEA::ITEM::CUSTOM_ITEM_COMMANDS.include?(command)
    show = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][2]
    continue = show <= 0 ? true : $game_switches[show]
    return unless continue
    text = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][0]
    switch = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][1]
    enabled = switch <= 0 ? true : $game_switches[switch]
    add_command(text, command, enabled)
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return unless self.active
    @item_window.category = current_symbol if @item_window
  end
  
  #--------------------------------------------------------------------------
  # item_window=
  #--------------------------------------------------------------------------
  def item_window=(item_window)
    @item_window = item_window
    update
  end
  
end # Window_ItemCommand

#==============================================================================
# ■ Window_ItemType
#==============================================================================

class Window_ItemType < Window_Command
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_reader   :item_window
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(x, y)
    super(x, y)
    deactivate
    @type = nil
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; return 4; end
  
  #--------------------------------------------------------------------------
  # reveal
  #--------------------------------------------------------------------------
  def reveal(type)
    @type = type
    refresh
    activate
    select(0)
  end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    return if @type.nil?
    #---
    case @type
    when :item
      commands = YEA::ITEM::ITEM_TYPES
    when :weapon
      commands = YEA::ITEM::WEAPON_TYPES
    else
      commands = YEA::ITEM::ARMOUR_TYPES
    end
    #---
    for command in commands
      case command[0]
      #---
      when :types
        case @type
        when :weapon
          for i in 1...$data_system.weapon_types.size
            name = $data_system.weapon_types[i]
            add_command(name, :w_type, true, i)
          end
        else
          for i in 1...$data_system.armor_types.size
            name = $data_system.armor_types[i]
            add_command(name, :a_type, true, i)
          end
        end
      #---
      when :slots
        if $imported["YEA-AceEquipEngine"]
          maximum = 1
          for key in YEA::EQUIP::TYPES
            maximum = [maximum, key[0]].max
          end
        else
          maximum = 4
        end
        for i in 1..maximum
          name = Vocab::etype(i)
          add_command(name, :e_type, true, i) if name != ""
        end
      #---
      else
        add_command(command[1], command[0], true, @type)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return unless self.active
    @item_window.category = current_symbol if @item_window
  end
  
  #--------------------------------------------------------------------------
  # item_window=
  #--------------------------------------------------------------------------
  def item_window=(item_window)
    @item_window = item_window
    update
  end
  
end # Window_ItemType

#==============================================================================
# ■ Window_ItemList
#==============================================================================

class Window_ItemList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_itemlist_initialize_aim initialize
  def initialize(dx, dy, dw, dh)
    window_itemlist_initialize_aim(dx, dy, dw, dh)
    @ext = :none
    @name = ""
  end
  
  #--------------------------------------------------------------------------
  # alias method: category=
  #--------------------------------------------------------------------------
  alias window_itemlist_category_aim category=
  def category=(category)
    if @types_window.nil?
      window_itemlist_category_aim(category)
    else
      return unless update_types?(category)
      @category = category
      if @types_window.active
        @name = @types_window.current_data[:name]
        @ext = @types_window.current_ext
      end
      refresh
      self.oy = 0
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: update_types?
  #--------------------------------------------------------------------------
  def update_types?(category)
    return true if @category != category
    return false unless @types_window.active
    if category == :category
      return @name != @types_window.current_data[:name]
    end
    return @ext != @types_window.current_ext
  end
  
  #--------------------------------------------------------------------------
  # new method: types_window=
  #--------------------------------------------------------------------------
  def types_window=(window)
    @types_window = window
  end
  
  #--------------------------------------------------------------------------
  # alias method: include?
  #--------------------------------------------------------------------------
  alias window_itemlist_include_aim include?
  def include?(item)
    if @types_window.nil?
      return window_itemlist_include_aim(item)
    else
      return ace_item_menu_include?(item)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: ace_item_menu_include?
  #--------------------------------------------------------------------------
  def ace_item_menu_include?(item)
    case @category
    #---
    when :field
      return false unless item.is_a?(RPG::Item)
      return item.menu_ok?
    when :battle
      return false unless item.is_a?(RPG::Item)
      return item.battle_ok?
    #---
    when :w_type
      return false unless item.is_a?(RPG::Weapon)
      return item.wtype_id == @types_window.current_ext
    when :a_type
      return false unless item.is_a?(RPG::Armor)
      return item.atype_id == @types_window.current_ext
    when :e_type
      return false unless item.is_a?(RPG::Armor)
      return item.etype_id == @types_window.current_ext
    #---
    when :all
      case @types_window.current_ext
      when :item
        return item.is_a?(RPG::Item)
      when :weapon
        return item.is_a?(RPG::Weapon)
      else
        return item.is_a?(RPG::Armor)
      end
    #---
    when :category
      case @types_window.current_ext
      when :item
        return false unless item.is_a?(RPG::Item)
      when :weapon
        return false unless item.is_a?(RPG::Weapon)
      else
        return false unless item.is_a?(RPG::Armor)
      end
      return item.category.include?(@types_window.current_data[:name].upcase)
    #---
    else
      return window_itemlist_include_aim(item)
    end
  end
  
end # Window_ItemList

#==============================================================================
# ■ Window_ItemStatus
#==============================================================================

class Window_ItemStatus < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, item_window)
    super(dx, dy, Graphics.width - dx, fitting_height(4))
    @item_window = item_window
    @item = nil
    refresh
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    update_item(@item_window.item)
  end
  
  #--------------------------------------------------------------------------
  # update_item
  #--------------------------------------------------------------------------
  def update_item(item)
    return if @item == item
    @item = item
    refresh
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    return draw_empty if @item.nil?
    contents.font.size = YEA::ITEM::STATUS_FONT_SIZE
    draw_item_image
    draw_item_stats
    draw_item_effects
  end
  
  #--------------------------------------------------------------------------
  # draw_empty
  #--------------------------------------------------------------------------
  def draw_empty
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(1, 1, 94, 94)
    contents.fill_rect(rect, colour)
    dx = 96; dy = 0
    dw = (contents.width - 96) / 2
    for i in 0...8
      draw_background_box(dx, dy, dw)
      dx = dx >= 96 + dw ? 96 : 96 + dw
      dy += line_height if dx == 96
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_background_box
  #--------------------------------------------------------------------------
  def draw_background_box(dx, dy, dw)
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw-2, line_height-2)
    contents.fill_rect(rect, colour)
  end
  
  #--------------------------------------------------------------------------
  # draw_item_image
  #--------------------------------------------------------------------------
  def draw_item_image
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(1, 1, 94, 94)
    contents.fill_rect(rect, colour)
    if @item.image.nil?
      icon_index = @item.icon_index
      bitmap = Cache.system("Iconset")
      rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
      target = Rect.new(0, 0, 96, 96)
      contents.stretch_blt(target, bitmap, rect)
    else
      bitmap = Cache.picture(@item.image)
      contents.blt(0, 0, bitmap, bitmap.rect, 255)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_item_stats
  #--------------------------------------------------------------------------
  def draw_item_stats
    return unless @item.is_a?(RPG::Weapon) || @item.is_a?(RPG::Armor)
    dx = 96; dy = 0
    dw = (contents.width - 96) / 2
    for i in 0...8
      draw_equip_param(i, dx, dy, dw)
      dx = dx >= 96 + dw ? 96 : 96 + dw
      dy += line_height if dx == 96
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_equip_param
  #--------------------------------------------------------------------------
  def draw_equip_param(param_id, dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::param(param_id))
    if $imported["YEA-EquipDynamicStats"]
      draw_percentage_param(param_id, dx, dy, dw)
    else
      draw_set_param(param_id, dx, dy, dw)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_percentage_param
  #--------------------------------------------------------------------------
  def draw_percentage_param(param_id, dx, dy, dw)
    if @item.per_params[param_id] != 0 && @item.params[param_id] != 0
      text = draw_set_param(param_id, dx, dy, dw)
      dw -= text_size(text).width
      draw_percent_param(param_id, dx, dy, dw)
    elsif @item.per_params[param_id] != 0 && @item.params[param_id] == 0
      draw_percent_param(param_id, dx, dy, dw)
    else
      draw_set_param(param_id, dx, dy, dw)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_set_param
  #--------------------------------------------------------------------------
  def draw_set_param(param_id, dx, dy, dw)
    value = @item.params[param_id]
    if $imported["YEA-EquipDynamicStats"] && @item.var_params[param_id] > 0
      value += $game_variables[@item.var_params[param_id]] rescue 0
    end
    change_color(param_change_color(value), value != 0)
    text = value.group
    text = "+" + text if value > 0
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
    return text
  end
  
  #--------------------------------------------------------------------------
  # draw_percent_param
  #--------------------------------------------------------------------------
  def draw_percent_param(param_id, dx, dy, dw)
    value = @item.per_params[param_id]
    change_color(param_change_color(value))
    text = (@item.per_params[param_id] * 100).to_i.group + "%"
    text = "+" + text if @item.per_params[param_id] > 0
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
    return text
  end
  
  #--------------------------------------------------------------------------
  # draw_item_effects
  #--------------------------------------------------------------------------
  def draw_item_effects
    return unless @item.is_a?(RPG::Item)
    dx = 96; dy = 0
    dw = (contents.width - 96) / 2
    draw_hp_recover(dx, dy + line_height * 0, dw)
    draw_mp_recover(dx, dy + line_height * 1, dw)
    draw_tp_recover(dx + dw, dy + line_height * 0, dw)
    draw_tp_gain(dx + dw, dy + line_height * 1, dw)
    dw = contents.width - 96
    draw_applies(dx, dy + line_height * 2, dw)
    draw_removes(dx, dy + line_height * 3, dw)
  end
  
  #--------------------------------------------------------------------------
  # draw_hp_recover
  #--------------------------------------------------------------------------
  def draw_hp_recover(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:hp_recover))
    per = 0
    set = 0
    for effect in @item.effects
      next unless effect.code == 11
      per += (effect.value1 * 100).to_i
      set += effect.value2.to_i
    end
    if per != 0 && set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      dw -= text_size(text).width
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      return
    elsif per != 0
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
    elsif set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_mp_recover
  #--------------------------------------------------------------------------
  def draw_mp_recover(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:mp_recover))
    per = 0
    set = 0
    for effect in @item.effects
      next unless effect.code == 12
      per += (effect.value1 * 100).to_i
      set += effect.value2.to_i
    end
    if per != 0 && set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      dw -= text_size(text).width
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      return
    elsif per != 0
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
    elsif set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_tp_recover
  #--------------------------------------------------------------------------
  def draw_tp_recover(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:tp_recover))
    set = 0
    for effect in @item.effects
      next unless effect.code == 13
      set += effect.value1.to_i
    end
    if set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_tp_gain
  #--------------------------------------------------------------------------
  def draw_tp_gain(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:tp_gain))
    set = @item.tp_gain
    if set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_applies
  #--------------------------------------------------------------------------
  def draw_applies(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:applies))
    icons = []
    for effect in @item.effects
      case effect.code
      when 21
        next unless effect.value1 > 0
        next if $data_states[effect.value1].nil?
        icons.push($data_states[effect.data_id].icon_index)
      when 31
        icons.push($game_actors[1].buff_icon_index(1, effect.data_id))
      when 32
        icons.push($game_actors[1].buff_icon_index(-1, effect.data_id))
      end
      icons.delete(0)
      break if icons.size >= YEA::ITEM::MAX_ICONS_DRAWN
    end
    draw_icons(dx, dy, dw, icons)
  end
  
  #--------------------------------------------------------------------------
  # draw_removes
  #--------------------------------------------------------------------------
  def draw_removes(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:removes))
    icons = []
    for effect in @item.effects
      case effect.code
      when 22
        next unless effect.value1 > 0
        next if $data_states[effect.value1].nil?
        icons.push($data_states[effect.data_id].icon_index)
      when 33
        icons.push($game_actors[1].buff_icon_index(1, effect.data_id))
      when 34
        icons.push($game_actors[1].buff_icon_index(-1, effect.data_id))
      end
      icons.delete(0)
      break if icons.size >= YEA::ITEM::MAX_ICONS_DRAWN
    end
    draw_icons(dx, dy, dw, icons)
  end
  
  #--------------------------------------------------------------------------
  # draw_icons
  #--------------------------------------------------------------------------
  def draw_icons(dx, dy, dw, icons)
    dx += dw - 4
    dx -= icons.size * 24
    for icon_id in icons
      draw_icon(icon_id, dx, dy)
      dx += 24
    end
    if icons.size == 0
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
      draw_text(4, dy, contents.width-8, line_height, text, 2)
    end
  end
  
end # Window_ItemStatus

#==============================================================================
# ■ Scene_Item
#==============================================================================

class Scene_Item < Scene_ItemBase
  
  #--------------------------------------------------------------------------
  # alias method: start
  #--------------------------------------------------------------------------
  alias scene_item_start_aim start
  def start
    scene_item_start_aim
    create_types_window
    create_status_window
    relocate_windows
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: return_scene
  #--------------------------------------------------------------------------
  def return_scene
    $game_temp.scene_item_index = nil
    $game_temp.scene_item_oy = nil
    super
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_category_window
  #--------------------------------------------------------------------------
  def create_category_window
    wy = @help_window.height
    @category_window = Window_ItemCommand.new(0, wy)
    @category_window.viewport = @viewport
    @category_window.help_window = @help_window
    @category_window.y = @help_window.height
    if !$game_temp.scene_item_index.nil?
      @category_window.select($game_temp.scene_item_index)
      @category_window.oy = $game_temp.scene_item_oy
    end
    $game_temp.scene_item_index = nil
    $game_temp.scene_item_oy = nil
    @category_window.set_handler(:ok, method(:on_category_ok))
    @category_window.set_handler(:cancel, method(:return_scene))
    @category_window.set_handler(:item, method(:open_types))
    @category_window.set_handler(:weapon, method(:open_types))
    @category_window.set_handler(:armor, method(:open_types))
    process_custom_item_commands
  end
  
  #--------------------------------------------------------------------------
  # new method: process_custom_item_commands
  #--------------------------------------------------------------------------
  def process_custom_item_commands
    for command in YEA::ITEM::COMMANDS
      next unless YEA::ITEM::CUSTOM_ITEM_COMMANDS.include?(command)
      called_method = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][3]
      @category_window.set_handler(command, method(called_method))
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: create_types_window
  #--------------------------------------------------------------------------
  def create_types_window
    wy = @category_window.y
    @types_window = Window_ItemType.new(Graphics.width, wy)
    @types_window.viewport = @viewport
    @types_window.help_window = @help_window
    @types_window.y = @help_window.height
    @types_window.item_window = @item_window
    @item_window.types_window = @types_window
    @types_window.set_handler(:ok, method(:on_types_ok))
    @types_window.set_handler(:cancel, method(:on_types_cancel))
  end
  
  #--------------------------------------------------------------------------
  # new method: create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    wx = @category_window.width
    wy = @category_window.y
    @status_window = Window_ItemStatus.new(wx, wy, @item_window)
    @status_window.viewport = @viewport
  end
  
  #--------------------------------------------------------------------------
  # new method: relocate_windows
  #--------------------------------------------------------------------------
  def relocate_windows
    return unless $imported["YEA-AceMenuEngine"]
    case Menu.help_window_location
    when 0 # Top
      @help_window.y = 0
      @category_window.y = @help_window.height
      @item_window.y = @category_window.y + @category_window.height
    when 1 # Middle
      @category_window.y = 0
      @help_window.y = @category_window.height
      @item_window.y = @help_window.y + @help_window.height
    else # Bottom
      @category_window.y = 0
      @item_window.y = @category_window.height
      @help_window.y = @item_window.y + @item_window.height
    end
    @types_window.y = @category_window.y
    @status_window.y = @category_window.y
  end
  
  #--------------------------------------------------------------------------
  # new method: open_categories
  #--------------------------------------------------------------------------
  def open_types
    @category_window.x = Graphics.width
    @types_window.x = 0
    @types_window.reveal(@category_window.current_symbol)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_types_ok
  #--------------------------------------------------------------------------
  def on_types_ok
    @item_window.activate
    @item_window.select_last
  end
  
  #--------------------------------------------------------------------------
  # new method: on_types_cancel
  #--------------------------------------------------------------------------
  def on_types_cancel
    @category_window.x = 0
    @category_window.activate
    @types_window.unselect
    @types_window.x = Graphics.width
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_item_cancel
  #--------------------------------------------------------------------------
  alias scene_item_on_item_cancel_aim on_item_cancel
  def on_item_cancel
    if @types_window.x <= 0
      @item_window.unselect
      @types_window.activate
    else
      scene_item_on_item_cancel_aim
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: command_totori
  #--------------------------------------------------------------------------
  def command_totori
    SceneManager.call(Scene_Alchemy)
  end
  
  #--------------------------------------------------------------------------
  # new method: command_name1
  #--------------------------------------------------------------------------
  def command_name1
    # Do nothing.
  end
  
  #--------------------------------------------------------------------------
  # new method: command_name2
  #--------------------------------------------------------------------------
  def command_name2
    # Do nothing.
  end
  
end # Scene_Item

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - Party System v1.08
# -- Last Updated: 2012.01.23
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-PartySystem"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.23 - Bug fixed: Party members are now rearranged when newly added.
# 2012.01.14 - New Feature: Maximum Battle Members Variable added.
# 2012.01.07 - Bug fixed: Error with removing members.
# 2012.01.05 - Bug fixed: Escape skill/item effects no longer counts as death.
# 2011.12.26 - Compatibility Update: New Game+
# 2011.12.17 - Updated Spriteset_Battle to have updated sprite counts.
# 2011.12.13 - Updated to provide better visual display when more than 5 pieces
#              of equipment are equipped on an actor at a time.
# 2011.12.05 - Added functionality to display faces in the Party Select Window.
#            - Fixed bug that doesn't refresh the caterpillar when new members
#              join the party.
# 2011.12.04 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# RPG Maker VX Ace comes with a very nice party system. However, changing the
# maximum number of members isn't possible without the aid of a script. This
# script enables you the ability to change the maximum number of party members,
# change EXP rates, and/or open up a separate party menu (if desired). In
# addition to that, you can lock the position of actors within a party and
# require other actors to be in the active party before continuing.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Script Calls - These commands are used with script calls.
# -----------------------------------------------------------------------------
# *IMPORTANT* These script calls require the new party menu to be enabled to
# use them. Otherwise, nothing will happen.
# 
# lock_actor(x)
# unlock_actor(x)
# This will lock actor x in its current position in the party if the actor is
# in the current party. The actor is unable to switch position and must remain
# in that position until the lock is removed. Use the unlock script call to
# remove the locked status. This script requires the actor to have joined and
# in the current party before the script call will work.
# 
# require_actor(x)
# unrequire_actor(x)
# This will cause the party to require actor x in order to continue. If the
# actor isn't in the current party but is in the reserve party, the party menu
# will open up and prompt the player to add the required actor into the party
# before being able to continue. This script call will not function unless the
# specific actor has joined the party, whether it is in the current or reserve.
# 
# call_party_menu
# This will open up the party menu. This script call requires for the party
# menu to be enabled to use.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module PARTY
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Party Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # In this section, you can adjust the general party settings for your game
    # such as the maximum amount of members and whatnot, the EXP rate for
    # party members in the reserve, etc.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    MAX_BATTLE_MEMBERS   = 6      # Maximum party members. Default: 4
    SPLIT_EXP            = false  # Splits EXP with more members in the party.
    RESERVE_EXP_RATE     = 0.50   # Reserve EXP Rate. Default: 1.00
    
    # If you wish to be able to change the maximum number of battle members
    # during the middle of your game, set this constant to a variable ID. If
    # that variable ID is a number greater than 0, that variable will determine
    # the current maximum number of battle members. Be cautious about using
    # this during battle.
    MAX_MEMBERS_VARIABLE = 2
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Party Menu Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section contains various menu settings for those who wish to use a
    # menu separate for the party system. Here, adjust the menu command order,
    # icons used, and other settings.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ENABLE_MENU = true   # Enables party menu. Default: false
    COMMANDS =[          # The order at which the menu items are shown.
    # [:command,  "Display"],
      [ :change,  "Change",],
      [ :remove,  "Remove",],
      [ :revert,  "Revert",],
      [ :finish,  "Finish",],
    ] # Do not remove this.
    COMMAND_ALIGN    = 1     # 0:Left Align, 1:Center Align, 2:Right Align
    
    # These settings here are used for the upper right window: the Party Select
    # window where the player selects a member to swap out or remove.
    PARTY_FONT_SIZE  = 20    # Font size used for party member names.
    LOCK_FIRST_ACTOR = false # Lock the first actor by default?
    LOCKED_ICON      = 125   # Icon used for locked members.
    REQUIRED_ICON    = 126   # Icon used for required members.
    EMPTY_TEXT = "-Empty-"   # Text used when a member isn't present.
    DISPLAY_FACE     = true # Display faces instead of sprites?
    
    # These settings here are used for the lower left window: the Party List
    # window where the player selects a member to replace.
    REMOVE_ICON      = 185          # Icon used for removing members.
    REMOVE_TEXT      = "-Remove-"   # Text used for remove member command.
    ACTOR_Y_BUFFER   = 12           # Amount the actor graphic be adjusted by.
    
    # These settings here are used for the lower right window: the Party Status
    # window where info about a selected actor is shown.
    NO_DATA         = "- No Data -" # Text used for when no actor is shown.
    IN_PARTY_COLOUR = 6             # Text colour used for in party members.
    STAT_FONT_SIZE  = 20            # Font size used for stats.
    EQUIP_TEXT      = "Equipment"   # Text used to display equipment.
    
  end # PARTY
end # YEA

#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

#==============================================================================
# ■ Icon
#==============================================================================

module Icon
  
  #--------------------------------------------------------------------------
  # self.locked_party
  #--------------------------------------------------------------------------
  def self.locked_party; return YEA::PARTY::LOCKED_ICON; end
  
  #--------------------------------------------------------------------------
  # self.required_party
  #--------------------------------------------------------------------------
  def self.required_party; return YEA::PARTY::REQUIRED_ICON; end
  
  #--------------------------------------------------------------------------
  # self.remove_party
  #--------------------------------------------------------------------------
  def self.remove_party; return YEA::PARTY::REMOVE_ICON; end
    
end # Icon

#==============================================================================
# ■ Variable
#==============================================================================

module Variable
  
  #--------------------------------------------------------------------------
  # self.max_battle_members
  #--------------------------------------------------------------------------
  def self.max_battle_members
    default = YEA::PARTY::MAX_BATTLE_MEMBERS
    return default if YEA::PARTY::MAX_MEMBERS_VARIABLE <= 0
    return default if $game_variables[YEA::PARTY::MAX_MEMBERS_VARIABLE] <= 0
    return $game_variables[YEA::PARTY::MAX_MEMBERS_VARIABLE]
  end
  
end # Variable

#==============================================================================
# ■ Numeric
#==============================================================================

class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric

#==============================================================================
# ■ Game_Actor
#==============================================================================

class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :locked
  attr_accessor :required
  
  #--------------------------------------------------------------------------
  # alias method: setup
  #--------------------------------------------------------------------------
  alias game_actor_setup_ps setup
  def setup(actor_id)
    game_actor_setup_ps(actor_id)
    @locked = false
    @required = false
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: final_exp_rate
  #--------------------------------------------------------------------------
  def final_exp_rate
    n = exr * (battle_member? ? 1 : reserve_members_exp_rate)
    if $game_party.in_battle
      n /= [$game_party.battle_members.size, 1].max if YEA::PARTY::SPLIT_EXP
    end
    return n
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: reserve_members_exp_rate
  #--------------------------------------------------------------------------
  def reserve_members_exp_rate
    $data_system.opt_extra_exp ? YEA::PARTY::RESERVE_EXP_RATE : 0
  end
  
end # Game_Actor

#==============================================================================
# ■ Game_Party
#==============================================================================

class Game_Party < Game_Unit
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :battle_members_array
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias game_party_initialize_ps initialize
  def initialize
    game_party_initialize_ps
    @battle_members_array = nil
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: max_battle_members
  #--------------------------------------------------------------------------
  def max_battle_members; return Variable.max_battle_members; end
  
  #--------------------------------------------------------------------------
  # alias method: setup_starting_members
  #--------------------------------------------------------------------------
  alias setup_starting_members_ps setup_starting_members
  def setup_starting_members
    setup_starting_members_ps
    initialize_battle_members
    return unless YEA::PARTY::LOCK_FIRST_ACTOR
    return if members[0].nil?
    members[0].locked = true
  end
  
  #--------------------------------------------------------------------------
  # alias method: setup_battle_test_members
  #--------------------------------------------------------------------------
  alias setup_battle_test_members_ps setup_battle_test_members
  def setup_battle_test_members
    setup_battle_test_members_ps
    return unless YEA::PARTY::LOCK_FIRST_ACTOR
    return if members[0].nil?
    members[0].locked = true
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: battle_members
  #--------------------------------------------------------------------------
  def battle_members
    initialize_battle_members if initialize_battle_members?
    array = []
    for actor_id in @battle_members_array
      break if array.size > max_battle_members
      next if actor_id.nil?
      next if $game_actors[actor_id].nil?
      next unless $game_actors[actor_id].exist?
      array.push($game_actors[actor_id])
    end
    return array
  end
  
  #--------------------------------------------------------------------------
  # new method: initialize_battle_members?
  #--------------------------------------------------------------------------
  def initialize_battle_members?
    return true if @battle_members_array.nil?
    return @battle_members_array.size != max_battle_members
  end
  
  #--------------------------------------------------------------------------
  # new method: initialize_battle_members
  #--------------------------------------------------------------------------
  def initialize_battle_members
    @battle_members_array = []
    for i in 0...max_battle_members
      @battle_members_array.push(@actors[i]) unless @actors[i].nil?
      @battle_members_array.push(0) if @actors[i].nil?
    end
    $game_player.refresh
  end
  
  #--------------------------------------------------------------------------
  # alias method: add_actor
  #--------------------------------------------------------------------------
  alias game_party_add_actor_ps add_actor
  def add_actor(actor_id)
    game_party_add_actor_ps(actor_id)
    return if @battle_members_array.include?(actor_id)
    return unless @battle_members_array.include?(0)
    index = @battle_members_array.index(0)
    @battle_members_array[index] = actor_id
    $game_player.refresh
    $game_map.need_refresh = true
    rearrange_actors
  end
  
  #--------------------------------------------------------------------------
  # alias method: remove_actor
  #--------------------------------------------------------------------------
  alias game_party_remove_actor_ps remove_actor
  def remove_actor(actor_id)
    game_party_remove_actor_ps(actor_id)
    return unless @battle_members_array.include?(actor_id)
    index = @battle_members_array.index(actor_id)
    @battle_members_array[index] = 0
    $game_player.refresh
    $game_map.need_refresh = true
    rearrange_actors
  end
  
  #--------------------------------------------------------------------------
  # new method: rearrange_actors
  #--------------------------------------------------------------------------
  def rearrange_actors
    initialize_battle_members if @battle_members_array.nil?
    array = []
    for actor_id in @battle_members_array
      next if [0, nil].include?(actor_id)
      next if $game_actors[actor_id].nil?
      array.push(actor_id)
    end
    for actor_id in @actors
      next if array.include?(actor_id)
      next if $game_actors[actor_id].nil?
      array.push(actor_id)
    end
    @actors = array
  end
  
end # Game_Party

#==============================================================================
# ■ Game_Interpreter
#==============================================================================

class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # new method: lock_actor
  #--------------------------------------------------------------------------
  def lock_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    actor = $game_actors[actor_id]
    return unless $game_party.battle_members.include?(actor)
    actor.locked = true
  end
  
  #--------------------------------------------------------------------------
  # new method: unlock_actor
  #--------------------------------------------------------------------------
  def unlock_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    actor = $game_actors[actor_id]
    return unless $game_party.battle_members.include?(actor)
    actor.locked = false
  end
  
  #--------------------------------------------------------------------------
  # new method: require_actor
  #--------------------------------------------------------------------------
  def require_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    return if $game_system.formation_disabled
    actor = $game_actors[actor_id]
    return unless $game_party.all_members.include?(actor)
    actor.required = true
    call_party_menu unless $game_party.battle_members.include?(actor)
  end
  
  #--------------------------------------------------------------------------
  # new method: unrequire_actor
  #--------------------------------------------------------------------------
  def unrequire_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    return if $game_system.formation_disabled
    actor = $game_actors[actor_id]
    return unless $game_party.all_members.include?(actor)
    actor.required = false
    call_party_menu unless $game_party.battle_members.include?(actor)
  end
  
  #--------------------------------------------------------------------------
  # new method: call_party_menu
  #--------------------------------------------------------------------------
  def call_party_menu
    return unless YEA::PARTY::ENABLE_MENU
    return if $game_system.formation_disabled
    SceneManager.call(Scene_Party)
  end
  
end # Game_Interpreter

#==============================================================================
# ■ Spriteset_Battle
#==============================================================================

class Spriteset_Battle
  
  #--------------------------------------------------------------------------
  # overwrite method: create_actors
  #--------------------------------------------------------------------------
  def create_actors
    total = $game_party.max_battle_members
    @actor_sprites = Array.new(total) { Sprite_Battler.new(@viewport1) }
  end
  
end # Spriteset_Battle

#==============================================================================
# ■ Window_PartyMenuCommand
#==============================================================================

class Window_PartyMenuCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; 4; end
  
  #--------------------------------------------------------------------------
  # alignment
  #--------------------------------------------------------------------------
  def alignment
    return Menu.command_window_align if $imported["YEA-AceMenuEngine"]
    return YEA::PARTY::COMMAND_ALIGN
  end
  
  #--------------------------------------------------------------------------
  # scene
  #--------------------------------------------------------------------------
  def scene; return SceneManager.scene; end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    for command in YEA::PARTY::COMMANDS
      case command[0]
      when :change, :remove, :revert
        add_command(command[1], command[0])
      when :finish
        add_command(command[1], command[0], enable_cancel?)
      else; next
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # process_cancel
  #--------------------------------------------------------------------------
  def process_cancel
    unless enable_cancel?
      Sound.play_buzzer
      return
    end
    super
  end
  
  #--------------------------------------------------------------------------
  # in_party?
  #--------------------------------------------------------------------------
  def in_party?(actor)
    return $game_party.battle_members.include?(actor)
  end
  
  #--------------------------------------------------------------------------
  # enable_cancel?
  #--------------------------------------------------------------------------
  def enable_cancel?
    return false if $game_party.battle_members.size <= 0
    for actor in $game_party.all_members
      next if in_party?(actor)
      return false if actor.required
      return false if actor.locked
    end
    return true
  end
  
end # Window_PartyMenuCommand

#==============================================================================
# ■ Window_PartySelect
#==============================================================================

class Window_PartySelect < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #-------------------------------------------------------------------------
  def initialize(command_window)
    @command_window = command_window
    super(160, 0, window_width, fitting_height(visible_line_number))
    select(0)
    deactivate
    refresh
  end
  
  #--------------------------------------------------------------------------
  # col_max
  #--------------------------------------------------------------------------
  def col_max; return $game_party.max_battle_members; end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return $game_party.max_battle_members; end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return Graphics.width - 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; 4; end
  
  #--------------------------------------------------------------------------
  # item_rect
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = contents.width / item_max
    rect.height = contents.height
    rect.x = index * rect.width
    rect.y = 0
    return rect
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    make_item_list
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # make_item_list
  #--------------------------------------------------------------------------
  def make_item_list
    @data = $game_party.battle_members_array.clone
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    actor = $game_actors[@data[index]]
    rect = item_rect(index)
    if actor.nil?
      draw_empty(rect.clone)
      return
    end
    dx = rect.width / 2
    dy = rect.height - 16
    draw_actor_face(actor, rect.x, rect.y) if display_face?
    draw_actor_graphic(actor, rect.x + dx, rect.y + dy) unless display_face?
    draw_actor_name(actor, rect)
    draw_locked_icon(actor, rect)
    draw_required_icon(actor, rect)
  end
  
  #--------------------------------------------------------------------------
  # display_face?
  #--------------------------------------------------------------------------
  def display_face?
    return YEA::PARTY::DISPLAY_FACE
  end
  
  #--------------------------------------------------------------------------
  # draw_empty
  #--------------------------------------------------------------------------
  def draw_empty(rect)
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect.x += 2
    rect.y += 2
    rect.width -= 4
    rect.height -= 4
    contents.fill_rect(rect, colour)
    reset_font_settings
    change_color(system_color)
    text = YEA::PARTY::EMPTY_TEXT
    draw_text(rect, text, 1)
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_name
  #--------------------------------------------------------------------------
  def draw_actor_name(actor, rect)
    contents.font.size = YEA::PARTY::PARTY_FONT_SIZE
    change_color(normal_color, actor.exist?)
    draw_text(rect.x+4, rect.y, rect.width-8, line_height, actor.name, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_face
  #--------------------------------------------------------------------------
  def draw_face(face_name, face_index, dx, dy, enabled = true)
    bitmap = Cache.face(face_name)
    dw = [96, item_rect(0).width-4].min
    rect = Rect.new(face_index % 4 * 96, face_index / 4 * 96, dw, 92)
    contents.blt(dx+2, dy+2, bitmap, rect, enabled ? 255 : translucent_alpha)
    bitmap.dispose
  end
  
  #--------------------------------------------------------------------------
  # draw_locked_icon
  #--------------------------------------------------------------------------
  def draw_locked_icon(actor, rect)
    return unless actor_locked?(actor)
    draw_icon(Icon.locked_party, rect.x+rect.width-26, rect.height - 26)
  end
  
  #--------------------------------------------------------------------------
  # draw_required_icon
  #--------------------------------------------------------------------------
  def draw_required_icon(actor, rect)
    return if actor_locked?(actor)
    return unless actor_required?(actor)
    draw_icon(Icon.required_party, rect.x+rect.width-26, rect.height - 26)
  end
  
  #--------------------------------------------------------------------------
  # actor_locked?
  #--------------------------------------------------------------------------
  def actor_locked?(actor); return actor.locked; end
  
  #--------------------------------------------------------------------------
  # actor_required?
  #--------------------------------------------------------------------------
  def actor_required?(actor)
    return false if actor.locked
    return actor.required
  end
  
  #--------------------------------------------------------------------------
  # current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?; enable?(@data[index]); end
  
  #--------------------------------------------------------------------------
  # enable?
  #--------------------------------------------------------------------------
  def enable?(item)
    case @command_window.current_symbol
    when :change
      return true if item.nil?
      return true if item == 0
    when :remove
      return false if item.nil?
      return false if item == 0
    end
    actor = $game_actors[item]
    return false if actor.locked
    return false if actor.required
    return true
  end
  
  #--------------------------------------------------------------------------
  # process_handling
  #--------------------------------------------------------------------------
  def process_handling
    return unless open? && active
    return process_ok       if ok_enabled?        && Input.trigger?(:C)
    return process_cancel   if cancel_enabled?    && Input.trigger?(:B)
    return process_pagedown if handle?(:pagedown) && Input.repeat?(:R)
    return process_pageup   if handle?(:pageup)   && Input.repeat?(:L)
  end
  
  #--------------------------------------------------------------------------
  # cur_actor
  #--------------------------------------------------------------------------
  def cur_actor
    actor_id = @data[index]
    return $game_actors[actor_id]
  end
  
  #--------------------------------------------------------------------------
  # prev_actor
  #--------------------------------------------------------------------------
  def prev_actor
    id = index == 0 ? @data.size - 1 : index - 1
    actor_id = @data[id]
    return $game_actors[actor_id]
  end
  
  #--------------------------------------------------------------------------
  # next_actor
  #--------------------------------------------------------------------------
  def next_actor
    id = index == @data.size - 1 ? 0 : index + 1
    actor_id = @data[id]
    return $game_actors[actor_id]
  end
  
  #--------------------------------------------------------------------------
  # process_pageup
  #--------------------------------------------------------------------------
  def process_pageup
    allow = true
    allow = false if !prev_actor.nil? && prev_actor.locked
    allow = false if !cur_actor.nil? && cur_actor.locked
    Sound.play_buzzer unless allow
    if allow
      super
      activate
      select(index == 0 ? @data.size - 1 : index - 1)
    end
  end
  
  #--------------------------------------------------------------------------
  # process_pagedown
  #--------------------------------------------------------------------------
  def process_pagedown
    allow = true
    allow = false if !next_actor.nil? && next_actor.locked
    allow = false if !cur_actor.nil? && cur_actor.locked
    Sound.play_buzzer unless allow
    if allow
      super
      activate
      select(index == @data.size - 1 ? 0 : index + 1)
    end
  end
  
  #--------------------------------------------------------------------------
  # item
  #--------------------------------------------------------------------------
  def item; return @data[index]; end
  
end # Window_PartySelect

#==============================================================================
# ■ Window_PartyList
#==============================================================================

class Window_PartyList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #-------------------------------------------------------------------------
  def initialize(party_window)
    super(0, fitting_height(4), window_width, window_height)
    @party_window = party_window
    select(1)
    deactivate
    refresh
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 200; end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height; return Graphics.height - fitting_height(4); end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return @data ? @data.size : 1; end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    make_item_list
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # make_item_list
  #--------------------------------------------------------------------------
  def make_item_list
    @data = [0]
    for member in $game_party.all_members
      next if member.nil?
      @data.push(member.id)
    end
    @data.push(0)
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    clear_item(index)
    rect = item_rect(index)
    if @data[index] == 0
      draw_remove(rect)
      return
    end
    actor = $game_actors[@data[index]]
    draw_actor(actor, rect)
    draw_actor_locked(actor, rect)
    draw_actor_required(actor, rect)
  end
  
  #--------------------------------------------------------------------------
  # draw_remove
  #--------------------------------------------------------------------------
  def draw_remove(rect)
    reset_font_settings
    draw_icon(Icon.remove_party, rect.x+4, rect.y)
    text = YEA::PARTY::REMOVE_TEXT
    draw_text(rect.x+32, rect.y, rect.width-32, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor
  #--------------------------------------------------------------------------
  def draw_actor(actor, rect)
    buffer = YEA::PARTY::ACTOR_Y_BUFFER
    draw_actor_graphic(actor, rect.x + 16, rect.y + rect.height + buffer)
    text = actor.name
    change_color(list_colour(actor), enabled?(actor))
    draw_text(rect.x+32, rect.y, rect.width-32, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # list_colour
  #--------------------------------------------------------------------------
  def list_colour(actor)
    return text_color(YEA::PARTY::IN_PARTY_COLOUR) if in_party?(actor)
    return normal_color
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_locked
  #--------------------------------------------------------------------------
  def draw_actor_locked(actor, rect)
    return unless actor.locked
    draw_icon(Icon.locked_party, rect.width-24, rect.y)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_required
  #--------------------------------------------------------------------------
  def draw_actor_required(actor, rect)
    return if actor.locked
    return unless actor.required
    draw_icon(Icon.required_party, rect.width-24, rect.y)
  end
  
  #--------------------------------------------------------------------------
  # enabled?
  #--------------------------------------------------------------------------
  def enabled?(actor)
    return false if actor.locked
    return false if actor.required && in_party?(actor)
    return actor.exist?
  end
  
  #--------------------------------------------------------------------------
  # in_party?
  #--------------------------------------------------------------------------
  def in_party?(actor); return $game_party.battle_members.include?(actor); end
  
  #--------------------------------------------------------------------------
  # current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?
    actor = $game_actors[item]
    replace = $game_actors[@party_window.item]
    unless actor.nil?
      return false if actor.locked && in_party?(actor)
      return false if actor.required && in_party?(actor)
    end
    return true if replace.nil?
    return false if replace.locked
    return false if replace.required
    return true if actor.nil?
    return actor.exist?
  end
  
  #--------------------------------------------------------------------------
  # item
  #--------------------------------------------------------------------------
  def item; return @data[index]; end
  
end # Window_PartyList

#==============================================================================
# ** Window_PartyStatus
#==============================================================================

class Window_PartyStatus < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(party_window, list_window)
    super(200, fitting_height(4), window_width, window_height)
    @party_window = party_window
    @list_window = list_window
    @actor = active_actor
    refresh
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; Graphics.width - 200; end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height; Graphics.height - fitting_height(4); end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    refresh if @actor != active_actor
  end
  
  #--------------------------------------------------------------------------
  # active_actor
  #--------------------------------------------------------------------------
  def active_actor
    if @list_window.active
      actor = @list_window.item
    else
      actor = @party_window.item
    end
    return nil if [0, nil].include?(actor)
    return actor
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    @actor = active_actor
    reset_font_settings
    if @actor.nil?
      draw_nil_actor
      return
    end
    actor = $game_actors[@actor]
    draw_actor_face(actor, 0, 0)
    draw_actor_name(actor, 108, 0)
    draw_actor_class(actor, 228, 0, contents.width-232)
    draw_actor_level(actor, 108, line_height)
    draw_actor_icons(actor, 228, line_height, contents.width-232)
    draw_actor_hp(actor, 108, line_height*2, contents.width-112)
    draw_actor_mp(actor, 108, line_height*3, contents.width-112)
    draw_actor_parameters(actor, 0, line_height*4 + line_height/2)
    draw_equipments(actor, contents.width/2, line_height*4 + line_height/2)
  end
  
  #--------------------------------------------------------------------------
  # draw_nil_actor
  #--------------------------------------------------------------------------
  def draw_nil_actor
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(0, 0, contents.width, contents.height)
    contents.fill_rect(rect, colour)
    change_color(system_color)
    text = YEA::PARTY::NO_DATA
    draw_text(rect, text, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_parameters
  #--------------------------------------------------------------------------
  def draw_actor_parameters(actor, dx, dy)
    dw = contents.width/2 - 4
    rect = Rect.new(dx+1, dy+1, dw - 2, line_height - 2)
    contents.font.size = YEA::PARTY::STAT_FONT_SIZE
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    array = [:atk, :def, :mat, :mdf, :agi, :luk]
    cx = 4
    for stat in array
      case stat
      when :atk
        param = Vocab::param(2)
        value = actor.atk.group
      when :def
        param = Vocab::param(3)
        value = actor.def.group
      when :mat
        param = Vocab::param(4)
        value = actor.mat.group
      when :mdf
        param = Vocab::param(5)
        value = actor.mdf.group
      when :agi
        param = Vocab::param(6)
        value = actor.agi.group
      when :luk
        param = Vocab::param(7)
        value = actor.luk.group
      else; next
      end
      contents.fill_rect(rect, colour)
      change_color(system_color)
      draw_text(rect.x + cx, rect.y, rect.width-cx*2, line_height, param, 0)
      change_color(normal_color)
      draw_text(rect.x + cx, rect.y, rect.width-cx*2, line_height, value, 2)
      rect.y += line_height
    end
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # draw_equipments
  #--------------------------------------------------------------------------
  def draw_equipments(actor, dx, dy)
    text = YEA::PARTY::EQUIP_TEXT
    change_color(system_color)
    draw_text(dx, dy, contents.width - dx, line_height, text, 1)
    dy += line_height
    if actor.equips.size <= 5
      actor.equips.each_with_index do |item, i|
        draw_item_name(item, dx, dy + line_height * i)
      end
    else
      orig_x = dx
      actor.equips.each_with_index do |item, i|
        next if item.nil?
        draw_icon(item.icon_index, dx, dy)
        dy += line_height if dx + 48 > contents.width
        dx = dx + 48 > contents.width ? orig_x : dx + 24
      end
    end
  end
  
end # Window_PartyStatus

#==============================================================================
# ■ Scene_Menu
#==============================================================================

class Scene_Menu < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # overwrite method: command_formation
  #--------------------------------------------------------------------------
  if YEA::PARTY::ENABLE_MENU
  def command_formation
    SceneManager.call(Scene_Party)
  end
  end # YEA::PARTY::ENABLE_MENU
  
end # Scene_Menu

#==============================================================================
# ■ Scene_Party
#==============================================================================

class Scene_Party < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # start
  #--------------------------------------------------------------------------
  def start
    super
    @former_party = $game_party.battle_members_array.clone
    create_command_window
    create_party_window
    create_list_window
    create_status_window
  end
  
  #--------------------------------------------------------------------------
  # create_command_window
  #--------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_PartyMenuCommand.new(0, 0)
    @command_window.set_handler(:change, method(:adjust_members))
    @command_window.set_handler(:remove, method(:adjust_members))
    @command_window.set_handler(:revert, method(:revert_party))
    @command_window.set_handler(:finish, method(:return_scene))
    @command_window.set_handler(:cancel, method(:return_scene))
  end
  
  #--------------------------------------------------------------------------
  # create_party_window
  #--------------------------------------------------------------------------
  def create_party_window
    @party_window = Window_PartySelect.new(@command_window)
    @party_window.set_handler(:ok,       method(:on_party_ok))
    @party_window.set_handler(:cancel,   method(:on_party_cancel))
    @party_window.set_handler(:pageup,   method(:on_party_pageup))
    @party_window.set_handler(:pagedown, method(:on_party_pagedown))
  end
  
  #--------------------------------------------------------------------------
  # create_list_window
  #--------------------------------------------------------------------------
  def create_list_window
    @list_window = Window_PartyList.new(@party_window)
    @list_window.set_handler(:ok,     method(:on_list_ok))
    @list_window.set_handler(:cancel, method(:on_list_cancel))
  end
  
  #--------------------------------------------------------------------------
  # create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    @status_window = Window_PartyStatus.new(@party_window, @list_window)
  end
  
  #--------------------------------------------------------------------------
  # adjust_members
  #--------------------------------------------------------------------------
  def adjust_members
    @party_window.activate
  end
  
  #--------------------------------------------------------------------------
  # window_refresh
  #--------------------------------------------------------------------------
  def window_refresh
    $game_party.rearrange_actors
    @command_window.refresh
    @party_window.refresh
    @list_window.refresh
    $game_player.refresh
    $game_map.need_refresh = true
  end
  
  #--------------------------------------------------------------------------
  # revert_party
  #--------------------------------------------------------------------------
  def revert_party
    @command_window.activate
    $game_party.battle_members_array = @former_party.clone
    window_refresh
  end
  
  #--------------------------------------------------------------------------
  # on_party_ok
  #--------------------------------------------------------------------------
  def on_party_ok
    case @command_window.current_symbol
    when :change
      @list_window.activate
    when :remove
      index = @party_window.index
      actor = $game_actors[$game_party.battle_members_array[index]]
      Sound.play_equip
      $game_party.battle_members_array[index] = 0
      window_refresh
      @party_window.activate
    end
  end
  
  #--------------------------------------------------------------------------
  # on_party_cancel
  #--------------------------------------------------------------------------
  def on_party_cancel
    @command_window.activate
  end
  
  #--------------------------------------------------------------------------
  # on_party_pageup
  #--------------------------------------------------------------------------
  def on_party_pageup
    Sound.play_equip
    actor_id1 = @party_window.item
    actor_id2 = @party_window.prev_actor.nil? ? 0 : @party_window.prev_actor.id
    max = @party_window.item_max-1
    index1 = @party_window.index
    index2 = @party_window.index == 0 ? max : index1-1
    $game_party.battle_members_array[index1] = actor_id2
    $game_party.battle_members_array[index2] = actor_id1
    window_refresh
  end
  
  #--------------------------------------------------------------------------
  # on_party_pagedown
  #--------------------------------------------------------------------------
  def on_party_pagedown
    Sound.play_equip
    actor_id1 = @party_window.item
    actor_id2 = @party_window.next_actor.nil? ? 0 : @party_window.next_actor.id
    max = @party_window.item_max-1
    index1 = @party_window.index
    index2 = @party_window.index == max ? 0 : index1+1
    $game_party.battle_members_array[index1] = actor_id2
    $game_party.battle_members_array[index2] = actor_id1
    window_refresh
  end
  
  #--------------------------------------------------------------------------
  # on_list_cancel
  #--------------------------------------------------------------------------
  def on_list_cancel
    @party_window.activate
  end
  
  #--------------------------------------------------------------------------
  # on_list_ok
  #--------------------------------------------------------------------------
  def on_list_ok
    Sound.play_equip
    replace = $game_actors[@party_window.item]
    actor = $game_actors[@list_window.item]
    index1 = @party_window.index
    actor_id1 = actor.nil? ? 0 : actor.id
    if actor.nil?
      $game_party.battle_members_array[index1] = 0
      window_refresh
      @party_window.activate
      return
    end
    actor_id2 = replace.nil? ? 0 : replace.id
    if $game_party.battle_members_array.include?(actor_id1)
      index2 = $game_party.battle_members_array.index(actor_id1)
      $game_party.battle_members_array[index2] = actor_id2
    end
    $game_party.battle_members_array[index1] = actor_id1
    window_refresh
    @party_window.activate
  end
  
end # Scene_Party

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================





#==============================================================================
# 
# ▼ Yanfly Engine Ace - Party Sized Menu v1.00
# -- Last Updated: 2012.01.05
# -- Level: Easy
# -- Requires: Requires YEA - Ace Menu Engine v1.00+
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-PartySizedMenu"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.05 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This is just a small script to adjust the size of the party window in the
# main menu and other menus to the maximum possible battle members (up to a
# maximum of 5 members) to show up on screen without leaving out vital data.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
# This script requires Yanfly Engine Ace - Ace Menu Engine v1.00+. Place this
# script under Yanfly Engine Ace - Ace Menu Engine in the script listing.
# 
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

if $imported["YEA-AceMenuEngine"]

#==============================================================================
# ■ Window_MenuStatus
#==============================================================================

class Window_MenuStatus < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: item_height
  #--------------------------------------------------------------------------
  def item_height
    return (height - standard_padding * 2) / member_size
  end
  
  #--------------------------------------------------------------------------
  # new method: member_size
  #--------------------------------------------------------------------------
  def member_size
    return [$game_party.max_battle_members, 6].min
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_face
  #--------------------------------------------------------------------------
  def draw_face(face_name, face_index, dx, dy, enabled = true)
    bitmap = Cache.face(face_name)
    ry = [(96 - item_rect(0).height + 1) / 2, 0].max
    rh = [item_rect(0).height - 2, 96].min
    rect = Rect.new(face_index % 4 * 96, face_index / 4 * 96 + ry, 96, rh)
    contents.blt(dx, dy, bitmap, rect, enabled ? 255 : translucent_alpha)
    bitmap.dispose
  end
  
end # Window_MenuStatus

end # $imported["YEA-AceMenuEngine"]

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================